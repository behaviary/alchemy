{"version":3,"sources":["../out/near.ts","~lib/memory.ts","~lib/internal/allocator.ts","~lib/internal/arraybuffer.ts","~lib/internal/string.ts","~lib/internal/typedarray.ts","~lib/internal/memory.ts","../out/json/decoder.ts","~lib/string.ts"],"names":[],"mappings":"","sourceRoot":"assemblyscript:///","sourceContents":["const DEFAULT_SCRATCH_BUFFER_SIZE: usize = 1 << 16;\n\ntype DataTypeIndex = u32;\n\nconst DATA_TYPE_ORIGINATOR_ACCOUNT_ID: DataTypeIndex = 1;\nconst DATA_TYPE_CURRENT_ACCOUNT_ID: DataTypeIndex = 2;\nconst DATA_TYPE_STORAGE: DataTypeIndex = 3;\nconst DATA_TYPE_INPUT: DataTypeIndex = 4;\nconst DATA_TYPE_RESULT: DataTypeIndex = 5;\nconst DATA_TYPE_STORAGE_ITER: DataTypeIndex = 6;\n\n/**\n * Represents contract storage.\n */\nexport class Storage {\n  private _scratchBuf: Uint8Array = new Uint8Array(DEFAULT_SCRATCH_BUFFER_SIZE);\n\n  /**\n   * Internal method to fetch list of keys from the given iterator up the limit.\n   */\n  private _fetchIter(iterId: u32, limit: i32 = -1): string[] {\n    let result: string[] = new Array<string>();\n    while (limit-- != 0) {\n      let key = this._internalReadString(DATA_TYPE_STORAGE_ITER, 0, iterId);\n      if (key != null) {\n        result.push(key);\n      }\n      if (!storage_iter_next(iterId)) {\n        break;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Returns list of keys between the given start key and the end key. Both inclusive.\n   * NOTE: Must be very careful to avoid exploding amount of compute with this method.\n   * @param start The start key used as a lower bound in lexicographical order. Inclusive.\n   * @param end The end key used as a upper bound in lexicographical order. Inclusive.\n   * @param limit The maximum number of keys to return. Default is `-1`, means no limit.\n   */\n  keyRange(start: string, end: string, limit: i32 = -1): string[] {\n    return this._fetchIter(\n      storage_range(start.lengthUTF8 - 1, start.toUTF8(), end.lengthUTF8 - 1, end.toUTF8()),\n      limit,\n    );\n  }\n\n  /**\n   * Returns list of keys starting with given prefix.\n   * NOTE: Must be very careful to avoid exploding amount of compute with this method.\n   * @param prefix The key prefix.\n   * @param limit The maximum number of keys to return. Default is `-1`, means no limit.\n   */\n  keys(prefix: string, limit: i32 = -1): string[] {\n    return this._fetchIter(\n      storage_iter(prefix.lengthUTF8 - 1, prefix.toUTF8()),\n      limit,\n    );\n  }\n\n  /**\n   * @deprecated Use setString or set<string>\n   */\n  setItem(key: string, value: string): void {\n    this.setString(key, value);\n  }\n\n  /**\n   * @deprecated Use getString or get<string>\n   */\n  getItem(key: string): string {\n    return this.getString(key);\n  }\n\n  /**\n   * Store string value under given key. Both key and value are encoded as UTF-8 strings.\n   */\n  setString(key: string, value: string): void {\n    storage_write(key.lengthUTF8 - 1, key.toUTF8(), value.lengthUTF8 - 1, value.toUTF8());\n  }\n\n  /**\n   * Get string value stored under given key. Both key and value are encoded as UTF-8 strings.\n   */\n  getString(key: string): string {\n    return this._internalReadString(DATA_TYPE_STORAGE, key.lengthUTF8 - 1, key.toUTF8());\n  }\n\n  /**\n   * Store byte array under given key. Key is encoded as UTF-8 strings.\n   * Byte array stored as is.\n   *\n   * It's convenient to use this together with `domainObject.encode()`.\n   */\n  setBytes(key: string, value: Uint8Array): void {\n    storage_write(key.lengthUTF8 - 1, key.toUTF8(), value.byteLength, value.buffer.data);\n  }\n\n  /**\n   * Get byte array stored under given key. Key is encoded as UTF-8 strings.\n   * Byte array stored as is.\n   *\n   * It's convenient to use this together with `DomainObject.decode()`.\n   */\n  getBytes(key: string): Uint8Array {\n    return this._internalReadBytes(DATA_TYPE_STORAGE, key.lengthUTF8 - 1, key.toUTF8());\n  }\n\n  /**\n   * Returns true if the given key is present in the storage.\n   */\n  contains(key: string): bool {\n    return storage_has_key(key.lengthUTF8 - 1, key.toUTF8());\n  }\n\n  @inline\n  hasKey(key: string): bool {\n    return this.contains(key);\n  }\n\n  delete(key: string): void {\n    storage_remove(key.lengthUTF8 - 1, key.toUTF8());\n  }\n\n  /**\n   * @deprecated Use #delete\n   */\n  @inline\n  remove(key: string): void {\n    this.delete(key);\n  }\n\n  /**\n   * @deprecated Use #delete\n   */\n  @inline\n  removeItem(key: string): void {\n    this.delete(key);\n  }\n\n  /**\n   * Store 64-bit unsigned int under given key. Key is encoded as UTF-8 strings.\n   * Number is encoded as decimal string.\n   */\n  setU64(key: string, value: u64): void {\n    this.setItem(key, value.toString());\n  }\n\n  /**\n   * Get 64-bit unsigned int stored under given key. Key is encoded as UTF-8 strings.\n   * Number is encoded as decimal string.\n   *\n   * @returns int value or 0 if value is not found\n   */\n  getU64(key: string): u64 {\n    return U64.parseInt(this.getItem(key) || \"0\");\n  }\n\n  /**\n   * Stores given generic value under the key. Key is encoded as UTF-8 strings.\n   * Supported types: bool, integer, string and data objects defined in model.ts.\n   *\n   * @param key A key to use for storage.\n   * @param value A value to store.\n   */\n  set<T>(key: string, value: T): void {\n    if (isString<T>()) {\n      this.setString(key, value);\n    } else if (isInteger<T>()) {\n      this.setString(key, value.toString());\n    } else {\n      this.setBytes(key, value.encode());\n    }\n  }\n\n  /**\n   * Gets given generic value stored under the key. Key is encoded as UTF-8 strings.\n   * Supported types: bool, integer, string and data objects defined in model.ts.\n   *\n   * @param key A key to read from storage.\n   * @param defaultValue The default value if the key is not available\n   * @returns A value of type T stored under the given key.\n   */\n  get<T>(key: string, defaultValue: T = null): T {\n    if (isString<T>() || isInteger<T>()) {\n      return near.parseFromString<T>(this.getString(key), defaultValue);\n    } else {\n      return near.parseFromBytes<T>(this.getBytes(key), defaultValue);\n    }\n  }\n\n  /**\n   * @hidden\n   * Reads given params into the internal scratch buffer and returns length.\n   */\n  private _internalBufferRead(dataType: DataTypeIndex, keyLen: usize, key: usize): usize {\n    for (let i = 0; i < 2; ++i) {\n      let len = data_read(\n        dataType,\n        keyLen,\n        key,\n        this._scratchBuf.byteLength,\n        this._scratchBuf.buffer.data,\n      );\n      if (len <= <usize>(this._scratchBuf.byteLength)) {\n        return len;\n      }\n      this._scratchBuf = new Uint8Array(len);\n    }\n    assert(false, \"Internal scratch buffer was resized more than once\");\n    return 0;\n  }\n\n  /**\n   * @hidden\n   * Reads a string for the given params.\n   */\n  _internalReadString(dataType: DataTypeIndex, keyLen: usize, key: usize): string {\n    let len = this._internalBufferRead(dataType, keyLen, key);\n    if (len == 0) {\n      return null;\n    }\n    return String.fromUTF8(this._scratchBuf.buffer.data, len);\n  }\n\n  /**\n   * @hidden\n   * Reads bytes for the given params.\n   */\n  _internalReadBytes(dataType: DataTypeIndex, keyLen: usize, key: usize): Uint8Array {\n    let len = this._internalBufferRead(dataType, keyLen, key);\n    if (len == 0) {\n      return null;\n    }\n    let res = new Uint8Array(len);\n    memory.copy(res.buffer.data, this._scratchBuf.buffer.data, len);\n    return res;\n  }\n}\n\n/**\n * An instance of a Storage class that is used for working with contract storage on the blockchain.\n */\nexport let storage: Storage = new Storage();\n\n/**\n * A namespace with classes and functions for persistent collections on the blockchain.\n */\nexport namespace collections {\n  const _KEY_LENGTH_SUFFIX = \":len\";\n  const _KEY_FRONT_INDEX_SUFFIX = \":front\";\n  const _KEY_BACK_INDEX_SUFFIX = \":back\";\n  const _KEY_ELEMENT_SUFFIX = \"::\";\n  const _KEY_RATING_SUFFIX = \":r\";\n  const _RATING_OFFSET: u64 = 2147483648;\n\n  /**\n   * A vector class that implements a persistent array.\n   */\n  export class Vector<T> {\n    private _elementPrefix: string;\n    private _lengthKey: string;\n    private _length: i32;\n\n    /**\n     * Creates or restores a persistent vector with a given storage prefix.\n     * Always use a unique storage prefix for different collections.\n     * @param prefix A prefix to use for every key of this vector.\n     */\n    constructor(prefix: string) {\n      this._elementPrefix = prefix + _KEY_ELEMENT_SUFFIX;\n      this._lengthKey = prefix + _KEY_LENGTH_SUFFIX;\n      this._length = -1;\n    }\n\n    /**\n     * @returns An interal key for a given index.\n     */\n    @inline\n    private _key(index: i32): string {\n      return this._elementPrefix + index.toString();\n    }\n\n    /**\n     * Removes the content of the element from storage without changing length of the vector.\n     * @param index The index of the element to remove.\n     */\n    delete(index: i32): void {\n      assert(this.containsIndex(index), \"Index out of range\");\n      storage.delete(this._key(index));\n    }\n\n    /**\n     * @param index The index to check.\n     * @returns True if the given index is within the range of the vector indices.\n     */\n    containsIndex(index: i32): bool {\n      return index >= 0 && index < this.length;\n    }\n\n    /**\n     * @returns True if the vector is empty.\n     */\n    get isEmpty(): bool {\n      return this.length == 0;\n    }\n\n    /**\n     * @returns The length of the vector.\n     */\n    get length(): i32 {\n      if (this._length < 0) {\n        this._length = storage.get<i32>(this._lengthKey, 0);\n      }\n      return this._length;\n    }\n\n    /**\n     * Internally sets the length of the vector\n     */\n    private set length(value: i32) {\n      this._length = value;\n      storage.set<i32>(this._lengthKey, value);\n    }\n\n    /**\n     * Returns the element of the vector for a given index. Asserts the given index is within the\n     * range of the vector.\n     * @param index The index of the element to return.\n     * @returns The element at the given index.\n     */\n    @operator(\"[]\")\n    private __get(index: i32): T {\n      assert(this.containsIndex(index), \"Index out of range\");\n      return this.__unchecked_get(index);\n    }\n\n    /**\n     * Returns the element of the vector for a given index without checks.\n     * @param index The index of the element to return.\n     * @returns The element at the given index.\n     */\n    @operator(\"{}\")\n    private __unchecked_get(index: i32): T {\n      return storage.get<T>(this._key(index));\n    }\n\n    /**\n     * Sets the value of an element at the given index. Asserts the given index is within the\n     * range of the vector.\n     * @param index The index of the element.\n     * @param value The new value.\n     */\n    @operator(\"[]=\")\n    private __set(index: i32, value: T): void {\n      assert(this.containsIndex(index), \"Index out of range\");\n      this.__unchecked_set(index, value);\n    }\n\n    /**\n     * Sets the value of an element at the given index without checks.\n     * @param index The index of the element.\n     * @param value The new value.\n     */\n    @operator(\"{}=\")\n    private __unchecked_set(index: i32, value: T): void {\n      storage.set<T>(this._key(index), value);\n    }\n\n    /**\n     * Adds a new element to the end of the vector. Increases the length of the vector.\n     * @param element A new element to add.\n     * @returns The index of a newly added element\n     */\n    push(element: T): i32 {\n      let index = this.length;\n      this.length = index + 1;\n      this.__unchecked_set(index, element);\n      return index;\n    }\n\n    /**\n     * Adds a new element to the end of the vector. Increases the length of the vector.\n     * @param element A new element to add.\n     * @returns The index of a newly added element\n     */\n    @inline\n    pushBack(element: T): i32 {\n      return this.push(element);\n    }\n\n    /**\n     * Removes the last element from the vector and returns it. Asserts that the vector is not empty.\n     * Decreases the length of the vector.\n     * @returns The removed last element of the vector.\n     */\n    pop(): T {\n      assert(this.length > 0, \"Vector is empty\");\n      let index = this.length - 1;\n      this.length = index;\n      let result = this.__unchecked_get(index);\n      storage.delete(this._key(index));\n      return result;\n    }\n\n    /**\n     * Removes the last element from the vector and returns it. Asserts that the vector is not empty.\n     * Decreases the length of the vector.\n     * @returns The removed last element of the vector.\n     */\n    @inline\n    popBack(): T {\n      return this.pop();\n    }\n\n    /**\n     * @returns The last element of the vector. Asserts that the vector is not empty.\n     */\n    get back(): T {\n      return this.__get(this.length - 1);\n    }\n\n    /**\n     * @returns The last element of the vector. Asserts that the vector is not empty.\n     */\n    @inline\n    get last(): T {\n      return this.back;\n    }\n\n    /**\n     * @returns The first element of the vector. Asserts that the vector is not empty.\n     */\n    get front(): T {\n      return this.__get(0);\n    }\n\n    /**\n     * @returns The first element of the vector. Asserts that the vector is not empty.\n     */\n    @inline\n    get first(): T {\n      return this.front;\n    }\n  }\n\n\n  /**\n   * A deque class that implements a persistent bidirectional queue.\n   */\n  export class Deque<T> {\n    private _elementPrefix: string;\n    private _frontIndexKey: string;\n    private _backIndexKey: string;\n    private _frontIndex: i32;\n    private _backIndex: i32;\n\n    /**\n     * Creates or restores a persistent deque with a given storage prefix.\n     * Always use a unique storage prefix for different collections.\n     * @param prefix A prefix to use for every key of this deque.\n     */\n    constructor(prefix: string) {\n      this._elementPrefix = prefix + _KEY_ELEMENT_SUFFIX;\n      this._frontIndexKey = prefix + _KEY_FRONT_INDEX_SUFFIX;\n      this._backIndexKey = prefix + _KEY_BACK_INDEX_SUFFIX;\n      this._frontIndex = i32.MIN_VALUE;\n      this._backIndex = i32.MAX_VALUE;\n    }\n\n    /**\n     * @returns An interal key for a given index.\n     */\n    @inline\n    private _key(index: i32): string {\n      return this._elementPrefix + index.toString();\n    }\n\n    /**\n     * @returns The index of the first/front element of the deque (inclusive).\n     */\n    private get frontIndex(): i32 {\n      if (this._frontIndex == i32.MIN_VALUE) {\n        this._frontIndex = storage.get<i32>(this._frontIndexKey, 0);\n      }\n      return this._frontIndex;\n    }\n\n    /**\n     * Internal. Sets the index of the first/front element.\n     */\n    private set frontIndex(value: i32) {\n      this._frontIndex = value;\n      storage.set<i32>(this._frontIndexKey, value);\n    }\n\n    /**\n     * @returns The index of the last/back element of the deque (inclusive).\n     */\n    private get backIndex(): i32 {\n      if (this._backIndex == i32.MAX_VALUE) {\n        this._backIndex = storage.get<i32>(this._backIndexKey, -1);\n      }\n      return this._backIndex;\n    }\n\n    /**\n     * Internal. Sets the index of the last/back element.\n     */\n    private set backIndex(value: i32) {\n      this._backIndex = value;\n      storage.set<i32>(this._backIndexKey, value);\n    }\n\n    /**\n     * @param index The index to check.\n     * @returns True if the given index is within the range of the deque indices.\n     */\n    containsIndex(index: i32): bool {\n      return index >= 0 && index < this.length;\n    }\n\n    /**\n     * Removes the content of the element from storage without changing length of the deque.\n     * @param index The index of the element to remove.\n     */\n    delete(index: i32): void {\n      assert(this.containsIndex(index), \"Index out of range\");\n      storage.delete(this._key(index + this.frontIndex));\n    }\n\n    /**\n     * @returns The length of the deque.\n     */\n    get length(): i32 {\n      return this.backIndex - this.frontIndex + 1;\n    }\n\n    /**\n     * @returns True if the deque is empty.\n     */\n    get isEmpty(): bool {\n      return this.length == 0;\n    }\n\n    /**\n     * Returns the element of the deque for a given index. Asserts the given index is within the\n     * range of the vector.\n     * @param index The index of the element to return.\n     * @returns The element at the given index.\n     */\n    @operator(\"[]\")\n    private __get(index: i32): T {\n      assert(this.containsIndex(index), \"Index out of range\");\n      return this.__unchecked_get(index);\n    }\n\n    /**\n     * Returns the element of the deque for a given index without checks.\n     * @param index The index of the element to return.\n     * @returns The element at the given index.\n     */\n    @operator(\"{}\")\n    private __unchecked_get(index: i32): T {\n      return storage.get<T>(this._key(index + this.frontIndex));\n    }\n\n    /**\n     * Sets the new value of an element at the given index. Asserts the given index is within the\n     * range of the deque.\n     * @param index The index of the element.\n     * @param value The new value.\n     */\n    @operator(\"[]=\")\n    private __set(index: i32, value: T): void {\n      assert(this.containsIndex(index), \"Index out of range\");\n      this.__unchecked_set(index, value);\n    }\n\n    /**\n     * Sets the new value of an element at the given index without checks.\n     * @param index The index of the element.\n     * @param value The new value.\n     */\n    @operator(\"{}=\")\n    private __unchecked_set(index: i32, value: T): void {\n      storage.set<T>(this._key(index + this.frontIndex), value);\n    }\n\n    /**\n     * Adds a new element in front of the deque. Increases the length of the deque.\n     * @param element A new element to add.\n     * @returns The index of a newly added element\n     */\n    pushFront(element: T): i32 {\n      this.frontIndex -= 1;\n      this.__unchecked_set(0, element);\n      return 0;\n    }\n\n    /**\n     * Removes the first/front element from the deque and returns it.\n     * Asserts that the deque is not empty. Decreases the length of the deque.\n     * @returns The removed first element of the queue.\n     */\n    popFront(): T {\n      assert(this.length > 0, \"Deque is empty\");\n      let result = this.__unchecked_get(0);\n      storage.delete(this._key(this.frontIndex));\n      this.frontIndex += 1;\n      return result;\n    }\n\n    /**\n     * @returns The first/front element of the deque.\n     */\n    get front(): T {\n      return this.__get(0);\n    }\n\n    /**\n     * @returns The first/front element of the deque.\n     */\n    @inline\n    get first(): T {\n      return this.front;\n    }\n\n    /**\n     * Adds a new element to the end of the deque. Increases the length of the deque.\n     * @param element A new element to add.\n     * @returns The index of a newly added element\n     */\n    pushBack(element: T): i32 {\n      let index = this.length;\n      this.backIndex += 1;\n      this.__unchecked_set(index, element);\n      return index;\n    }\n\n    /**\n     * Removes the last/back element from the deque and returns it.\n     * Asserts that the deque is not empty. Decreases the length of the deque.\n     * @returns The removed first element of the queue.\n     */\n    popBack(): T {\n      let index = this.length - 1;\n      assert(index >= 0, \"Deque is empty\");\n      let result = this.__unchecked_get(index);\n      storage.delete(this._key(this.backIndex));\n      this.backIndex -= 1;\n      return result;\n    }\n\n    /**\n     * @returns The last/back element of the deque.\n     */\n    get back(): T {\n      return this.__get(this.length - 1);\n    }\n\n    /**\n     * @returns The last/back element of the deque.\n     */\n    @inline\n    get last(): T {\n      return this.back;\n    }\n  }\n\n\n  /**\n   * A map class that implements a persistent unordered map.\n   * NOTE: The Map doesn't store keys, so if you need to retrive them, include keys in the values.\n   */\n  export class Map<K, V> {\n    private _elementPrefix: string;\n\n    /**\n     * Creates or restores a persistent map with a given storage prefix.\n     * Always use a unique storage prefix for different collections.\n     * @param prefix A prefix to use for every key of this map.\n     */\n    constructor(prefix: string) {\n      this._elementPrefix = prefix + _KEY_ELEMENT_SUFFIX;\n    }\n\n    /**\n     * @returns An interal string key for a given key of type K.\n     */\n    private _key(key: K): string {\n      return this._elementPrefix + key.toString();\n    }\n\n    /**\n     * Returns values of the map between the given start key and the end key.\n     * @param start Starting from which key to include values. Default is `null`, means from the beginning.\n     * @param end Up to which key include values (inclusive). Default is `null`, means to the end.\n     * @param limit The maximum number of values to return. Default is `-1`, means no limit.\n     * @param startInclusive Whether the start key is inclusive. Default is `true`, means include start key.\n     *     It's useful to set it to false for pagination.\n     */\n    values(start: K = null, end: K = null, limit: i32 = -1, startInclusive: bool = true): V[] {\n      let startKey = (start != null) ? this._key(start) : this._elementPrefix;\n      if (!startInclusive) {\n        startKey += String.fromCharCode(0);\n      }\n      let endKey = (end != null) ? this._key(end) : (this._elementPrefix + String.fromCharCode(255));\n      let keys = storage.keyRange(startKey, endKey, limit);\n      return keys.map<V>((key: string) => storage.get<V>(key));\n    }\n\n    /**\n     * @param key Key to check.\n     * @returns True if the given key present in the map.\n     */\n    contains(key: K): bool {\n      return storage.contains(this._key(key));\n    }\n\n    /**\n     * Removes value and the key from the map.\n     * @param key Key to remove.\n     */\n    delete(key: K): void {\n      storage.delete(this._key(key));\n    }\n\n    /**\n     * @param key Key of the element.\n     * @param defaultValue The default value if the key is not present.\n     * @returns Value for the given key or the default value.\n     */\n    get(key: K, defaultValue: V = null): V {\n      return storage.get<V>(this._key(key), defaultValue);\n    }\n\n    /**\n     * Sets the new value for the given key.\n     * @param key Key of the element.\n     * @param value The new value of the element.\n     */\n    set(key: K, value: V): void {\n      storage.set<V>(this._key(key), value);\n    }\n  }\n\n  /**\n   * A TopN class that can return first N keys of a type K sorted by rating. Rating is stored as i32.\n   * Default sort order is descending (highest rated keys), but can be changed to ascending (lowest rated keys).\n   */\n  export class TopN<K> {\n    // Internally, this prefix is used for storing padded ratings\n    private _orderPrefix: string;\n    // Whether the order is descending\n    private _descending: bool;\n    // Number of unique keys.\n    private _length: i32;\n    // The key to store length.\n    private _lengthKey: string;\n\n    // A map to store rating by key\n    private _ratings: Map<K, i32>;\n\n    /**\n     * Creates or restores a persistent top N collection with a given storage prefix.\n     * Always use a unique storage prefix for different collections.\n     * @param prefix A prefix to use for every key of this collection.\n     * @param descending Sorting order of keys for rating. Default is descending (the highest rated keys).\n     */\n    constructor(prefix: string, descending: bool = true) {\n      this._ratings = new Map<K, i32>(prefix + _KEY_RATING_SUFFIX);\n      this._orderPrefix = prefix + _KEY_ELEMENT_SUFFIX;\n      this._descending = descending;\n      this._lengthKey = prefix + _KEY_LENGTH_SUFFIX;\n      this._length = -1;\n    }\n\n    /**\n     * @returns A suffix for an internal key for a given external key of type K.\n     */\n    private _keySuffix(key: K): string {\n      return _KEY_ELEMENT_SUFFIX + key.toString();\n    }\n\n    /**\n     * @returns Converted integer rating into a padded string.\n     */\n    private _ratingKey(rating: i32): string {\n      let r: u32 = <u32>((<i64>rating) + _RATING_OFFSET);\n      if (this._descending) {\n        r = u32.MAX_VALUE - r;\n      }\n      return r.toString().padStart(10, \"0\");\n    }\n\n    /**\n     * Creates an internal key from a given rating and a given external key.\n     */\n    private _orderKey(rating: i32, key: K): string {\n      return this._orderPrefix + this._ratingKey(rating) + this._keySuffix(key);\n    }\n\n    /**\n     * @returns True if the TopN collection is empty.\n     */\n    get isEmpty(): bool {\n      return this.length == 0;\n    }\n\n    /**\n     * @returns The number of unique elements in the TopN collection.\n     */\n    get length(): i32 {\n      if (this._length < 0) {\n        this._length = storage.get<i32>(this._lengthKey, 0);\n      }\n      return this._length;\n    }\n\n    /**\n     * Internally sets the length of the collection.\n     */\n    private set length(value: i32) {\n      this._length = value;\n      storage.set<i32>(this._lengthKey, value);\n    }\n\n\n    /**\n     * @param key Key to check.\n     * @returns True if the given key is present.\n     */\n    contains(key: K): bool {\n      return this._ratings.contains(key);\n    }\n\n    /**\n     * Removes rating and the key from the collection.\n     * @param key Key to remove.\n     */\n    delete(key: K): void {\n      if (this.contains(key)) {\n        let rating = this._ratings.get(key);\n        this._ratings.delete(key);\n        storage.delete(this._orderKey(rating, key));\n        this.length -= 1;\n      }\n    }\n\n    /**\n     * @param keys The array of keys to lookup rating.\n     * @returns an array of key to rating pairs for the given keys.\n     */\n    keysToRatings(keys: K[]): near.MapEntry<K, i32>[] {\n      let result = new Array<near.MapEntry<K, i32>>(keys.length);\n      for (let index = 0; index < keys.length; ++index) {\n        let key = keys[index];\n        result[index] = new near.MapEntry<K, i32>(key, this._ratings.get(key));\n      }\n      return result;\n    }\n\n    /**\n     * @param limit The maximum limit of keys to return.\n     * @returns The array of top rated keys.\n     */\n    getTop(limit: i32): K[] {\n      let orderKeys = storage.keys(this._orderPrefix, limit);\n      return orderKeys.map<K>((orderKey: string) => storage.get<K>(orderKey));\n    }\n\n    /**\n     * Returns a top list starting from the given key (exclusive). It's useful for pagination.\n     * @param limit The maximum limit of keys to return.\n     * @param fromKey The key from which return top list (exclisive).\n     * @returns The array of top rated keys starting from the given key.\n     */\n    getTopFromKey(limit: i32, fromKey: K): K[] {\n      let rating = this.getRating(fromKey, 0);\n      let orderKeys = storage.keyRange(\n        this._orderKey(rating, fromKey) + String.fromCharCode(0),\n        this._orderPrefix + String.fromCharCode(255),\n        limit);\n      return orderKeys.map<K>((orderKey: string) => storage.get<K>(orderKey));\n    }\n\n    /**\n     * @param limit The maximum limit of keys to return.\n     * @returns The array of top rated keys with their corresponding rating.\n     */\n    getTopWithRating(limit: i32): near.MapEntry<K, i32>[] {\n      return this.keysToRatings(this.getTop(limit));\n    }\n\n    /**\n     * Returns a top list with rating starting from the given key (exclusive).\n     * It's useful for pagination.\n     * @param limit The maximum limit of keys to return.\n     * @param fromKey The key from which return top list (exclisive).\n     * @returns The array of top rated keys with their rating starting from the given key.\n     */\n    getTopWithRatingFromKey(limit: i32, fromKey: K): near.MapEntry<K, i32>[] {\n      return this.keysToRatings(this.getTopFromKey(limit, fromKey));\n    }\n\n    /**\n     * @param key Key of the element.\n     * @param defaultRating The default rating to return if the key is not present.\n     * @returns Value for the given key or the defaultRating.\n     */\n    getRating(key: K, defaultRating: i32 = 0): i32 {\n      return this._ratings.get(key, defaultRating);\n    }\n\n    /**\n     * Sets the new rating for the given key.\n     * @param key The key to update.\n     * @param rating The new rating of the key.\n     */\n    setRating(key: K, rating: i32): void {\n      if (this.contains(key)) {\n        let oldRating = this.getRating(key);\n        storage.delete(this._orderKey(oldRating, key));\n      } else {\n        this.length += 1;\n      }\n      this._ratings.set(key, rating);\n      storage.set<K>(this._orderKey(rating, key), key);\n    }\n\n    /**\n     * Increments rating of the given key by the given increment (1 by default).\n     * @param key The key to update.\n     * @param increment The increment value for the rating (1 by default).\n     */\n    incrementRating(key: K, increment: i32 = 1): void {\n      let oldRating = 0;\n      if (this.contains(key)) {\n        oldRating = this.getRating(key);\n        storage.delete(this._orderKey(oldRating, key));\n      } else {\n        this.length += 1;\n      }\n      let rating = oldRating + increment;\n      this._ratings.set(key, rating);\n      storage.set<K>(this._orderKey(rating, key), key);\n    }\n  }\n\n  /**\n   * Creates or restores a persistent vector with a given storage prefix.\n   * Always use a unique storage prefix for different collections.\n   * @param prefix A prefix to use for every key of this vector.\n   */\n  export function vector<T>(prefix: string): Vector<T> {\n    return new Vector<T>(prefix);\n  }\n\n  /**\n   * Creates or restores a persistent deque with a given storage prefix.\n   * Always use a unique storage prefix for different collections.\n   * @param prefix A prefix to use for every key of this deque.\n   */\n  export function deque<T>(prefix: string): Deque<T> {\n    return new Deque<T>(prefix);\n  }\n\n  /**\n   * Creates or restores a persistent map with a given storage prefix.\n   * Always use a unique storage prefix for different collections.\n   * @param prefix A prefix to use for every key of this map.\n   */\n  export function map<K, V>(prefix: string): Map<K, V> {\n    return new Map<K, V>(prefix);\n  }\n\n  /**\n   * Creates or restores a persistent TopN with a given storage prefix.\n   * Always use a unique storage prefix for different collections.\n   * @param prefix A prefix to use for every key of this collection.\n   * @param descending Sorting order of keys for rating. Default is descending (the highest rated keys).\n   */\n  export function topN<K>(prefix: string, descending: bool = true): TopN<K> {\n    return new TopN<K>(prefix, descending);\n  }\n}\n\n/**\n * Provides context for contract execution, including information about transaction sender, etc.\n */\nclass Context {\n  /**\n   * Account ID of transaction sender.\n   */\n  get sender(): string {\n    return storage._internalReadString(DATA_TYPE_ORIGINATOR_ACCOUNT_ID, 0, 0);\n  }\n\n  /**\n   * Account ID of contract.\n   */\n  get contractName(): string {\n    return storage._internalReadString(DATA_TYPE_CURRENT_ACCOUNT_ID, 0, 0);\n  }\n\n  /**\n   * Current block index.\n   */\n  get blockIndex(): u64 {\n    return block_index();\n  }\n\n  /**\n   * The amount of tokens received with this execution call.\n   */\n  get receivedAmount(): u64 {\n    return received_amount();\n  }\n\n  /**\n   * The amount of tokens that are locked in the account. Storage usage fee is deducted from this balance.\n   */\n  get frozenBalance(): u64 {\n    return frozen_balance();\n  }\n\n  /**\n   * The amount of tokens that can be used for running wasm, creating transactions, and sending to other contracts\n   * through cross-contract calls.\n   */\n  get liquidBalance(): u64 {\n      return liquid_balance();\n  }\n\n  /**\n   * The current storage usage in bytes.\n   */\n  get storageUsage(): u64 {\n    return storage_usage();\n  }\n\n  /**\n   * Moves assets from liquid balance to frozen balance.\n   * If there is enough liquid balance will deposit the maximum amount. Otherwise will deposit as much as possible.\n   * Will fail if there is less than minimum amount on the liquid balance. Returns the deposited amount.\n   */\n  deposit(minAmount: u64, maxAmount: u64): u64 {\n    deposit(minAmount, maxAmount)\n  }\n\n   /**\n   * Moves assets from frozen balance to liquid balance.\n   * If there is enough frozen balance will withdraw the maximum amount. Otherwise will withdraw as much as possible.\n   * Will fail if there is less than minimum amount on the frozen balance. Returns the withdrawn amount.\n   */\n  withdraw(minAmount: u64, maxAmount: u64): u64 {\n    withdraw(minAmount, maxAmount)\n  }\n}\n\nexport let context: Context = new Context();\n\nexport namespace near {\n\n  /**\n   * Parses the given string to return a value of the given generic type.\n   * Supported types: bool, integer, string and data objects defined in model.ts.\n   *\n   * @param s String to parse.\n   * @param defaultValue The default value if the string is null\n   * @returns A parsed value of type T.\n   */\n  export function parseFromString<T>(s: string, defaultValue: T = null): T {\n    if (s == null) {\n      return defaultValue;\n    }\n    if (isString<T>()) {\n      return s;\n    } else if (isInteger<T>()) {\n      if (defaultValue instanceof bool) {\n        return <T>(s == \"true\");\n      } else if (isSigned<T>()) {\n        return <T>I64.parseInt(s);\n      } else {\n        return <T>U64.parseInt(s);\n      }\n    } else {\n      let v = instantiate<T>();\n      return v.decode(stringToBytes(s));\n    }\n  }\n\n  /**\n   * Parses the given bytes array to return a value of the given generic type.\n   * Supported types: bool, integer, string and data objects defined in model.ts.\n   *\n   * @param bytes Bytes to parse.\n   * @param defaultValue The default value if the bytes are null\n   * @returns A parsed value of type T.\n   */\n  export function parseFromBytes<T>(bytes: Uint8Array, defaultValue: T = null): T {\n    if (bytes == null) {\n      return defaultValue;\n    }\n    if (isString<T>() || isInteger<T>()) {\n      return parseFromString<T>(bytesToString(bytes), defaultValue);\n    } else {\n      let v = instantiate<T>();\n      return v.decode(bytes);\n    }\n  }\n\n  export function bytesToString(bytes: Uint8Array): string {\n    return String.fromUTF8(bytes.buffer.data + bytes.byteOffset, bytes.byteLength)\n  }\n\n  export function stringToBytes(s: string): Uint8Array {\n    let len = s.lengthUTF8 - 1;\n    let bytes = new Uint8Array(len);\n    memory.copy(bytes.buffer.data, s.toUTF8(), len);\n    return bytes;\n  }\n\n  /**\n   * Helper class to store key->value pairs.\n   */\n  export class MapEntry<K, V> {\n    key: K;\n    value: V;\n\n    constructor(key: K, value: V) {\n      this.key = key;\n      this.value = value;\n    }\n  }\n\n  /**\n   * Hash given data. Returns hash as 32-byte array.\n   * @param data data can be passed as either Uint8Array or anything with .toString (hashed as UTF-8 string).\n   */\n  export function hash<T>(data: T): Uint8Array {\n    let result = new Uint8Array(32);\n    if (data instanceof Uint8Array) {\n      _near_hash(data.byteLength, data.buffer.data, result.buffer.data);\n    } else {\n      let str = data.toString();\n      _near_hash(str.lengthUTF8 - 1, str.toUTF8(), result.buffer.data);\n    }\n    return result;\n  }\n\n  /**\n   * Hash given data. Returns hash as 32-bit integer.\n   * @param data data can be passed as either Uint8Array or anything with .toString (hashed as UTF-8 string).\n   */\n  export function hash32<T>(data: T): u32 {\n    let dataToHash : Uint8Array;\n    if (data instanceof Uint8Array) {\n      return _near_hash32(data.byteLength, data.buffer.data);\n    } else {\n      let str = data.toString();\n      return _near_hash32(str.lengthUTF8 - 1, str.toUTF8());\n    }\n  }\n\n  /**\n   * Returns random byte buffer of given length.\n   */\n  export function randomBuffer(len: u32): Uint8Array {\n    let result = new Uint8Array(len);\n    _near_random_buf(len, result.buffer.data);\n    return result;\n  }\n\n  /**\n   * Returns random 32-bit integer.\n   */\n  export function random32(): u32 {\n    return random32();\n  }\n\n  export function log(msg: string): void {\n    _near_log(<usize>msg);\n  }\n\n  export function str<T>(value: T): string {\n    let arr: Array<T> = [value];\n    return arr.toString();\n  }\n\n  export function base58(source: Uint8Array): string {\n    // Code converted from:\n    // https://github.com/cryptocoinjs/base-x/blob/master/index.js\n    const iFACTOR = 2; // TODO: Calculate precise value to avoid overallocating\n    const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n    let BASE = ALPHABET.length;\n    let LEADER = ALPHABET.charAt(0);\n\n    // Skip & count leading zeroes.\n    let zeroes = 0\n    let length = 0\n    let pbegin = 0\n    let pend = source.length\n\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n\n    // Allocate enough space in big-endian base58 representation.\n    let size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    let b58 = new Uint8Array(size)\n\n    // Process the bytes.\n    while (pbegin !== pend) {\n      let carry = i32(source[pbegin])\n\n      // Apply \"b58 = b58 * 256 + ch\".\n      let i = 0\n      for (let it = size - 1; (carry !== 0 || i < length) && (it !== -1); it--, i++) {\n        carry += (256 * b58[it]) >>> 0\n        b58[it] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n\n      assert(carry == 0, 'Non-zero carry');\n      length = i\n      pbegin++\n    }\n\n    // Skip leading zeroes in base58 result.\n    let it = size - length\n    while (it !== size && b58[it] === 0) {\n      it++\n    }\n\n    // Translate the result into a string.\n    let str = LEADER.repeat(zeroes)\n    for (; it < size; ++it) str += ALPHABET.charAt(b58[it])\n\n    return str\n  }\n}\n\n/**\n * Class to make asynchronous calls to other contracts and receive callbacks.\n * Here is an example on how to create a new async call with the callback.\n * ```\n * export function callMetaNear(): void {\n *   let itemArgs: AddItemArgs = {\n *     accountId: \"alice.near\",\n *     itemId: \"Sword +9000\",s\n *   };\n *   let promise = ContractPromise.create(\n *     \"metanear\",\n *     \"addItem\",\n *     itemArgs.encode(),\n *     0,\n *   );\n *   // Setting up args for the callback\n *   let requestArgs: OnItemAddedArgs = {\n *     \"itemAddedRequestId\": \"UNIQUE_REQUEST_ID\",\n *   };\n *   let callbackPromise = promise.then(\n *      \"_onItemAdded\",\n *      requestArgs.encode(),\n *      2,  // Attaching 2 additional requests, in case we need to do another call\n *   );\n *   callbackPromise.returnAsResult();\n * }\n * ```\n * See docs on used methods for more details.\n */\nexport class ContractPromise {\n  // Session-based unique promise ID. Don't preserve it longer than this execution.\n  id: i32;\n\n  /**\n   * Creates a new async call promise. Returns an instance of `ContractPromise`.\n   * The call would be scheduled if the this current execution of the contract succeeds\n   * without errors or failed asserts.\n   * @param contractName Account ID of the remote contract to call. E.g. `metanear`.\n   * @param methodName Method name on the remote contract to call. E.g. `addItem`.\n   * @param args Serialized arguments to pass into the method. To get them create a new model\n   *     specific for the method you calling, e.g. `AddItemArgs`. Then create an instance of it\n   *     and populate arguments. After this, serialize it into bytes. E.g.\n   *     ```\n   *     let itemArgs: AddItemArgs = {\n   *       accountId: \"alice.near\",\n   *       itemId: \"Sword +9000\",\n   *     };\n   *     // Serialize args\n   *     let args = itemArgs.encode();\n   *     ```\n   * @param amount The amount of tokens from your contract to be sent to the remote contract with this call.\n   */\n  static create(\n      contractName: string,\n      methodName: string,\n      args: Uint8Array,\n      amount: u64 = 0\n  ): ContractPromise {\n    return {\n      id: promise_create(\n        contractName.lengthUTF8 - 1, contractName.toUTF8(),\n        methodName.lengthUTF8 - 1, methodName.toUTF8(),\n        args.byteLength, args.buffer.data,\n        amount)\n    };\n  }\n\n  /**\n   * Creating a callback for the AsyncCall Promise created with `create` method.\n   * @param methodName Method name on your contract to be called to receive the callback.\n   *     NOTE: Your callback method name can start with `_`, which would prevent other\n   *     contracts from calling it directly. Only callbacks can call methods with `_` prefix.\n   * @param args Serialized arguments on your callback method, see `create` for details.\n   * @param amount The amount of tokens from the called contract to be sent to the current contract with this call.\n   */\n  then(\n      methodName: string,\n      args: Uint8Array,\n      amount: u64\n  ): ContractPromise {\n    return {\n      id: promise_then(\n        this.id,\n        methodName.lengthUTF8 - 1, methodName.toUTF8(),\n        args.byteLength, args.buffer.data,\n        amount)\n    };\n  }\n\n  /**\n   * Returns the promise as a result of your function. Don't return any other results from the function.\n   * Your current function should be `void` and shouldn't return anything else. E.g.\n   * ```\n   * export function callMetaNear(): void {\n   *   let itemArgs: AddItemArgs = {\n   *     accountId: \"alice.near\",\n   *     itemId: \"Sword +9000\",\n   *   };\n   *   let promise = ContractPromise.create(\n   *     \"metanear\",\n   *     \"addItem\",\n   *     itemArgs.encode(),\n   *     0,\n   *     0,\n   *   );\n   *   promise.returnAsResult();\n   * }\n   * ```\n   *\n   * Now when you call `callMetaNear` method, it creates new promise to `metanear` contract.\n   * And saying that the result of the current execution depends on the result `addItem`.\n   * Even though this contract is not going to be called with a callback, the contract which\n   * calling `callMetaNear` would receive the result from `addItem`. This call essentially acts\n   * as a proxy.\n   *\n   * You can also attach a callback on top of the promise before returning it, e.g.\n   *\n   * ```\n   *   ...\n   *   let promise = ContractPromise.create(\n   *      ...\n   *   );\n   *   // Setting up args for the callback\n   *   let requestArgs: OnItemAddedArgs = {\n   *     \"itemAddedRequestId\": \"UNIQUE_REQUEST_ID\",\n   *   };\n   *   let callbackPromise = promise.then(\n   *      \"_onItemAdded\",\n   *      requestArgs.encode(),\n   *      2,  // Attaching 2 additional requests, in case we need to do another call\n   *   );\n   *   callbackPromise.returnAsResult();\n   * }\n   * ```\n   */\n  returnAsResult(): void {\n    return_promise(this.id);\n  }\n\n  /**\n   * Joins multiple async call promises into one, to aggregate results before the callback.\n   * NOTE: Given promises can only be new async calls and can't be callbacks.\n   * Joined promise can't be returned as a result\n   * @param promises List of async call promises to join.\n   */\n  static all(promises: ContractPromise[]): ContractPromise {\n    assert(promises.length > 0);\n    let id = promises[0].id;\n    for (let i = 1; i < promises.length; i++) {\n      id = promise_and(id, promises[i].id);\n    }\n    return { id };\n  }\n\n  /**\n   * Method to receive async (one or multiple) results from the remote contract in the callback.\n   * Example of using it.\n   * ```\n   * // This function is prefixed with `_`, so other contracts or people can't call it directly.\n   * export function _onItemAdded(itemAddedRequestId: string): bool {\n   *   // Get all results\n   *   let results = ContractPromise.getResults();\n   *   let addItemResult = results[0];\n   *   // Verifying the remote contract call succeeded.\n   *   if (addItemResult.success) {\n   *     // Decoding data from the bytes buffer into the local object.\n   *     let data = AddItemResult.decode(addItemResult.buffer);\n   *     if (data.itemPower > 9000) {\n   *       return true;\n   *     }\n   *   }\n   *   return false;\n   * }\n   * ```\n   * @returns An array of results based on the number of promises the callback was created on.\n   *     If the callback using `then` was scheduled only on one result, then one result will be returned.\n   */\n  static getResults() : ContractPromiseResult[] {\n    let count = <i32>result_count();\n    let results = new Array<ContractPromiseResult>(count);\n    for (let i = 0; i < count; i++) {\n      let isOk = result_is_ok(i);\n      if (!isOk) {\n        results[i] = { success: false }\n        continue;\n      }\n      let buffer = storage._internalReadBytes(DATA_TYPE_RESULT, 0, i);\n      results[i] = { success: isOk, buffer: buffer };\n    }\n    return results;\n  }\n}\n\n/**\n * Class to store results of the async calls on the remote contracts.\n */\nexport class ContractPromiseResult {\n  // Whether the execution of the remote call succeeded.\n  success: bool;\n  // Bytes data returned by the remote contract. Can be empty or null, if the remote\n  // method returns `void`.\n  buffer: Uint8Array;\n}\n\n@external(\"env\", \"storage_write\")\ndeclare function storage_write(key_len: usize, key_ptr: usize, value_len: usize, value_ptr: usize): void;\n@external(\"env\", \"storage_remove\")\ndeclare function storage_remove(key_len: usize, key_ptr: usize): void;\n@external(\"env\", \"storage_has_key\")\ndeclare function storage_has_key(key_len: usize, key_ptr: usize): bool;\n@external(\"env\", \"storage_iter\")\ndeclare function storage_iter(prefix_len: usize, prefix_ptr: usize): u32;\n@external(\"env\", \"storage_range\")\ndeclare function storage_range(start_len: usize, start_ptr: usize, end_len: usize, end_ptr: usize): u32;\n@external(\"env\", \"storage_iter_next\")\ndeclare function storage_iter_next(id: u32): u32;\n\n@external(\"env\", \"result_count\")\ndeclare function result_count(): u32;\n@external(\"env\", \"result_is_ok\")\ndeclare function result_is_ok(index: u32): bool;\n\n@external(\"env\", \"return_value\")\ndeclare function return_value(value_len: usize, value_ptr: usize): void;\n@external(\"env\", \"return_promise\")\ndeclare function return_promise(promise_index: u32): void;\n\n@external(\"env\", \"data_read\")\ndeclare function data_read(type_index: u32, key_len: usize, key: usize, max_buf_len: usize, buf_ptr: usize): usize;\n\n@external(\"env\", \"promise_create\")\ndeclare function promise_create(\n    account_id_len: usize, account_id_ptr: usize,\n    method_name_len: usize, method_name_ptr: usize,\n    args_len: usize, args_ptr: usize,\n    amount: u64): u32;\n\n@external(\"env\", \"promise_then\")\ndeclare function promise_then(\n    promise_index: u32,\n    method_name_len: usize, method_name_ptr: usize,\n    args_len: usize, args_ptr: usize,\n    amount: u64): u32;\n\n@external(\"env\", \"promise_and\")\ndeclare function promise_and(promise_index1: u32, promise_index2: u32): u32;\n\n/**\n * @hidden\n * Hash buffer is 32 bytes\n */\n@external(\"env\", \"hash\")\ndeclare function _near_hash(value_len: usize, value_ptr: usize, buf_ptr: usize): void;\n\n/**\n * @hidden\n */\n@external(\"env\", \"hash32\")\ndeclare function _near_hash32(value_len: usize, value_ptr: usize): u32;\n\n/**\n * @hidden\n * Fills given buffer with random u8.\n */\n@external(\"env\", \"random_buf\")\ndeclare function _near_random_buf(buf_len: u32, buf_ptr: usize): void\n\n/**\n * @hidden\n */\n@external(\"env\", \"random32\")\ndeclare function random32(): u32;\n\n/**\n * @hidden\n */\n@external(\"env\", \"log\")\ndeclare function _near_log(msg_ptr: usize): void;\n\n/**\n * @hidden\n */\n@external(\"env\", \"frozen_balance\")\ndeclare function frozen_balance(): u64;\n\n/**\n * @hidden\n */\n@external(\"env\", \"liquid_balance\")\ndeclare function liquid_balance(): u64;\n\n/**\n * @hidden\n */\n@external(\"env\", \"storage_usage\")\ndeclare function storage_usage(): u64;\n\n/**\n * @hidden\n */\n@external(\"env\", \"deposit\")\ndeclare function deposit(min_amount: u64, max_amount: u64): u64;\n\n/**\n * @hidden\n */\n@external(\"env\", \"withdraw\")\ndeclare function withdraw(min_amount: u64, max_amount: u64): u64;\n\n/**\n * @hidden\n */\n@external(\"env\", \"received_amount\")\ndeclare function received_amount(): u64;\n\n/**\n * @hidden\n */\n@external(\"env\", \"block_index\")\ndeclare function block_index(): u64;\n\n// adapted from https://gist.github.com/Juszczak/63e6d9e01decc850de03\n/**\n * base64 encoding/decoding\n */\nexport namespace base64 {\n  const PADCHAR: string = '=';\n  const ALPHA: string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n  function getByte64(s: string, i: u32): u32 {\n    return this.ALPHA.indexOf(s.charAt(i));\n  }\n\n  /**\n   * Decode base64-encoded string and return a Uint8Array.\n   * @param s Base64 encoded string.\n   */\n  export function decode (s: string): Uint8Array {\n    let i: u32, b10: u32;\n    let pads = 0,\n        imax = s.length as u32;\n\n    if (imax == 0) {\n      return new Uint8Array(0);\n    }\n\n    if (s.charAt(imax - 1) == this.PADCHAR) {\n      pads = 1;\n      if (s.charAt(imax - 2) == this.PADCHAR) {\n        pads = 2;\n      }\n      imax -= 4;\n    }\n\n    let main_chunk = imax % 4 == 0 ? imax / 4 * 3 : (imax / 4 + 1) * 3;\n    let pad_size = pads > 0 ? 3 - pads : 0;\n    let size = main_chunk + pad_size;\n\n    let x = new Uint8Array(size),\n        index = 0;\n\n    for (i = 0; i < imax; i += 4) {\n      b10 = (this.getByte64(s, i) << 18) | (this.getByte64(s, i + 1) << 12) | (this.getByte64(s, i + 2) << 6) | this.getByte64(s, i + 3);\n      x[index++] = b10 >> 16;\n      x[index++] = (b10 >> 8) & 255;\n      x[index++] = b10 & 255;\n    }\n    switch (pads) {\n      case 1:\n        b10 = (this.getByte64(s, i) << 18) | (this.getByte64(s, i + 1) << 12) | (this.getByte64(s, i + 2) << 6);\n        x[index++] = b10 >> 16;\n        x[index++] = (b10 >> 8) & 255;\n        break;\n      case 2:\n        b10 = (this.getByte64(s, i) << 18) | (this.getByte64(s, i + 1) << 12);\n        x[index++] = b10 >> 16;\n        break;\n    }\n\n    return x;\n  }\n\n  /**\n   * Encode Uint8Array in base64.\n   * @param bytes Byte array of type Uint8Array.\n   */\n  export function encode(bytes: Uint8Array): string {\n    let i: i32, b10: u32;\n    let x = new Array<string>(),\n        imax = bytes.length - bytes.length % 3;\n\n    if (bytes.length == 0) {\n      return \"\";\n    }\n\n    for (i = 0; i < imax; i += 3) {\n      b10 = (bytes[i] as u32 << 16) | (bytes[i+1] as u32 << 8) | bytes[i+2] as u32;\n      x.push(this.ALPHA.charAt(b10 >> 18));\n      x.push(this.ALPHA.charAt((b10 >> 12) & 63));\n      x.push(this.ALPHA.charAt((b10 >> 6) & 63));\n      x.push(this.ALPHA.charAt(b10 & 63));\n    }\n\n    switch (bytes.length - imax) {\n      case 1:\n        b10 = bytes[i] as u32 << 16;\n        x.push(this.ALPHA.charAt(b10 >> 18));\n        x.push(this.ALPHA.charAt((b10 >> 12) & 63));\n        x.push(this.PADCHAR);\n        x.push(this.PADCHAR);\n        break;\n      case 2:\n        b10 = (bytes[i] as u32 << 16) | (bytes[i+1] as u32 << 8);\n        x.push(this.ALPHA.charAt(b10 >> 18));\n        x.push(this.ALPHA.charAt((b10 >> 12) & 63));\n        x.push(this.ALPHA.charAt((b10 >> 6) & 63));\n        x.push(this.PADCHAR);\n        break;\n    }\n\n    return x.join('');\n  }\n}\n","import { memcmp, memmove, memset } from \"./internal/memory\";\n\n@builtin export declare const HEAP_BASE: usize; // tslint:disable-line\n\n/* tslint:disable */\n\nexport namespace memory {\n\n  @builtin export declare function size(): i32;\n\n  @builtin export declare function grow(pages: i32): i32;\n\n  @builtin @inline\n  export function fill(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n    memset(dest, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  @builtin @inline\n  export function copy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n    memmove(dest, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  @inline export function compare(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\n    return memcmp(vl, vr, n);\n  }\n\n  // Passive segments\n\n  // export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n  //   __memory_init(segmentIndex, srcOffset, dstOffset);\n  // }\n\n  // export function drop(segmentIndex: u32): void {\n  //   __memory_drop(segmentIndex);\n  // }\n\n  // Allocator\n\n  @inline export function allocate(size: usize): usize {\n    if (isDefined(__memory_allocate)) return __memory_allocate(size);\n    WARNING(\"Calling 'memory.allocate' requires a memory manager to be present.\");\n    return <usize>unreachable();\n  }\n\n  @inline export function free(ptr: usize): void {\n    if (isDefined(__memory_free)) { __memory_free(ptr); return; }\n    WARNING(\"Calling 'memory.free' requires a memory manager to be present.\");\n    unreachable();\n  }\n\n  @inline export function reset(): void {\n    if (isDefined(__memory_reset)) { __memory_reset(); return; }\n    unreachable();\n  }\n}\n","/** Number of alignment bits. */\n@inline export const AL_BITS: u32 = 3;\n/** Number of possible alignment values. */\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n/** Mask to obtain just the alignment bits. */\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n/** Maximum 32-bit allocation size. */\n@inline export const MAX_SIZE_32: usize = 1 << 30; // 1GB\n","import {\n  AL_MASK,\n  MAX_SIZE_32\n } from \"./allocator\";\n\n/** Size of an ArrayBuffer header. */\n@inline export const HEADER_SIZE: usize = (offsetof<ArrayBuffer>() + AL_MASK) & ~AL_MASK;\n/** Maximum byte length of an ArrayBuffer. */\n@inline export const MAX_BLENGTH: i32 = <i32>MAX_SIZE_32 - HEADER_SIZE;\n\nfunction computeSize(byteLength: i32): usize {\n  // round up to power of 2, with HEADER_SIZE=8:\n  // 0            -> 2^3  = 8\n  // 1..8         -> 2^4  = 16\n  // 9..24        -> 2^5  = 32\n  // ...\n  // MAX_LENGTH   -> 2^30 = 0x40000000 (MAX_SIZE_32)\n  return <usize>1 << <usize>(<u32>32 - clz<u32>(byteLength + HEADER_SIZE - 1));\n}\n\n// Low-level utility\n\nfunction __gc(ref: usize): void {}\n\nexport function allocateUnsafe(byteLength: i32): ArrayBuffer {\n  assert(<u32>byteLength <= <u32>MAX_BLENGTH);\n  var buffer: usize;\n  if (isManaged<ArrayBuffer>()) {\n    buffer = __gc_allocate(computeSize(byteLength), __gc); // tslint:disable-line\n  } else {\n    buffer = memory.allocate(computeSize(byteLength));\n  }\n  store<i32>(buffer, byteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n  return changetype<ArrayBuffer>(buffer);\n}\n\nexport function reallocateUnsafe(buffer: ArrayBuffer, newByteLength: i32): ArrayBuffer {\n  var oldByteLength = buffer.byteLength;\n  if (newByteLength > oldByteLength) {\n    assert(newByteLength <= MAX_BLENGTH);\n    if (newByteLength <= <i32>(computeSize(oldByteLength) - HEADER_SIZE)) { // fast path: zero out additional space\n      store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n    } else { // slow path: copy to new buffer\n      let newBuffer = allocateUnsafe(newByteLength);\n      memory.copy(\n        changetype<usize>(newBuffer) + HEADER_SIZE,\n        changetype<usize>(buffer) + HEADER_SIZE,\n        <usize>oldByteLength\n      );\n      if (!isManaged<ArrayBuffer>()) {\n        memory.free(changetype<usize>(buffer));\n      }\n      buffer = newBuffer;\n    }\n    memory.fill(\n      changetype<usize>(buffer) + HEADER_SIZE + <usize>oldByteLength,\n      0,\n      <usize>(newByteLength - oldByteLength)\n    );\n  } else if (newByteLength < oldByteLength) { // fast path: override size\n    // TBD: worth to copy and release if size is significantly less than before?\n    assert(newByteLength >= 0);\n    store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n  }\n  return buffer;\n}\n\n// The helpers below use two different types in order to emit loads and stores that load respectively\n// store one type to/from memory while returning/taking the desired output/input type. This allows to\n// emit instructions like\n//\n// * `i32.load8` ^= `<i32>load<i8>(...)` that reads an i8 but returns an i32, or\n// * `i64.load32_s` ^= `<i64>load<i32>(...)`) that reads a 32-bit as a 64-bit integer\n//\n// without having to emit an additional instruction for conversion purposes. The second parameter\n// can be omitted for references and other loads and stores that simply return the exact type.\n\n@inline export function LOAD<T,TOut = T>(buffer: ArrayBuffer, index: i32, byteOffset: i32 = 0): TOut {\n  return <TOut>load<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, HEADER_SIZE);\n}\n\n@inline export function STORE<T,TIn = T>(buffer: ArrayBuffer, index: i32, value: TIn, byteOffset: i32 = 0): void {\n  store<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, value, HEADER_SIZE);\n}\n","import { MAX_SIZE_32 } from \"./allocator\";\nimport { String } from \"../string\";\n\n/** Size of a String header. */\n@inline export const HEADER_SIZE = (offsetof<String>() + 1) & ~1; // 2 byte aligned\n/** Maximum length of a String. */\n@inline export const MAX_LENGTH = (<i32>MAX_SIZE_32 - HEADER_SIZE) >>> 1;\n\n// Low-level utility\n\nfunction __gc(ref: usize): void {}\n\nexport function allocateUnsafe(length: i32): String {\n  assert(length > 0 && length <= MAX_LENGTH);\n  var buffer: usize;\n  if (isManaged<String>()) {\n    buffer = __gc_allocate(HEADER_SIZE + (<usize>length << 1), __gc);  // tslint:disable-line\n  } else {\n    buffer = memory.allocate(HEADER_SIZE + (<usize>length << 1));\n  }\n  store<i32>(buffer, length);\n  return changetype<String>(buffer);\n}\n\n@inline\nexport function freeUnsafe(buffer: String): void {\n  if (!isManaged<String>()) {\n    assert(buffer);\n    memory.free(changetype<usize>(buffer));\n  }\n}\n\nexport function copyUnsafe(dest: String, destOffset: usize, src: String, srcOffset: usize, len: usize): void {\n  memory.copy(\n    changetype<usize>(dest) + (destOffset << 1) + HEADER_SIZE,\n    changetype<usize>(src)  + (srcOffset  << 1) + HEADER_SIZE,\n    len << 1\n  );\n}\n\nexport function compareUnsafe(str1: String, offset1: usize, str2: String, offset2: usize, len: usize): i32 {\n  var cmp: i32 = 0;\n  var ptr1 = changetype<usize>(str1) + (offset1 << 1);\n  var ptr2 = changetype<usize>(str2) + (offset2 << 1);\n  while (len && !(cmp = <i32>load<u16>(ptr1, HEADER_SIZE) - <i32>load<u16>(ptr2, HEADER_SIZE))) {\n    --len, ptr1 += 2, ptr2 += 2;\n  }\n  return cmp;\n}\n\nexport function repeatUnsafe(dest: String, destOffset: usize, src: String, count: i32): void {\n  var length = src.length;\n  if (ASC_SHRINK_LEVEL > 1) {\n    let strLen = length << 1;\n    let to   = changetype<usize>(dest) + HEADER_SIZE + (destOffset << 1);\n    let from = changetype<usize>(src)  + HEADER_SIZE;\n    for (let i = 0, len = strLen * count; i < len; i += strLen) {\n      memory.copy(to + i, from, strLen);\n    }\n  } else {\n    switch (length) {\n      case 0: break;\n      case 1: {\n        let cc =  load<u16>(changetype<usize>(src), HEADER_SIZE);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u16>(out + (i << 1), cc, HEADER_SIZE);\n        }\n        break;\n      }\n      case 2: {\n        let cc  = load<u32>(changetype<usize>(src), HEADER_SIZE);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u32>(out + (i << 2), cc, HEADER_SIZE);\n        }\n        break;\n      }\n      case 3: {\n        let cc1 = load<u32>(changetype<usize>(src), HEADER_SIZE + 0);\n        let cc2 = load<u16>(changetype<usize>(src), HEADER_SIZE + 4);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u32>(out + (i << 2), cc1, HEADER_SIZE + 0);\n          store<u16>(out + (i << 1), cc2, HEADER_SIZE + 4);\n        }\n        break;\n      }\n      case 4: {\n        let cc = load<u64>(changetype<usize>(src), HEADER_SIZE);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u64>(out + (i << 3), cc, HEADER_SIZE);\n        }\n        break;\n      }\n      default: {\n        let strLen = length << 1;\n        let to   = changetype<usize>(dest) + HEADER_SIZE + (destOffset << 1);\n        let from = changetype<usize>(src)  + HEADER_SIZE;\n        for (let i = 0, len = strLen * count; i < len; i += strLen) {\n          memory.copy(to + i, from, strLen);\n        }\n        break;\n      }\n    }\n  }\n}\n\n// Helpers\n\n@inline export const enum CharCode {\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5a,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  x = 0x78,\n  z = 0x7A\n}\n\nexport function isWhiteSpaceOrLineTerminator(c: u16): bool {\n  switch (c) {\n    case 9:    // <TAB>\n    case 10:   // <LF>\n    case 13:   // <CR>\n    case 11:   // <VT>\n    case 12:   // <FF>\n    case 32:   // <SP>\n    case 160:  // <NBSP>\n    case 8232: // <LS>\n    case 8233: // <PS>\n    case 65279: return true; // <ZWNBSP>\n    default: return false;\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function parse<T>(str: String, radix: i32 = 0): T {\n  var len: i32 = str.length;\n  if (!len) return <T>NaN;\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\n\n  // determine sign\n  var sign: T;\n  if (code == CharCode.MINUS) {\n    if (!--len) return <T>NaN;\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return <T>NaN;\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = 1;\n  } else {\n    sign = 1;\n  }\n\n  // determine radix\n  if (!radix) {\n    if (code == CharCode._0 && len > 2) {\n      switch (<i32>load<u16>(ptr + 2, HEADER_SIZE)) {\n        case CharCode.B:\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.O:\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.X:\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n        default: radix = 10;\n      }\n    } else radix = 10;\n  } else if (radix < 2 || radix > 36) {\n    return <T>NaN;\n  }\n\n  // calculate value\n  var num: T = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\n    if (code >= CharCode._0 && code <= CharCode._9) {\n      code -= CharCode._0;\n    } else if (code >= CharCode.A && code <= CharCode.Z) {\n      code -= CharCode.A - 10;\n    } else if (code >= CharCode.a && code <= CharCode.z) {\n      code -= CharCode.a - 10;\n    } else break;\n    if (code >= radix) break;\n    num = (num * radix) + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n","import {\n  HEADER_SIZE as AB_HEADER_SIZE,\n  MAX_BLENGTH as AB_MAX_BLENGTH,\n  allocateUnsafe,\n  LOAD,\n  STORE\n} from \"./arraybuffer\";\n\nimport {\n  SORT as SORT_IMPL\n} from \"./sort\";\n\n/** Typed array base class. Not a global object. */\nexport abstract class TypedArray<T> {\n  [key: number]: T; // compatibility only\n\n  readonly buffer: ArrayBuffer;\n  readonly byteOffset: i32;\n  readonly byteLength: i32;\n\n  constructor(length: i32) {\n    const MAX_LENGTH = <u32>AB_MAX_BLENGTH / sizeof<T>();\n    if (<u32>length > MAX_LENGTH) throw new RangeError(\"Invalid typed array length\");\n    var byteLength = length << alignof<T>();\n    var buffer = allocateUnsafe(byteLength);\n    memory.fill(changetype<usize>(buffer) + AB_HEADER_SIZE, 0, <usize>byteLength);\n    this.buffer = buffer;\n    this.byteOffset = 0;\n    this.byteLength = byteLength;\n  }\n\n  @inline\n  get length(): i32 {\n    return this.byteLength >>> alignof<T>();\n  }\n\n  @operator(\"[]\")\n  protected __get(index: i32): T {\n    if (<u32>index >= <u32>(this.byteLength >>> alignof<T>())) throw new Error(\"Index out of bounds\");\n    return LOAD<T>(this.buffer, index, this.byteOffset);\n  }\n\n  @inline @operator(\"{}\")\n  protected __unchecked_get(index: i32): T {\n    return LOAD<T>(this.buffer, index, this.byteOffset);\n  }\n\n  @operator(\"[]=\")\n  protected __set(index: i32, value: native<T>): void {\n    if (<u32>index >= <u32>(this.byteLength >>> alignof<T>())) throw new Error(\"Index out of bounds\");\n    STORE<T,native<T>>(this.buffer, index, value, this.byteOffset);\n  }\n\n  @inline @operator(\"{}=\")\n  protected __unchecked_set(index: i32, value: native<T>): void {\n    STORE<T,native<T>>(this.buffer, index, value, this.byteOffset);\n  }\n\n  // copyWithin(target: i32, start: i32, end: i32 = this.length): this\n}\n\n@inline\nexport function FILL<TArray extends TypedArray<T>, T extends number>(\n  array: TArray,\n  value: native<T>,\n  start: i32,\n  end: i32\n): TArray {\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  var len = array.length;\n  start = start < 0 ? max(len + start, 0) : min(start, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  if (sizeof<T>() == 1) {\n    if (start < end) {\n      memory.fill(\n        changetype<usize>(buffer) + start + byteOffset + AB_HEADER_SIZE,\n        <u8>value,\n        <usize>(end - start)\n      );\n    }\n  } else {\n    for (; start < end; ++start) {\n      STORE<T,native<T>>(buffer, start, value, byteOffset);\n    }\n  }\n  return array;\n}\n\n@inline\nexport function SORT<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  comparator: (a: T, b: T) => i32\n): TArray {\n  var byteOffset = array.byteOffset;\n  var length = array.length;\n  if (length <= 1) return array;\n  var buffer = array.buffer;\n  if (length == 2) {\n    let a = LOAD<T>(buffer, 1, byteOffset);\n    let b = LOAD<T>(buffer, 0, byteOffset);\n    if (comparator(a, b) < 0) {\n      STORE<T>(buffer, 1, b, byteOffset);\n      STORE<T>(buffer, 0, a, byteOffset);\n    }\n    return array;\n  }\n  SORT_IMPL<T>(buffer, byteOffset, length, comparator);\n  return array;\n}\n\n@inline\nexport function SUBARRAY<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  var length = <i32>array.length;\n  if (begin < 0) begin = max(length + begin, 0);\n  else begin = min(begin, length);\n  if (end < 0) end = max(length + end, begin);\n  else end = max(min(end, length), begin);\n  var slice = memory.allocate(offsetof<TArray>());\n  store<usize>(slice, array.buffer, offsetof<TArray>(\"buffer\"));\n  store<i32>(slice, <i32>array.byteOffset + (begin << alignof<T>()), offsetof<TArray>(\"byteOffset\"));\n  store<i32>(slice, (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\n  return changetype<TArray>(slice);\n}\n\n@inline\nexport function REDUCE<TArray extends TypedArray<T>, T, TRet>(\n  array: TArray,\n  callbackfn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    initialValue = callbackfn(\n      initialValue,\n      LOAD<T>(buffer, i, byteOffset),\n      i,\n      array,\n    );\n  }\n  return initialValue;\n}\n\n@inline\nexport function REDUCE_RIGHT<TArray extends TypedArray<T>, T, TRet>(\n  array: TArray,\n  callbackfn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = callbackfn(\n      initialValue,\n      LOAD<T>(buffer, i, byteOffset),\n      i,\n      array,\n    );\n  }\n  return initialValue;\n}\n\n@inline\nexport function MAP<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  var result = instantiate<TArray>(length);\n  var resultBuffer = result.buffer;\n  for (let i = 0; i < length; i++) {\n    STORE<T, native<T>>(resultBuffer, i, <native<T>>callbackfn(LOAD<T>(buffer, i, byteOffset), i, array));\n  }\n\n  return result;\n}\n\n@inline\nexport function FIND_INDEX<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n@inline\nexport function SOME<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n@inline\nexport function EVERY<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n","// this function will go away once `memory.copy` becomes an intrinsic\nexport function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// this function will go away once `memory.copy` becomes an intrinsic\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (src + n <= dest || dest + n <= src) {\n    memcpy(dest, src, n);\n    return;\n  }\n  if (dest < src) {\n    if ((src & 7) == (dest & 7)) {\n      while (dest & 7) {\n        if (!n) return;\n        --n;\n        store<u8>(dest++, load<u8>(src++));\n      }\n      while (n >= 8) {\n        store<u64>(dest, load<u64>(src));\n        n    -= 8;\n        dest += 8;\n        src  += 8;\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if ((src & 7) == (dest & 7)) {\n      while ((dest + n) & 7) {\n        if (!n) return;\n        store<u8>(dest + --n, load<u8>(src + n));\n      }\n      while (n >= 8) {\n        n -= 8;\n        store<u64>(dest + n, load<u64>(src + n));\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// this function will go away once `memory.fill` becomes an intrinsic\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n\n  // fill head and tail with minimal branching\n  if (!n) return;\n  store<u8>(dest, c);\n  store<u8>(dest + n - 1, c);\n  if (n <= 2) return;\n\n  store<u8>(dest + 1, c);\n  store<u8>(dest + 2, c);\n  store<u8>(dest + n - 2, c);\n  store<u8>(dest + n - 3, c);\n  if (n <= 6) return;\n  store<u8>(dest + 3, c);\n  store<u8>(dest + n - 4, c);\n  if (n <= 8) return;\n\n  // advance pointer to align it at 4-byte boundary\n  var k: usize = -dest & 3;\n  dest += k;\n  n -= k;\n  n &= -4;\n\n  var c32: u32 = <u32>-1 / 255 * c;\n\n  // fill head/tail up to 28 bytes each in preparation\n  store<u32>(dest, c32);\n  store<u32>(dest + n - 4, c32);\n  if (n <= 8) return;\n  store<u32>(dest + 4, c32);\n  store<u32>(dest + 8, c32);\n  store<u32>(dest + n - 12, c32);\n  store<u32>(dest + n - 8, c32);\n  if (n <= 24) return;\n  store<u32>(dest + 12, c32);\n  store<u32>(dest + 16, c32);\n  store<u32>(dest + 20, c32);\n  store<u32>(dest + 24, c32);\n  store<u32>(dest + n - 28, c32);\n  store<u32>(dest + n - 24, c32);\n  store<u32>(dest + n - 20, c32);\n  store<u32>(dest + n - 16, c32);\n\n  // align to a multiple of 8\n  k = 24 + (dest & 4);\n  dest += k;\n  n -= k;\n\n  // copy 32 bytes each\n  var c64: u64 = <u64>c32 | (<u64>c32 << 32);\n  while (n >= 32) {\n    store<u64>(dest, c64);\n    store<u64>(dest + 8, c64);\n    store<u64>(dest + 16, c64);\n    store<u64>(dest + 24, c64);\n    n -= 32;\n    dest += 32;\n  }\n}\n\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\n  if (vl == vr) return 0;\n  while (n != 0 && load<u8>(vl) == load<u8>(vr)) {\n    n--; vl++; vr++;\n  }\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\n}\n","declare function logStr(str: string): void;\ndeclare function logF64(val: f64): void;\n\n/**\n * Extend from this class to handle events from parser.\n * Default implementation traverses whole object tree and does nothing.\n */\nexport abstract class JSONHandler {\n    setString(name: string, value: string): void {\n    }\n\n    setBoolean(name: string, value: bool): void {\n    }\n\n    setNull(name: string): void {\n    }\n\n    setInteger(name: string, value: i64): void {\n    }\n\n    pushArray(name: string): bool {\n        return true;\n    }\n\n    popArray(): void {\n    }\n\n    pushObject(name: string): bool {\n        return true;\n    }\n\n    popObject(): void {\n    }\n}\n\n/**\n * Extend from this class to handle events from parser.\n * This implementation crashes on every unimplemented set/push method\n * to allow easier validation of input.\n */\nexport class ThrowingJSONHandler extends JSONHandler {\n    setString(name: string, value: string): void {\n       assert(false, 'Unexpected string field ' + name + ' : \"' + value + '\"');\n    }\n\n    setBoolean(name: string, value: bool): void {\n       assert(false, 'Unexpected bool field ' + name + ' : ' + (value ? 'true' : 'false'));\n    }\n\n    setNull(name: string): void {\n       assert(false, 'Unexpected null field ' + name);\n    }\n\n    setInteger(name: string, value: i64): void {\n       assert(false, 'Unexpected integer field ' + name + ' : ' + value.toString());\n    }\n\n    pushArray(name: string): bool {\n        assert(false, 'Unexpected array field ' + name);\n        return true;\n    }\n\n    pushObject(name: string): bool {\n        assert(false, 'Unexpected object field ' + name);\n        return true;\n    }\n}\n\nconst TRUE_STR = \"true\";\nconst FALSE_STR = \"false\";\nconst NULL_STR = \"null\";\nlet CHAR_0 = \"0\".charCodeAt(0);\nlet CHAR_9 = \"9\".charCodeAt(0);\nlet CHAR_A = \"A\".charCodeAt(0);\nlet CHAR_A_LOWER = \"a\".charCodeAt(0);\n\nexport class DecoderState {\n    readIndex: i32 = 0;\n    buffer: Uint8Array = null;\n    lastKey: string = null;\n}\n\nexport class JSONDecoder<JSONHandlerT extends JSONHandler> {\n\n    handler: JSONHandlerT;\n    state: DecoderState;\n\n    constructor(handler: JSONHandlerT) {\n        this.handler = handler;\n    }\n\n    deserialize(buffer: Uint8Array, decoderState: DecoderState = null): void {\n        if (decoderState) {\n            this.state = decoderState;\n        } else {\n            this.state = new DecoderState();\n            this.state.readIndex = 0;\n            this.state.buffer = buffer;\n            this.state.lastKey = null;\n        }\n\n        assert(this.parseValue(), \"Cannot parse JSON\");\n        // TODO: Error if input left\n    }\n\n    private peekChar(): i32 {\n        if (this.state.readIndex >= this.state.buffer.length) {\n          return -1;\n        }\n        return this.state.buffer[this.state.readIndex];\n    }\n\n    private readChar(): i32 {\n        assert(this.state.readIndex < this.state.buffer.length, \"Unexpected input end\");\n        return this.state.buffer[this.state.readIndex++];\n    }\n\n    private parseValue(): bool {\n        this.skipWhitespace();\n        let result = this.parseObject()\n            || this.parseArray()\n            || this.parseString()\n            || this.parseBoolean()\n            || this.parseNumber()\n            || this.parseNull()\n        this.skipWhitespace();\n        return result;\n    }\n\n    private parseObject(): bool {\n        if (this.peekChar() != \"{\".charCodeAt(0)) {\n            return false;\n        }\n        let key = this.state.lastKey;\n        this.state.lastKey = null;\n        if (this.handler.pushObject(key)) {\n            this.readChar();\n            this.skipWhitespace();\n\n            let firstItem = true;\n            while (this.peekChar() != \"}\".charCodeAt(0)) {\n                if (!firstItem) {\n                    assert(this.readChar() == \",\".charCodeAt(0), \"Expected ','\");\n                } else {\n                    firstItem = false;\n                }\n                this.parseKey();\n                this.parseValue();\n            }\n            assert(this.readChar() == \"}\".charCodeAt(0), \"Unexpected end of object\");\n        }\n        this.handler.popObject();\n        return true;\n    }\n\n    private parseKey(): void {\n        this.skipWhitespace();\n        this.state.lastKey = this.readString();\n        this.skipWhitespace();\n        assert(this.readChar() == \":\".charCodeAt(0), \"Expected ':'\");\n    }\n\n    private parseArray(): bool {\n        if (this.peekChar() != \"[\".charCodeAt(0)) {\n            return false;\n        }\n        let key = this.state.lastKey;\n        this.state.lastKey = null;\n        if (this.handler.pushArray(key)) {\n            this.readChar();\n            this.skipWhitespace();\n\n            let firstItem = true;\n            while (this.peekChar() != \"]\".charCodeAt(0)) {\n                if (!firstItem) {\n                    assert(this.readChar() == \",\".charCodeAt(0), \"Expected ','\");\n                } else {\n                    firstItem = false;\n                }\n                this.parseValue();\n            }\n            assert(this.readChar() == \"]\".charCodeAt(0), \"Unexpected end of array\");\n        }\n        this.handler.popArray();\n        return true;;\n    }\n\n    private parseString(): bool {\n        if (this.peekChar() != '\"'.charCodeAt(0)) {\n            return false;\n        }\n        this.handler.setString(this.state.lastKey, this.readString());\n        return true;\n    }\n\n    private readString(): string {\n        assert(this.readChar() == '\"'.charCodeAt(0), \"Expected double-quoted string\");\n        let savedIndex = this.state.readIndex;\n        let stringParts: Array<string> = null;\n        for (;;) {\n            let byte = this.readChar();\n            assert(byte >= 0x20, \"Unexpected control character\");\n            if (byte == '\"'.charCodeAt(0)) {\n                let s = String.fromUTF8(this.state.buffer.buffer.data + savedIndex, this.state.readIndex - savedIndex - 1);\n                if (stringParts == null) {\n                    return s;\n                }\n                stringParts.push(s);\n                return stringParts.join(\"\");\n            } else if (byte == \"\\\\\".charCodeAt(0)) {\n                if (stringParts == null) {\n                    stringParts = new Array<string>();\n                }\n                if (this.state.readIndex > savedIndex + 1) {\n                    stringParts.push(\n                        String.fromUTF8(this.state.buffer.buffer.data + savedIndex, this.state.readIndex - savedIndex - 1));\n                }\n                stringParts.push(this.readEscapedChar());\n                savedIndex = this.state.readIndex;\n            }\n        }\n        // Should never happen\n        return \"\";\n    }\n\n    private readEscapedChar(): string {\n        let byte = this.readChar();\n        // TODO: Use lookup table for anything except \\u\n        if (byte == '\"'.charCodeAt(0)) {\n            return '\"';\n        }\n        if (byte == \"\\\\\".charCodeAt(0)) {\n            return \"\\\\\";\n        }\n        if (byte == \"/\".charCodeAt(0)) {\n            return \"/\";\n        }\n        if (byte == \"b\".charCodeAt(0)) {\n            return \"\\b\";\n        }\n        if (byte == \"n\".charCodeAt(0)) {\n            return \"\\n\";\n        }\n        if (byte == \"r\".charCodeAt(0)) {\n            return \"\\r\";\n        }\n        if (byte == \"t\".charCodeAt(0)) {\n            return \"\\t\";\n        }\n        if (byte == \"u\".charCodeAt(0)) {\n            let d1 = this.readHexDigit();\n            let d2 = this.readHexDigit();\n            let d3 = this.readHexDigit();\n            let d4 = this.readHexDigit();\n            let charCode = d1 * 0x1000 + d2 * 0x100 + d3 * 0x10 + d4;\n            return String.fromCodePoint(charCode);\n        }\n        assert(false, \"Unexpected escaped character: \" + String.fromCharCode(byte));\n        return \"\";\n    }\n\n    private readHexDigit(): i32 {\n        let byte = this.readChar();\n        let digit = byte - CHAR_0;\n        if (digit > 9) {\n            digit = byte - CHAR_A + 10;\n            if (digit < 10 || digit > 15) {\n                digit = byte - CHAR_A_LOWER + 10;\n            }\n        }\n        let arr: Array<i32> = [byte, digit];\n        assert(digit >= 0 && digit < 16, \"Unexpected \\\\u digit\");\n        return digit;\n    }\n\n    private parseNumber(): bool {\n        // TODO: Parse floats\n        let number: i64 = 0;\n        let sign: i64 = 1;\n        if (this.peekChar() == \"-\".charCodeAt(0)) {\n            sign = -1;\n            this.readChar();\n        }\n        let digits = 0;\n        while (CHAR_0 <= this.peekChar() && this.peekChar() <= CHAR_9 ) {\n            let byte = this.readChar();\n            number *= 10;\n            number += byte - CHAR_0;\n            digits++;\n        }\n        if (digits > 0) {\n            this.handler.setInteger(this.state.lastKey, number * sign);\n            return true;\n        }\n        return false;\n    }\n\n    private parseBoolean(): bool {\n        if (this.peekChar() == FALSE_STR.charCodeAt(0)) {\n            this.readAndAssert(FALSE_STR);\n            this.handler.setBoolean(this.state.lastKey, false);\n            return true;\n        }\n        if (this.peekChar() == TRUE_STR.charCodeAt(0)) {\n            this.readAndAssert(TRUE_STR);\n            this.handler.setBoolean(this.state.lastKey, true);\n            return true;\n        }\n\n        return false;\n    }\n\n    private parseNull(): bool {\n        if (this.peekChar() == NULL_STR.charCodeAt(0)) {\n            this.readAndAssert(NULL_STR);\n            this.handler.setNull(this.state.lastKey);\n            return true;\n        }\n        return false;\n    }\n\n    private readAndAssert(str: string): void {\n        for (let i = 0; i < str.length; i++) {\n            assert(str.charCodeAt(i) == this.readChar(), \"Expected '\" + str + \"'\");\n        }\n    }\n\n    private skipWhitespace(): void {\n        while (this.isWhitespace(this.peekChar())) {\n            this.readChar();\n        }\n    }\n\n    private isWhitespace(charCode: i32): bool {\n        return charCode == 0x9 || charCode == 0xa || charCode == 0xd || charCode == 0x20;\n    }\n}\n","import {\n  HEADER_SIZE,\n  MAX_LENGTH,\n  allocateUnsafe,\n  compareUnsafe,\n  repeatUnsafe,\n  copyUnsafe,\n  isWhiteSpaceOrLineTerminator,\n  CharCode,\n  parse\n} from \"./internal/string\";\n\nimport {\n  STORE\n} from \"./internal/arraybuffer\";\n\n@sealed\nexport class String {\n\n  readonly length: i32; // capped to [0, MAX_LENGTH]\n\n  // TODO Add and handle second argument\n  static fromCharCode(code: i32): String {\n    var out = allocateUnsafe(1);\n    store<u16>(\n      changetype<usize>(out),\n      <u16>code,\n      HEADER_SIZE\n    );\n    return out;\n  }\n\n  static fromCodePoint(code: i32): String {\n    assert(<u32>code <= 0x10FFFF);\n    var sur = code > 0xFFFF;\n    var out = allocateUnsafe(<i32>sur + 1);\n    if (!sur) {\n      store<u16>(\n        changetype<usize>(out),\n        <u16>code,\n        HEADER_SIZE\n      );\n    } else {\n      code -= 0x10000;\n      let hi: u32 = (code >>> 10)  + 0xD800;\n      let lo: u32 = (code & 0x3FF) + 0xDC00;\n      store<u32>(\n        changetype<usize>(out),\n        (hi << 16) | lo,\n        HEADER_SIZE\n      );\n    }\n    return out;\n  }\n\n  @operator(\"[]\")\n  charAt(pos: i32): String {\n    assert(this !== null);\n\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n\n    var out = allocateUnsafe(1);\n    store<u16>(\n      changetype<usize>(out),\n      load<u16>(\n        changetype<usize>(this) + (<usize>pos << 1),\n        HEADER_SIZE\n      ),\n      HEADER_SIZE\n    );\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    assert(this !== null);\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n\n    return load<u16>(\n      changetype<usize>(this) + (<usize>pos << 1),\n      HEADER_SIZE\n    );\n  }\n\n  codePointAt(pos: i32): i32 {\n    assert(this !== null);\n    if (<u32>pos >= <u32>this.length) return -1; // (undefined)\n\n    var first = <i32>load<u16>(\n      changetype<usize>(this) + (<usize>pos << 1),\n      HEADER_SIZE\n    );\n    if (first < 0xD800 || first > 0xDBFF || pos + 1 == this.length) {\n      return first;\n    }\n    var second = <i32>load<u16>(\n      changetype<usize>(this) + ((<usize>pos + 1) << 1),\n      HEADER_SIZE\n    );\n    if (second < 0xDC00 || second > 0xDFFF) return first;\n    return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\")\n  private static __concat(left: String, right: String): String {\n    if (!changetype<usize>(left)) left = changetype<String>(\"null\");\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    assert(this !== null);\n    if (other === null) other = changetype<String>(\"null\");\n\n    var thisLen: isize = this.length;\n    var otherLen: isize = other.length;\n    var outLen: usize = thisLen + otherLen;\n    if (outLen == 0) return changetype<String>(\"\");\n    var out = allocateUnsafe(outLen);\n    copyUnsafe(out, 0, this, 0, thisLen);\n    copyUnsafe(out, thisLen, other, 0, otherLen);\n    return out;\n  }\n\n  endsWith(searchString: String, endPosition: i32 = MAX_LENGTH): bool {\n    assert(this !== null);\n    if (searchString === null) return false;\n    var end = min(max(endPosition, 0), this.length);\n    var searchLength: isize = searchString.length;\n    var start: isize = end - searchLength;\n    if (start < 0) return false;\n    return !compareUnsafe(this, start, searchString, 0, searchLength);\n  }\n\n  @operator(\"==\")\n  private static __eq(left: String, right: String): bool {\n    if (left === right) return true;\n    if (left === null || right === null) return false;\n\n    var leftLength = left.length;\n    if (leftLength != right.length) return false;\n\n    return !compareUnsafe(left, 0, right, 0, leftLength);\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String, right: String): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\")\n  private static __gt(left: String, right: String): bool {\n    if (left === right || left === null || right === null) return false;\n\n    var leftLength  = left.length;\n    var rightLength = right.length;\n\n    if (!leftLength)  return false;\n    if (!rightLength) return true;\n\n    var length = <usize>min<i32>(leftLength, rightLength);\n    return compareUnsafe(left, 0, right, 0, length) > 0;\n  }\n\n  @operator(\">=\")\n  private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\")\n  private static __lt(left: String, right: String): bool {\n    if (left === right || left === null || right === null) return false;\n\n    var leftLength  = left.length;\n    var rightLength = right.length;\n\n    if (!rightLength) return false;\n    if (!leftLength)  return true;\n\n    var length = <usize>min<i32>(leftLength, rightLength);\n    return compareUnsafe(left, 0, right, 0, length) < 0;\n  }\n\n  @operator(\"<=\")\n  private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  @inline\n  includes(searchString: String, position: i32 = 0): bool {\n    return this.indexOf(searchString, position) != -1;\n  }\n\n  indexOf(searchString: String, fromIndex: i32 = 0): i32 {\n    assert(this !== null);\n    if (searchString === null) searchString = changetype<String>(\"null\");\n\n    var searchLen: isize = searchString.length;\n    if (!searchLen) return 0;\n    var len: isize = this.length;\n    if (!len) return -1;\n    var start = min<isize>(max<isize>(fromIndex, 0), len);\n    len -= searchLen;\n    for (let k: isize = start; k <= len; ++k) {\n      if (!compareUnsafe(this, k, searchString, 0, searchLen)) return <i32>k;\n    }\n    return -1;\n  }\n\n  lastIndexOf(searchString: String, fromIndex: i32 = i32.MAX_VALUE): i32 {\n    assert(this !== null);\n    if (searchString === null) searchString = changetype<String>(\"null\");\n\n    var len: isize = this.length;\n    var searchLen: isize = searchString.length;\n    if (!searchLen) return len;\n    if (!len) return -1;\n    var start = min<isize>(max(fromIndex, 0), len - searchLen);\n    for (let k = start; k >= 0; --k) {\n      if (!compareUnsafe(this, k, searchString, 0, searchLen)) return <i32>k;\n    }\n    return -1;\n  }\n\n  startsWith(searchString: String, position: i32 = 0): bool {\n    assert(this !== null);\n    if (searchString === null) searchString = changetype<String>(\"null\");\n\n    var pos: isize = position;\n    var len: isize = this.length;\n    var start = min(max(pos, 0), len);\n    var searchLength: isize = searchString.length;\n    if (searchLength + start > len) return false;\n    return !compareUnsafe(this, start, searchString, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String {\n    assert(this !== null);\n    var intStart: isize = start;\n    var end: isize = length;\n    var size: isize = this.length;\n    if (intStart < 0) intStart = max(size + intStart, 0);\n    var resultLength = min(max(end, 0), size - intStart);\n    if (resultLength <= 0) return changetype<String>(\"\");\n    var out = allocateUnsafe(resultLength);\n    copyUnsafe(out, 0, this, intStart, resultLength);\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    assert(this !== null);\n    var len = this.length;\n    var finalStart = min(max(start, 0), len);\n    var finalEnd = min(max(end, 0), len);\n    var from = min<i32>(finalStart, finalEnd);\n    var to = max<i32>(finalStart, finalEnd);\n    len = to - from;\n    if (!len) return changetype<String>(\"\");\n    if (!from && to == this.length) return this;\n    var out = allocateUnsafe(len);\n    copyUnsafe(out, 0, this, from, len);\n    return out;\n  }\n\n  trim(): String {\n    assert(this !== null);\n    var length: usize = this.length;\n\n    while (\n      length &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (length << 1), HEADER_SIZE)\n      )\n    ) {\n      --length;\n    }\n    var start: usize = 0;\n    while (\n      start < length &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (start << 1), HEADER_SIZE)\n      )\n    ) {\n      ++start, --length;\n    }\n    if (!length) return changetype<String>(\"\");\n    if (!start && length == this.length) return this;\n    var out = allocateUnsafe(length);\n    copyUnsafe(out, 0, this, start, length);\n    return out;\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    assert(this !== null);\n    var start: isize = 0;\n    var len: isize = this.length;\n    while (\n      start < len &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (start << 1), HEADER_SIZE)\n      )\n    ) {\n      ++start;\n    }\n    if (!start) return this;\n    var outLen = len - start;\n    if (!outLen) return changetype<String>(\"\");\n    var out = allocateUnsafe(outLen);\n    copyUnsafe(out, 0, this, start, outLen);\n    return out;\n  }\n\n  trimEnd(): String {\n    assert(this !== null);\n    var len: isize = this.length;\n    while (\n      len > 0 &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (len << 1), HEADER_SIZE)\n      )\n    ) {\n      --len;\n    }\n    if (len <= 0) return changetype<String>(\"\");\n    if (<i32>len == this.length) return this;\n    var out = allocateUnsafe(len);\n    copyUnsafe(out, 0, this, 0, len);\n    return out;\n  }\n\n  padStart(targetLength: i32, padString: String = changetype<String>(\" \")): String {\n    assert(this !== null);\n    var length = this.length;\n    var padLen = padString.length;\n    if (targetLength < length || !padLen) return this;\n    var len = targetLength - length;\n    var out = allocateUnsafe(targetLength);\n    if (len > padLen) {\n      let count = (len - 1) / padLen;\n      let base  = count * padLen;\n      let rest  = len - base;\n      repeatUnsafe(out, 0, padString, count);\n      if (rest) copyUnsafe(out, base, padString, 0, rest);\n    } else {\n      copyUnsafe(out, 0, padString, 0, len);\n    }\n    if (length) copyUnsafe(out, len, this, 0, length);\n    return out;\n  }\n\n  padEnd(targetLength: i32, padString: String = changetype<String>(\" \")): String {\n    assert(this !== null);\n    var length = this.length;\n    var padLen = padString.length;\n    if (targetLength < length || !padLen) return this;\n    var len = targetLength - length;\n    var out = allocateUnsafe(targetLength);\n    if (length) copyUnsafe(out, 0, this, 0, length);\n    if (len > padLen) {\n      let count = (len - 1) / padLen;\n      let base = count * padLen;\n      let rest = len - base;\n      repeatUnsafe(out, length, padString, count);\n      if (rest) copyUnsafe(out, base + length, padString, 0, rest);\n    } else {\n      copyUnsafe(out, length, padString, 0, len);\n    }\n    return out;\n  }\n\n  repeat(count: i32 = 0): String {\n    assert(this !== null);\n    var length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || length * count > (1 << 28)) {\n      throw new RangeError(\"Invalid count value\");\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n\n    var result = allocateUnsafe(length * count);\n    repeatUnsafe(result, 0, this, count);\n    return result;\n  }\n\n  slice(beginIndex: i32, endIndex: i32 = i32.MAX_VALUE): String {\n    var len = this.length;\n    var begin = beginIndex < 0 ? max(beginIndex + len, 0) : min(beginIndex, len);\n    var end = endIndex < 0 ? max(endIndex + len, 0) : min(endIndex, len);\n    len = end - begin;\n    if (len <= 0) return changetype<String>(\"\");\n    var out = allocateUnsafe(len);\n    copyUnsafe(out, 0, this, begin, len);\n    return out;\n  }\n\n  split(separator: String = null, limit: i32 = i32.MAX_VALUE): String[] {\n    assert(this !== null);\n    if (!limit) return new Array<String>();\n    if (separator === null) return <String[]>[this];\n    var length: isize = this.length;\n    var sepLen: isize = separator.length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return new Array<String>();\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = new Array<String>(length);\n      let buffer = <ArrayBuffer>result.buffer_;\n      for (let i: isize = 0; i < length; ++i) {\n        let char = allocateUnsafe(1);\n        store<u16>(\n          changetype<usize>(char),\n          load<u16>(\n            changetype<usize>(this) + (<usize>i << 1),\n            HEADER_SIZE\n          ),\n          HEADER_SIZE\n        );\n        STORE<String>(buffer, i, char);\n      }\n      return result;\n    } else if (!length) {\n      let result = new Array<String>(1);\n      unchecked(result[0] = changetype<String>(\"\"));\n      return result;\n    }\n    var result = new Array<String>();\n    var end = 0, start = 0, i = 0;\n    while ((end = this.indexOf(separator, start)) != -1) {\n      let len = end - start;\n      if (len > 0) {\n        let out = allocateUnsafe(len);\n        copyUnsafe(out, 0, this, start, len);\n        result.push(out);\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) {\n      let result = new Array<String>(1);\n      unchecked(result[0] = this);\n      return result;\n    }\n    var len = length - start;\n    if (len > 0) {\n      let out = allocateUnsafe(len);\n      copyUnsafe(out, 0, this, start, len);\n      result.push(out);\n    } else {\n      result.push(changetype<String>(\"\"));\n    }\n    return result;\n  }\n\n  toString(): String {\n    return this;\n  }\n\n  get lengthUTF8(): i32 {\n    var len = 1; // null terminated\n    var pos: usize = 0;\n    var end = <usize>this.length;\n    while (pos < end) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (pos << 1), HEADER_SIZE);\n      if (c < 128) {\n        len += 1; ++pos;\n      } else if (c < 2048) {\n        len += 2; ++pos;\n      } else {\n        if (\n          (c & 0xFC00) == 0xD800 && pos + 1 < end &&\n          (<u32>load<u16>(changetype<usize>(this) + ((pos + 1) << 1), HEADER_SIZE) & 0xFC00) == 0xDC00\n        ) {\n          len += 4; pos += 2;\n        } else {\n          len += 3; ++pos;\n        }\n      }\n    }\n    return len;\n  }\n\n  static fromUTF8(ptr: usize, len: usize): String {\n    if (len < 1) return changetype<String>(\"\");\n    var ptrPos = <usize>0;\n    var buf = memory.allocate(<usize>len << 1);\n    var bufPos = <usize>0;\n    while (ptrPos < len) {\n      let cp = <u32>load<u8>(ptr + ptrPos++);\n      if (cp < 128) {\n        store<u16>(buf + bufPos, cp);\n        bufPos += 2;\n      } else if (cp > 191 && cp < 224) {\n        assert(ptrPos + 1 <= len);\n        store<u16>(buf + bufPos, (cp & 31) << 6 | load<u8>(ptr + ptrPos++) & 63);\n        bufPos += 2;\n      } else if (cp > 239 && cp < 365) {\n        assert(ptrPos + 3 <= len);\n        cp = (\n          (cp                       &  7) << 18 |\n          (load<u8>(ptr + ptrPos++) & 63) << 12 |\n          (load<u8>(ptr + ptrPos++) & 63) << 6  |\n           load<u8>(ptr + ptrPos++) & 63\n        ) - 0x10000;\n        store<u16>(buf + bufPos, 0xD800 + (cp >> 10));\n        bufPos += 2;\n        store<u16>(buf + bufPos, 0xDC00 + (cp & 1023));\n        bufPos += 2;\n      } else {\n        assert(ptrPos + 2 <= len);\n        store<u16>(buf + bufPos,\n          (cp                       & 15) << 12 |\n          (load<u8>(ptr + ptrPos++) & 63) << 6  |\n           load<u8>(ptr + ptrPos++) & 63\n        );\n        bufPos += 2;\n      }\n    }\n    assert(ptrPos == len);\n    var str = allocateUnsafe(<u32>(bufPos >> 1));\n    memory.copy(changetype<usize>(str) + HEADER_SIZE, buf, bufPos);\n    memory.free(buf);\n    return str;\n  }\n\n  toUTF8(): usize {\n    var buf = memory.allocate(<usize>this.lengthUTF8);\n    var pos: usize = 0;\n    var end = <usize>this.length;\n    var off: usize = 0;\n    while (pos < end) {\n      let c1 = <u32>load<u16>(changetype<usize>(this) + (pos << 1), HEADER_SIZE);\n      if (c1 < 128) {\n        store<u8>(buf + off, c1);\n        ++off; ++pos;\n      } else if (c1 < 2048) {\n        let ptr = buf + off;\n        store<u8>(ptr, c1 >> 6      | 192);\n        store<u8>(ptr, c1      & 63 | 128, 1);\n        off += 2; ++pos;\n      } else {\n        let ptr = buf + off;\n        if ((c1 & 0xFC00) == 0xD800 && pos + 1 < end) {\n          let c2 = <u32>load<u16>(changetype<usize>(this) + ((pos + 1) << 1), HEADER_SIZE);\n          if ((c2 & 0xFC00) == 0xDC00) {\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\n            store<u8>(ptr, c1 >> 18      | 240);\n            store<u8>(ptr, c1 >> 12 & 63 | 128, 1);\n            store<u8>(ptr, c1 >> 6  & 63 | 128, 2);\n            store<u8>(ptr, c1       & 63 | 128, 3);\n            off += 4; pos += 2;\n            continue;\n          }\n        }\n        store<u8>(ptr, c1 >> 12      | 224);\n        store<u8>(ptr, c1 >> 6  & 63 | 128, 1);\n        store<u8>(ptr, c1       & 63 | 128, 2);\n        off += 3; ++pos;\n      }\n    }\n    store<u8>(buf + off, 0);\n    return buf;\n  }\n}\n\nexport type string = String;\n\nexport function parseInt(str: String, radix: i32 = 0): f64 {\n  return parse<f64>(str, radix);\n}\n\nexport function parseI32(str: String, radix: i32 = 0): i32 {\n  return parse<i32>(str, radix);\n}\n\nexport function parseI64(str: String, radix: i32 = 0): i64 {\n  return parse<i64>(str, radix);\n}\n\n// FIXME: naive implementation\nexport function parseFloat(str: String): f64 {\n  var len: i32 = str.length;\n  if (!len) return NaN;\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\n\n  // determine sign\n  var sign: f64;\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = 1;\n  } else {\n    sign = 1;\n  }\n\n  // calculate value\n  var num: f64 = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\n    if (code == CharCode.DOT) {\n      ptr += 2;\n      let fac: f64 = 0.1; // precision :(\n      while (len--) {\n        code = <i32>load<u16>(ptr, HEADER_SIZE);\n        if (code == CharCode.E || code == CharCode.e) {\n          assert(false); // TODO\n        }\n        code -= CharCode._0;\n        if (<u32>code > 9) break;\n        num += <f64>code * fac;\n        fac *= 0.1;\n        ptr += 2;\n      }\n      break;\n    }\n    code -= CharCode._0;\n    if (<u32>code >= 10) break;\n    num = (num * 10) + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n"]}
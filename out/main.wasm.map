{"version":3,"sources":["../out/near.ts","~lib/memory.ts","~lib/internal/allocator.ts","~lib/allocator/arena.ts","~lib/internal/arraybuffer.ts","~lib/internal/string.ts","~lib/internal/typedarray.ts","~lib/internal/memory.ts","../out/json/decoder.ts","~lib/string.ts","../out/main.ts","../out/main.near.ts","~lib/number.ts","~lib/internal/number.ts","~lib/builtins.ts","~lib/arraybuffer.ts","~lib/array.ts","../out/json/encoder.ts","../out/model.near.ts","~lib/math.ts"],"names":[],"mappings":"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","sourceRoot":"assemblyscript:///","sourceContents":["const DEFAULT_SCRATCH_BUFFER_SIZE: usize = 1 << 16;\n\ntype DataTypeIndex = u32;\n\nconst DATA_TYPE_ORIGINATOR_ACCOUNT_ID: DataTypeIndex = 1;\nconst DATA_TYPE_CURRENT_ACCOUNT_ID: DataTypeIndex = 2;\nconst DATA_TYPE_STORAGE: DataTypeIndex = 3;\nconst DATA_TYPE_INPUT: DataTypeIndex = 4;\nconst DATA_TYPE_RESULT: DataTypeIndex = 5;\nconst DATA_TYPE_STORAGE_ITER: DataTypeIndex = 6;\n\n/**\n * Represents contract storage.\n */\nexport class Storage {\n  private _scratchBuf: Uint8Array = new Uint8Array(DEFAULT_SCRATCH_BUFFER_SIZE);\n\n  /**\n   * Internal method to fetch list of keys from the given iterator up the limit.\n   */\n  private _fetchIter(iterId: u32, limit: i32 = -1): string[] {\n    let result: string[] = new Array<string>();\n    while (limit-- != 0) {\n      let key = this._internalReadString(DATA_TYPE_STORAGE_ITER, 0, iterId);\n      if (key != null) {\n        result.push(key);\n      }\n      if (!storage_iter_next(iterId)) {\n        break;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Returns list of keys between the given start key and the end key. Both inclusive.\n   * NOTE: Must be very careful to avoid exploding amount of compute with this method.\n   * @param start The start key used as a lower bound in lexicographical order. Inclusive.\n   * @param end The end key used as a upper bound in lexicographical order. Inclusive.\n   * @param limit The maximum number of keys to return. Default is `-1`, means no limit.\n   */\n  keyRange(start: string, end: string, limit: i32 = -1): string[] {\n    return this._fetchIter(\n      storage_range(start.lengthUTF8 - 1, start.toUTF8(), end.lengthUTF8 - 1, end.toUTF8()),\n      limit,\n    );\n  }\n\n  /**\n   * Returns list of keys starting with given prefix.\n   * NOTE: Must be very careful to avoid exploding amount of compute with this method.\n   * @param prefix The key prefix.\n   * @param limit The maximum number of keys to return. Default is `-1`, means no limit.\n   */\n  keys(prefix: string, limit: i32 = -1): string[] {\n    return this._fetchIter(\n      storage_iter(prefix.lengthUTF8 - 1, prefix.toUTF8()),\n      limit,\n    );\n  }\n\n  /**\n   * @deprecated Use setString or set<string>\n   */\n  setItem(key: string, value: string): void {\n    this.setString(key, value);\n  }\n\n  /**\n   * @deprecated Use getString or get<string>\n   */\n  getItem(key: string): string {\n    return this.getString(key);\n  }\n\n  /**\n   * Store string value under given key. Both key and value are encoded as UTF-8 strings.\n   */\n  setString(key: string, value: string): void {\n    storage_write(key.lengthUTF8 - 1, key.toUTF8(), value.lengthUTF8 - 1, value.toUTF8());\n  }\n\n  /**\n   * Get string value stored under given key. Both key and value are encoded as UTF-8 strings.\n   */\n  getString(key: string): string {\n    return this._internalReadString(DATA_TYPE_STORAGE, key.lengthUTF8 - 1, key.toUTF8());\n  }\n\n  /**\n   * Store byte array under given key. Key is encoded as UTF-8 strings.\n   * Byte array stored as is.\n   *\n   * It's convenient to use this together with `domainObject.encode()`.\n   */\n  setBytes(key: string, value: Uint8Array): void {\n    storage_write(key.lengthUTF8 - 1, key.toUTF8(), value.byteLength, value.buffer.data);\n  }\n\n  /**\n   * Get byte array stored under given key. Key is encoded as UTF-8 strings.\n   * Byte array stored as is.\n   *\n   * It's convenient to use this together with `DomainObject.decode()`.\n   */\n  getBytes(key: string): Uint8Array {\n    return this._internalReadBytes(DATA_TYPE_STORAGE, key.lengthUTF8 - 1, key.toUTF8());\n  }\n\n  /**\n   * Returns true if the given key is present in the storage.\n   */\n  contains(key: string): bool {\n    return storage_has_key(key.lengthUTF8 - 1, key.toUTF8());\n  }\n\n  @inline\n  hasKey(key: string): bool {\n    return this.contains(key);\n  }\n\n  delete(key: string): void {\n    storage_remove(key.lengthUTF8 - 1, key.toUTF8());\n  }\n\n  /**\n   * @deprecated Use #delete\n   */\n  @inline\n  remove(key: string): void {\n    this.delete(key);\n  }\n\n  /**\n   * @deprecated Use #delete\n   */\n  @inline\n  removeItem(key: string): void {\n    this.delete(key);\n  }\n\n  /**\n   * Store 64-bit unsigned int under given key. Key is encoded as UTF-8 strings.\n   * Number is encoded as decimal string.\n   */\n  setU64(key: string, value: u64): void {\n    this.setItem(key, value.toString());\n  }\n\n  /**\n   * Get 64-bit unsigned int stored under given key. Key is encoded as UTF-8 strings.\n   * Number is encoded as decimal string.\n   *\n   * @returns int value or 0 if value is not found\n   */\n  getU64(key: string): u64 {\n    return U64.parseInt(this.getItem(key) || \"0\");\n  }\n\n  /**\n   * Stores given generic value under the key. Key is encoded as UTF-8 strings.\n   * Supported types: bool, integer, string and data objects defined in model.ts.\n   *\n   * @param key A key to use for storage.\n   * @param value A value to store.\n   */\n  set<T>(key: string, value: T): void {\n    if (isString<T>()) {\n      this.setString(key, value);\n    } else if (isInteger<T>()) {\n      this.setString(key, value.toString());\n    } else {\n      this.setBytes(key, value.encode());\n    }\n  }\n\n  /**\n   * Gets given generic value stored under the key. Key is encoded as UTF-8 strings.\n   * Supported types: bool, integer, string and data objects defined in model.ts.\n   *\n   * @param key A key to read from storage.\n   * @param defaultValue The default value if the key is not available\n   * @returns A value of type T stored under the given key.\n   */\n  get<T>(key: string, defaultValue: T = null): T {\n    if (isString<T>() || isInteger<T>()) {\n      return near.parseFromString<T>(this.getString(key), defaultValue);\n    } else {\n      return near.parseFromBytes<T>(this.getBytes(key), defaultValue);\n    }\n  }\n\n  /**\n   * @hidden\n   * Reads given params into the internal scratch buffer and returns length.\n   */\n  private _internalBufferRead(dataType: DataTypeIndex, keyLen: usize, key: usize): usize {\n    for (let i = 0; i < 2; ++i) {\n      let len = data_read(\n        dataType,\n        keyLen,\n        key,\n        this._scratchBuf.byteLength,\n        this._scratchBuf.buffer.data,\n      );\n      if (len <= <usize>(this._scratchBuf.byteLength)) {\n        return len;\n      }\n      this._scratchBuf = new Uint8Array(len);\n    }\n    assert(false, \"Internal scratch buffer was resized more than once\");\n    return 0;\n  }\n\n  /**\n   * @hidden\n   * Reads a string for the given params.\n   */\n  _internalReadString(dataType: DataTypeIndex, keyLen: usize, key: usize): string {\n    let len = this._internalBufferRead(dataType, keyLen, key);\n    if (len == 0) {\n      return null;\n    }\n    return String.fromUTF8(this._scratchBuf.buffer.data, len);\n  }\n\n  /**\n   * @hidden\n   * Reads bytes for the given params.\n   */\n  _internalReadBytes(dataType: DataTypeIndex, keyLen: usize, key: usize): Uint8Array {\n    let len = this._internalBufferRead(dataType, keyLen, key);\n    if (len == 0) {\n      return null;\n    }\n    let res = new Uint8Array(len);\n    memory.copy(res.buffer.data, this._scratchBuf.buffer.data, len);\n    return res;\n  }\n}\n\n/**\n * An instance of a Storage class that is used for working with contract storage on the blockchain.\n */\nexport let storage: Storage = new Storage();\n\n/**\n * A namespace with classes and functions for persistent collections on the blockchain.\n */\nexport namespace collections {\n  const _KEY_LENGTH_SUFFIX = \":len\";\n  const _KEY_FRONT_INDEX_SUFFIX = \":front\";\n  const _KEY_BACK_INDEX_SUFFIX = \":back\";\n  const _KEY_ELEMENT_SUFFIX = \"::\";\n  const _KEY_RATING_SUFFIX = \":r\";\n  const _RATING_OFFSET: u64 = 2147483648;\n\n  /**\n   * A vector class that implements a persistent array.\n   */\n  export class Vector<T> {\n    private _elementPrefix: string;\n    private _lengthKey: string;\n    private _length: i32;\n\n    /**\n     * Creates or restores a persistent vector with a given storage prefix.\n     * Always use a unique storage prefix for different collections.\n     * @param prefix A prefix to use for every key of this vector.\n     */\n    constructor(prefix: string) {\n      this._elementPrefix = prefix + _KEY_ELEMENT_SUFFIX;\n      this._lengthKey = prefix + _KEY_LENGTH_SUFFIX;\n      this._length = -1;\n    }\n\n    /**\n     * @returns An interal key for a given index.\n     */\n    @inline\n    private _key(index: i32): string {\n      return this._elementPrefix + index.toString();\n    }\n\n    /**\n     * Removes the content of the element from storage without changing length of the vector.\n     * @param index The index of the element to remove.\n     */\n    delete(index: i32): void {\n      assert(this.containsIndex(index), \"Index out of range\");\n      storage.delete(this._key(index));\n    }\n\n    /**\n     * @param index The index to check.\n     * @returns True if the given index is within the range of the vector indices.\n     */\n    containsIndex(index: i32): bool {\n      return index >= 0 && index < this.length;\n    }\n\n    /**\n     * @returns True if the vector is empty.\n     */\n    get isEmpty(): bool {\n      return this.length == 0;\n    }\n\n    /**\n     * @returns The length of the vector.\n     */\n    get length(): i32 {\n      if (this._length < 0) {\n        this._length = storage.get<i32>(this._lengthKey, 0);\n      }\n      return this._length;\n    }\n\n    /**\n     * Internally sets the length of the vector\n     */\n    private set length(value: i32) {\n      this._length = value;\n      storage.set<i32>(this._lengthKey, value);\n    }\n\n    /**\n     * Returns the element of the vector for a given index. Asserts the given index is within the\n     * range of the vector.\n     * @param index The index of the element to return.\n     * @returns The element at the given index.\n     */\n    @operator(\"[]\")\n    private __get(index: i32): T {\n      assert(this.containsIndex(index), \"Index out of range\");\n      return this.__unchecked_get(index);\n    }\n\n    /**\n     * Returns the element of the vector for a given index without checks.\n     * @param index The index of the element to return.\n     * @returns The element at the given index.\n     */\n    @operator(\"{}\")\n    private __unchecked_get(index: i32): T {\n      return storage.get<T>(this._key(index));\n    }\n\n    /**\n     * Sets the value of an element at the given index. Asserts the given index is within the\n     * range of the vector.\n     * @param index The index of the element.\n     * @param value The new value.\n     */\n    @operator(\"[]=\")\n    private __set(index: i32, value: T): void {\n      assert(this.containsIndex(index), \"Index out of range\");\n      this.__unchecked_set(index, value);\n    }\n\n    /**\n     * Sets the value of an element at the given index without checks.\n     * @param index The index of the element.\n     * @param value The new value.\n     */\n    @operator(\"{}=\")\n    private __unchecked_set(index: i32, value: T): void {\n      storage.set<T>(this._key(index), value);\n    }\n\n    /**\n     * Adds a new element to the end of the vector. Increases the length of the vector.\n     * @param element A new element to add.\n     * @returns The index of a newly added element\n     */\n    push(element: T): i32 {\n      let index = this.length;\n      this.length = index + 1;\n      this.__unchecked_set(index, element);\n      return index;\n    }\n\n    /**\n     * Adds a new element to the end of the vector. Increases the length of the vector.\n     * @param element A new element to add.\n     * @returns The index of a newly added element\n     */\n    @inline\n    pushBack(element: T): i32 {\n      return this.push(element);\n    }\n\n    /**\n     * Removes the last element from the vector and returns it. Asserts that the vector is not empty.\n     * Decreases the length of the vector.\n     * @returns The removed last element of the vector.\n     */\n    pop(): T {\n      assert(this.length > 0, \"Vector is empty\");\n      let index = this.length - 1;\n      this.length = index;\n      let result = this.__unchecked_get(index);\n      storage.delete(this._key(index));\n      return result;\n    }\n\n    /**\n     * Removes the last element from the vector and returns it. Asserts that the vector is not empty.\n     * Decreases the length of the vector.\n     * @returns The removed last element of the vector.\n     */\n    @inline\n    popBack(): T {\n      return this.pop();\n    }\n\n    /**\n     * @returns The last element of the vector. Asserts that the vector is not empty.\n     */\n    get back(): T {\n      return this.__get(this.length - 1);\n    }\n\n    /**\n     * @returns The last element of the vector. Asserts that the vector is not empty.\n     */\n    @inline\n    get last(): T {\n      return this.back;\n    }\n\n    /**\n     * @returns The first element of the vector. Asserts that the vector is not empty.\n     */\n    get front(): T {\n      return this.__get(0);\n    }\n\n    /**\n     * @returns The first element of the vector. Asserts that the vector is not empty.\n     */\n    @inline\n    get first(): T {\n      return this.front;\n    }\n  }\n\n\n  /**\n   * A deque class that implements a persistent bidirectional queue.\n   */\n  export class Deque<T> {\n    private _elementPrefix: string;\n    private _frontIndexKey: string;\n    private _backIndexKey: string;\n    private _frontIndex: i32;\n    private _backIndex: i32;\n\n    /**\n     * Creates or restores a persistent deque with a given storage prefix.\n     * Always use a unique storage prefix for different collections.\n     * @param prefix A prefix to use for every key of this deque.\n     */\n    constructor(prefix: string) {\n      this._elementPrefix = prefix + _KEY_ELEMENT_SUFFIX;\n      this._frontIndexKey = prefix + _KEY_FRONT_INDEX_SUFFIX;\n      this._backIndexKey = prefix + _KEY_BACK_INDEX_SUFFIX;\n      this._frontIndex = i32.MIN_VALUE;\n      this._backIndex = i32.MAX_VALUE;\n    }\n\n    /**\n     * @returns An interal key for a given index.\n     */\n    @inline\n    private _key(index: i32): string {\n      return this._elementPrefix + index.toString();\n    }\n\n    /**\n     * @returns The index of the first/front element of the deque (inclusive).\n     */\n    private get frontIndex(): i32 {\n      if (this._frontIndex == i32.MIN_VALUE) {\n        this._frontIndex = storage.get<i32>(this._frontIndexKey, 0);\n      }\n      return this._frontIndex;\n    }\n\n    /**\n     * Internal. Sets the index of the first/front element.\n     */\n    private set frontIndex(value: i32) {\n      this._frontIndex = value;\n      storage.set<i32>(this._frontIndexKey, value);\n    }\n\n    /**\n     * @returns The index of the last/back element of the deque (inclusive).\n     */\n    private get backIndex(): i32 {\n      if (this._backIndex == i32.MAX_VALUE) {\n        this._backIndex = storage.get<i32>(this._backIndexKey, -1);\n      }\n      return this._backIndex;\n    }\n\n    /**\n     * Internal. Sets the index of the last/back element.\n     */\n    private set backIndex(value: i32) {\n      this._backIndex = value;\n      storage.set<i32>(this._backIndexKey, value);\n    }\n\n    /**\n     * @param index The index to check.\n     * @returns True if the given index is within the range of the deque indices.\n     */\n    containsIndex(index: i32): bool {\n      return index >= 0 && index < this.length;\n    }\n\n    /**\n     * Removes the content of the element from storage without changing length of the deque.\n     * @param index The index of the element to remove.\n     */\n    delete(index: i32): void {\n      assert(this.containsIndex(index), \"Index out of range\");\n      storage.delete(this._key(index + this.frontIndex));\n    }\n\n    /**\n     * @returns The length of the deque.\n     */\n    get length(): i32 {\n      return this.backIndex - this.frontIndex + 1;\n    }\n\n    /**\n     * @returns True if the deque is empty.\n     */\n    get isEmpty(): bool {\n      return this.length == 0;\n    }\n\n    /**\n     * Returns the element of the deque for a given index. Asserts the given index is within the\n     * range of the vector.\n     * @param index The index of the element to return.\n     * @returns The element at the given index.\n     */\n    @operator(\"[]\")\n    private __get(index: i32): T {\n      assert(this.containsIndex(index), \"Index out of range\");\n      return this.__unchecked_get(index);\n    }\n\n    /**\n     * Returns the element of the deque for a given index without checks.\n     * @param index The index of the element to return.\n     * @returns The element at the given index.\n     */\n    @operator(\"{}\")\n    private __unchecked_get(index: i32): T {\n      return storage.get<T>(this._key(index + this.frontIndex));\n    }\n\n    /**\n     * Sets the new value of an element at the given index. Asserts the given index is within the\n     * range of the deque.\n     * @param index The index of the element.\n     * @param value The new value.\n     */\n    @operator(\"[]=\")\n    private __set(index: i32, value: T): void {\n      assert(this.containsIndex(index), \"Index out of range\");\n      this.__unchecked_set(index, value);\n    }\n\n    /**\n     * Sets the new value of an element at the given index without checks.\n     * @param index The index of the element.\n     * @param value The new value.\n     */\n    @operator(\"{}=\")\n    private __unchecked_set(index: i32, value: T): void {\n      storage.set<T>(this._key(index + this.frontIndex), value);\n    }\n\n    /**\n     * Adds a new element in front of the deque. Increases the length of the deque.\n     * @param element A new element to add.\n     * @returns The index of a newly added element\n     */\n    pushFront(element: T): i32 {\n      this.frontIndex -= 1;\n      this.__unchecked_set(0, element);\n      return 0;\n    }\n\n    /**\n     * Removes the first/front element from the deque and returns it.\n     * Asserts that the deque is not empty. Decreases the length of the deque.\n     * @returns The removed first element of the queue.\n     */\n    popFront(): T {\n      assert(this.length > 0, \"Deque is empty\");\n      let result = this.__unchecked_get(0);\n      storage.delete(this._key(this.frontIndex));\n      this.frontIndex += 1;\n      return result;\n    }\n\n    /**\n     * @returns The first/front element of the deque.\n     */\n    get front(): T {\n      return this.__get(0);\n    }\n\n    /**\n     * @returns The first/front element of the deque.\n     */\n    @inline\n    get first(): T {\n      return this.front;\n    }\n\n    /**\n     * Adds a new element to the end of the deque. Increases the length of the deque.\n     * @param element A new element to add.\n     * @returns The index of a newly added element\n     */\n    pushBack(element: T): i32 {\n      let index = this.length;\n      this.backIndex += 1;\n      this.__unchecked_set(index, element);\n      return index;\n    }\n\n    /**\n     * Removes the last/back element from the deque and returns it.\n     * Asserts that the deque is not empty. Decreases the length of the deque.\n     * @returns The removed first element of the queue.\n     */\n    popBack(): T {\n      let index = this.length - 1;\n      assert(index >= 0, \"Deque is empty\");\n      let result = this.__unchecked_get(index);\n      storage.delete(this._key(this.backIndex));\n      this.backIndex -= 1;\n      return result;\n    }\n\n    /**\n     * @returns The last/back element of the deque.\n     */\n    get back(): T {\n      return this.__get(this.length - 1);\n    }\n\n    /**\n     * @returns The last/back element of the deque.\n     */\n    @inline\n    get last(): T {\n      return this.back;\n    }\n  }\n\n\n  /**\n   * A map class that implements a persistent unordered map.\n   * NOTE: The Map doesn't store keys, so if you need to retrive them, include keys in the values.\n   */\n  export class Map<K, V> {\n    private _elementPrefix: string;\n\n    /**\n     * Creates or restores a persistent map with a given storage prefix.\n     * Always use a unique storage prefix for different collections.\n     * @param prefix A prefix to use for every key of this map.\n     */\n    constructor(prefix: string) {\n      this._elementPrefix = prefix + _KEY_ELEMENT_SUFFIX;\n    }\n\n    /**\n     * @returns An interal string key for a given key of type K.\n     */\n    private _key(key: K): string {\n      return this._elementPrefix + key.toString();\n    }\n\n    /**\n     * Returns values of the map between the given start key and the end key.\n     * @param start Starting from which key to include values. Default is `null`, means from the beginning.\n     * @param end Up to which key include values (inclusive). Default is `null`, means to the end.\n     * @param limit The maximum number of values to return. Default is `-1`, means no limit.\n     * @param startInclusive Whether the start key is inclusive. Default is `true`, means include start key.\n     *     It's useful to set it to false for pagination.\n     */\n    values(start: K = null, end: K = null, limit: i32 = -1, startInclusive: bool = true): V[] {\n      let startKey = (start != null) ? this._key(start) : this._elementPrefix;\n      if (!startInclusive) {\n        startKey += String.fromCharCode(0);\n      }\n      let endKey = (end != null) ? this._key(end) : (this._elementPrefix + String.fromCharCode(255));\n      let keys = storage.keyRange(startKey, endKey, limit);\n      return keys.map<V>((key: string) => storage.get<V>(key));\n    }\n\n    /**\n     * @param key Key to check.\n     * @returns True if the given key present in the map.\n     */\n    contains(key: K): bool {\n      return storage.contains(this._key(key));\n    }\n\n    /**\n     * Removes value and the key from the map.\n     * @param key Key to remove.\n     */\n    delete(key: K): void {\n      storage.delete(this._key(key));\n    }\n\n    /**\n     * @param key Key of the element.\n     * @param defaultValue The default value if the key is not present.\n     * @returns Value for the given key or the default value.\n     */\n    get(key: K, defaultValue: V = null): V {\n      return storage.get<V>(this._key(key), defaultValue);\n    }\n\n    /**\n     * Sets the new value for the given key.\n     * @param key Key of the element.\n     * @param value The new value of the element.\n     */\n    set(key: K, value: V): void {\n      storage.set<V>(this._key(key), value);\n    }\n  }\n\n  /**\n   * A TopN class that can return first N keys of a type K sorted by rating. Rating is stored as i32.\n   * Default sort order is descending (highest rated keys), but can be changed to ascending (lowest rated keys).\n   */\n  export class TopN<K> {\n    // Internally, this prefix is used for storing padded ratings\n    private _orderPrefix: string;\n    // Whether the order is descending\n    private _descending: bool;\n    // Number of unique keys.\n    private _length: i32;\n    // The key to store length.\n    private _lengthKey: string;\n\n    // A map to store rating by key\n    private _ratings: Map<K, i32>;\n\n    /**\n     * Creates or restores a persistent top N collection with a given storage prefix.\n     * Always use a unique storage prefix for different collections.\n     * @param prefix A prefix to use for every key of this collection.\n     * @param descending Sorting order of keys for rating. Default is descending (the highest rated keys).\n     */\n    constructor(prefix: string, descending: bool = true) {\n      this._ratings = new Map<K, i32>(prefix + _KEY_RATING_SUFFIX);\n      this._orderPrefix = prefix + _KEY_ELEMENT_SUFFIX;\n      this._descending = descending;\n      this._lengthKey = prefix + _KEY_LENGTH_SUFFIX;\n      this._length = -1;\n    }\n\n    /**\n     * @returns A suffix for an internal key for a given external key of type K.\n     */\n    private _keySuffix(key: K): string {\n      return _KEY_ELEMENT_SUFFIX + key.toString();\n    }\n\n    /**\n     * @returns Converted integer rating into a padded string.\n     */\n    private _ratingKey(rating: i32): string {\n      let r: u32 = <u32>((<i64>rating) + _RATING_OFFSET);\n      if (this._descending) {\n        r = u32.MAX_VALUE - r;\n      }\n      return r.toString().padStart(10, \"0\");\n    }\n\n    /**\n     * Creates an internal key from a given rating and a given external key.\n     */\n    private _orderKey(rating: i32, key: K): string {\n      return this._orderPrefix + this._ratingKey(rating) + this._keySuffix(key);\n    }\n\n    /**\n     * @returns True if the TopN collection is empty.\n     */\n    get isEmpty(): bool {\n      return this.length == 0;\n    }\n\n    /**\n     * @returns The number of unique elements in the TopN collection.\n     */\n    get length(): i32 {\n      if (this._length < 0) {\n        this._length = storage.get<i32>(this._lengthKey, 0);\n      }\n      return this._length;\n    }\n\n    /**\n     * Internally sets the length of the collection.\n     */\n    private set length(value: i32) {\n      this._length = value;\n      storage.set<i32>(this._lengthKey, value);\n    }\n\n\n    /**\n     * @param key Key to check.\n     * @returns True if the given key is present.\n     */\n    contains(key: K): bool {\n      return this._ratings.contains(key);\n    }\n\n    /**\n     * Removes rating and the key from the collection.\n     * @param key Key to remove.\n     */\n    delete(key: K): void {\n      if (this.contains(key)) {\n        let rating = this._ratings.get(key);\n        this._ratings.delete(key);\n        storage.delete(this._orderKey(rating, key));\n        this.length -= 1;\n      }\n    }\n\n    /**\n     * @param keys The array of keys to lookup rating.\n     * @returns an array of key to rating pairs for the given keys.\n     */\n    keysToRatings(keys: K[]): near.MapEntry<K, i32>[] {\n      let result = new Array<near.MapEntry<K, i32>>(keys.length);\n      for (let index = 0; index < keys.length; ++index) {\n        let key = keys[index];\n        result[index] = new near.MapEntry<K, i32>(key, this._ratings.get(key));\n      }\n      return result;\n    }\n\n    /**\n     * @param limit The maximum limit of keys to return.\n     * @returns The array of top rated keys.\n     */\n    getTop(limit: i32): K[] {\n      let orderKeys = storage.keys(this._orderPrefix, limit);\n      return orderKeys.map<K>((orderKey: string) => storage.get<K>(orderKey));\n    }\n\n    /**\n     * Returns a top list starting from the given key (exclusive). It's useful for pagination.\n     * @param limit The maximum limit of keys to return.\n     * @param fromKey The key from which return top list (exclisive).\n     * @returns The array of top rated keys starting from the given key.\n     */\n    getTopFromKey(limit: i32, fromKey: K): K[] {\n      let rating = this.getRating(fromKey, 0);\n      let orderKeys = storage.keyRange(\n        this._orderKey(rating, fromKey) + String.fromCharCode(0),\n        this._orderPrefix + String.fromCharCode(255),\n        limit);\n      return orderKeys.map<K>((orderKey: string) => storage.get<K>(orderKey));\n    }\n\n    /**\n     * @param limit The maximum limit of keys to return.\n     * @returns The array of top rated keys with their corresponding rating.\n     */\n    getTopWithRating(limit: i32): near.MapEntry<K, i32>[] {\n      return this.keysToRatings(this.getTop(limit));\n    }\n\n    /**\n     * Returns a top list with rating starting from the given key (exclusive).\n     * It's useful for pagination.\n     * @param limit The maximum limit of keys to return.\n     * @param fromKey The key from which return top list (exclisive).\n     * @returns The array of top rated keys with their rating starting from the given key.\n     */\n    getTopWithRatingFromKey(limit: i32, fromKey: K): near.MapEntry<K, i32>[] {\n      return this.keysToRatings(this.getTopFromKey(limit, fromKey));\n    }\n\n    /**\n     * @param key Key of the element.\n     * @param defaultRating The default rating to return if the key is not present.\n     * @returns Value for the given key or the defaultRating.\n     */\n    getRating(key: K, defaultRating: i32 = 0): i32 {\n      return this._ratings.get(key, defaultRating);\n    }\n\n    /**\n     * Sets the new rating for the given key.\n     * @param key The key to update.\n     * @param rating The new rating of the key.\n     */\n    setRating(key: K, rating: i32): void {\n      if (this.contains(key)) {\n        let oldRating = this.getRating(key);\n        storage.delete(this._orderKey(oldRating, key));\n      } else {\n        this.length += 1;\n      }\n      this._ratings.set(key, rating);\n      storage.set<K>(this._orderKey(rating, key), key);\n    }\n\n    /**\n     * Increments rating of the given key by the given increment (1 by default).\n     * @param key The key to update.\n     * @param increment The increment value for the rating (1 by default).\n     */\n    incrementRating(key: K, increment: i32 = 1): void {\n      let oldRating = 0;\n      if (this.contains(key)) {\n        oldRating = this.getRating(key);\n        storage.delete(this._orderKey(oldRating, key));\n      } else {\n        this.length += 1;\n      }\n      let rating = oldRating + increment;\n      this._ratings.set(key, rating);\n      storage.set<K>(this._orderKey(rating, key), key);\n    }\n  }\n\n  /**\n   * Creates or restores a persistent vector with a given storage prefix.\n   * Always use a unique storage prefix for different collections.\n   * @param prefix A prefix to use for every key of this vector.\n   */\n  export function vector<T>(prefix: string): Vector<T> {\n    return new Vector<T>(prefix);\n  }\n\n  /**\n   * Creates or restores a persistent deque with a given storage prefix.\n   * Always use a unique storage prefix for different collections.\n   * @param prefix A prefix to use for every key of this deque.\n   */\n  export function deque<T>(prefix: string): Deque<T> {\n    return new Deque<T>(prefix);\n  }\n\n  /**\n   * Creates or restores a persistent map with a given storage prefix.\n   * Always use a unique storage prefix for different collections.\n   * @param prefix A prefix to use for every key of this map.\n   */\n  export function map<K, V>(prefix: string): Map<K, V> {\n    return new Map<K, V>(prefix);\n  }\n\n  /**\n   * Creates or restores a persistent TopN with a given storage prefix.\n   * Always use a unique storage prefix for different collections.\n   * @param prefix A prefix to use for every key of this collection.\n   * @param descending Sorting order of keys for rating. Default is descending (the highest rated keys).\n   */\n  export function topN<K>(prefix: string, descending: bool = true): TopN<K> {\n    return new TopN<K>(prefix, descending);\n  }\n}\n\n/**\n * Provides context for contract execution, including information about transaction sender, etc.\n */\nclass Context {\n  /**\n   * Account ID of transaction sender.\n   */\n  get sender(): string {\n    return storage._internalReadString(DATA_TYPE_ORIGINATOR_ACCOUNT_ID, 0, 0);\n  }\n\n  /**\n   * Account ID of contract.\n   */\n  get contractName(): string {\n    return storage._internalReadString(DATA_TYPE_CURRENT_ACCOUNT_ID, 0, 0);\n  }\n\n  /**\n   * Current block index.\n   */\n  get blockIndex(): u64 {\n    return block_index();\n  }\n\n  /**\n   * The amount of tokens received with this execution call.\n   */\n  get receivedAmount(): u64 {\n    return received_amount();\n  }\n\n  /**\n   * The amount of tokens that are locked in the account. Storage usage fee is deducted from this balance.\n   */\n  get frozenBalance(): u64 {\n    return frozen_balance();\n  }\n\n  /**\n   * The amount of tokens that can be used for running wasm, creating transactions, and sending to other contracts\n   * through cross-contract calls.\n   */\n  get liquidBalance(): u64 {\n      return liquid_balance();\n  }\n\n  /**\n   * The current storage usage in bytes.\n   */\n  get storageUsage(): u64 {\n    return storage_usage();\n  }\n\n  /**\n   * Moves assets from liquid balance to frozen balance.\n   * If there is enough liquid balance will deposit the maximum amount. Otherwise will deposit as much as possible.\n   * Will fail if there is less than minimum amount on the liquid balance. Returns the deposited amount.\n   */\n  deposit(minAmount: u64, maxAmount: u64): u64 {\n    deposit(minAmount, maxAmount)\n  }\n\n   /**\n   * Moves assets from frozen balance to liquid balance.\n   * If there is enough frozen balance will withdraw the maximum amount. Otherwise will withdraw as much as possible.\n   * Will fail if there is less than minimum amount on the frozen balance. Returns the withdrawn amount.\n   */\n  withdraw(minAmount: u64, maxAmount: u64): u64 {\n    withdraw(minAmount, maxAmount)\n  }\n}\n\nexport let context: Context = new Context();\n\nexport namespace near {\n\n  /**\n   * Parses the given string to return a value of the given generic type.\n   * Supported types: bool, integer, string and data objects defined in model.ts.\n   *\n   * @param s String to parse.\n   * @param defaultValue The default value if the string is null\n   * @returns A parsed value of type T.\n   */\n  export function parseFromString<T>(s: string, defaultValue: T = null): T {\n    if (s == null) {\n      return defaultValue;\n    }\n    if (isString<T>()) {\n      return s;\n    } else if (isInteger<T>()) {\n      if (defaultValue instanceof bool) {\n        return <T>(s == \"true\");\n      } else if (isSigned<T>()) {\n        return <T>I64.parseInt(s);\n      } else {\n        return <T>U64.parseInt(s);\n      }\n    } else {\n      let v = instantiate<T>();\n      return v.decode(stringToBytes(s));\n    }\n  }\n\n  /**\n   * Parses the given bytes array to return a value of the given generic type.\n   * Supported types: bool, integer, string and data objects defined in model.ts.\n   *\n   * @param bytes Bytes to parse.\n   * @param defaultValue The default value if the bytes are null\n   * @returns A parsed value of type T.\n   */\n  export function parseFromBytes<T>(bytes: Uint8Array, defaultValue: T = null): T {\n    if (bytes == null) {\n      return defaultValue;\n    }\n    if (isString<T>() || isInteger<T>()) {\n      return parseFromString<T>(bytesToString(bytes), defaultValue);\n    } else {\n      let v = instantiate<T>();\n      return v.decode(bytes);\n    }\n  }\n\n  export function bytesToString(bytes: Uint8Array): string {\n    return String.fromUTF8(bytes.buffer.data + bytes.byteOffset, bytes.byteLength)\n  }\n\n  export function stringToBytes(s: string): Uint8Array {\n    let len = s.lengthUTF8 - 1;\n    let bytes = new Uint8Array(len);\n    memory.copy(bytes.buffer.data, s.toUTF8(), len);\n    return bytes;\n  }\n\n  /**\n   * Helper class to store key->value pairs.\n   */\n  export class MapEntry<K, V> {\n    key: K;\n    value: V;\n\n    constructor(key: K, value: V) {\n      this.key = key;\n      this.value = value;\n    }\n  }\n\n  /**\n   * Hash given data. Returns hash as 32-byte array.\n   * @param data data can be passed as either Uint8Array or anything with .toString (hashed as UTF-8 string).\n   */\n  export function hash<T>(data: T): Uint8Array {\n    let result = new Uint8Array(32);\n    if (data instanceof Uint8Array) {\n      _near_hash(data.byteLength, data.buffer.data, result.buffer.data);\n    } else {\n      let str = data.toString();\n      _near_hash(str.lengthUTF8 - 1, str.toUTF8(), result.buffer.data);\n    }\n    return result;\n  }\n\n  /**\n   * Hash given data. Returns hash as 32-bit integer.\n   * @param data data can be passed as either Uint8Array or anything with .toString (hashed as UTF-8 string).\n   */\n  export function hash32<T>(data: T): u32 {\n    let dataToHash : Uint8Array;\n    if (data instanceof Uint8Array) {\n      return _near_hash32(data.byteLength, data.buffer.data);\n    } else {\n      let str = data.toString();\n      return _near_hash32(str.lengthUTF8 - 1, str.toUTF8());\n    }\n  }\n\n  /**\n   * Returns random byte buffer of given length.\n   */\n  export function randomBuffer(len: u32): Uint8Array {\n    let result = new Uint8Array(len);\n    _near_random_buf(len, result.buffer.data);\n    return result;\n  }\n\n  /**\n   * Returns random 32-bit integer.\n   */\n  export function random32(): u32 {\n    return random32();\n  }\n\n  export function log(msg: string): void {\n    _near_log(<usize>msg);\n  }\n\n  export function str<T>(value: T): string {\n    let arr: Array<T> = [value];\n    return arr.toString();\n  }\n\n  export function base58(source: Uint8Array): string {\n    // Code converted from:\n    // https://github.com/cryptocoinjs/base-x/blob/master/index.js\n    const iFACTOR = 2; // TODO: Calculate precise value to avoid overallocating\n    const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n    let BASE = ALPHABET.length;\n    let LEADER = ALPHABET.charAt(0);\n\n    // Skip & count leading zeroes.\n    let zeroes = 0\n    let length = 0\n    let pbegin = 0\n    let pend = source.length\n\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n\n    // Allocate enough space in big-endian base58 representation.\n    let size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    let b58 = new Uint8Array(size)\n\n    // Process the bytes.\n    while (pbegin !== pend) {\n      let carry = i32(source[pbegin])\n\n      // Apply \"b58 = b58 * 256 + ch\".\n      let i = 0\n      for (let it = size - 1; (carry !== 0 || i < length) && (it !== -1); it--, i++) {\n        carry += (256 * b58[it]) >>> 0\n        b58[it] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n\n      assert(carry == 0, 'Non-zero carry');\n      length = i\n      pbegin++\n    }\n\n    // Skip leading zeroes in base58 result.\n    let it = size - length\n    while (it !== size && b58[it] === 0) {\n      it++\n    }\n\n    // Translate the result into a string.\n    let str = LEADER.repeat(zeroes)\n    for (; it < size; ++it) str += ALPHABET.charAt(b58[it])\n\n    return str\n  }\n}\n\n/**\n * Class to make asynchronous calls to other contracts and receive callbacks.\n * Here is an example on how to create a new async call with the callback.\n * ```\n * export function callMetaNear(): void {\n *   let itemArgs: AddItemArgs = {\n *     accountId: \"alice.near\",\n *     itemId: \"Sword +9000\",s\n *   };\n *   let promise = ContractPromise.create(\n *     \"metanear\",\n *     \"addItem\",\n *     itemArgs.encode(),\n *     0,\n *   );\n *   // Setting up args for the callback\n *   let requestArgs: OnItemAddedArgs = {\n *     \"itemAddedRequestId\": \"UNIQUE_REQUEST_ID\",\n *   };\n *   let callbackPromise = promise.then(\n *      \"_onItemAdded\",\n *      requestArgs.encode(),\n *      2,  // Attaching 2 additional requests, in case we need to do another call\n *   );\n *   callbackPromise.returnAsResult();\n * }\n * ```\n * See docs on used methods for more details.\n */\nexport class ContractPromise {\n  // Session-based unique promise ID. Don't preserve it longer than this execution.\n  id: i32;\n\n  /**\n   * Creates a new async call promise. Returns an instance of `ContractPromise`.\n   * The call would be scheduled if the this current execution of the contract succeeds\n   * without errors or failed asserts.\n   * @param contractName Account ID of the remote contract to call. E.g. `metanear`.\n   * @param methodName Method name on the remote contract to call. E.g. `addItem`.\n   * @param args Serialized arguments to pass into the method. To get them create a new model\n   *     specific for the method you calling, e.g. `AddItemArgs`. Then create an instance of it\n   *     and populate arguments. After this, serialize it into bytes. E.g.\n   *     ```\n   *     let itemArgs: AddItemArgs = {\n   *       accountId: \"alice.near\",\n   *       itemId: \"Sword +9000\",\n   *     };\n   *     // Serialize args\n   *     let args = itemArgs.encode();\n   *     ```\n   * @param amount The amount of tokens from your contract to be sent to the remote contract with this call.\n   */\n  static create(\n      contractName: string,\n      methodName: string,\n      args: Uint8Array,\n      amount: u64 = 0\n  ): ContractPromise {\n    return {\n      id: promise_create(\n        contractName.lengthUTF8 - 1, contractName.toUTF8(),\n        methodName.lengthUTF8 - 1, methodName.toUTF8(),\n        args.byteLength, args.buffer.data,\n        amount)\n    };\n  }\n\n  /**\n   * Creating a callback for the AsyncCall Promise created with `create` method.\n   * @param methodName Method name on your contract to be called to receive the callback.\n   *     NOTE: Your callback method name can start with `_`, which would prevent other\n   *     contracts from calling it directly. Only callbacks can call methods with `_` prefix.\n   * @param args Serialized arguments on your callback method, see `create` for details.\n   * @param amount The amount of tokens from the called contract to be sent to the current contract with this call.\n   */\n  then(\n      methodName: string,\n      args: Uint8Array,\n      amount: u64\n  ): ContractPromise {\n    return {\n      id: promise_then(\n        this.id,\n        methodName.lengthUTF8 - 1, methodName.toUTF8(),\n        args.byteLength, args.buffer.data,\n        amount)\n    };\n  }\n\n  /**\n   * Returns the promise as a result of your function. Don't return any other results from the function.\n   * Your current function should be `void` and shouldn't return anything else. E.g.\n   * ```\n   * export function callMetaNear(): void {\n   *   let itemArgs: AddItemArgs = {\n   *     accountId: \"alice.near\",\n   *     itemId: \"Sword +9000\",\n   *   };\n   *   let promise = ContractPromise.create(\n   *     \"metanear\",\n   *     \"addItem\",\n   *     itemArgs.encode(),\n   *     0,\n   *     0,\n   *   );\n   *   promise.returnAsResult();\n   * }\n   * ```\n   *\n   * Now when you call `callMetaNear` method, it creates new promise to `metanear` contract.\n   * And saying that the result of the current execution depends on the result `addItem`.\n   * Even though this contract is not going to be called with a callback, the contract which\n   * calling `callMetaNear` would receive the result from `addItem`. This call essentially acts\n   * as a proxy.\n   *\n   * You can also attach a callback on top of the promise before returning it, e.g.\n   *\n   * ```\n   *   ...\n   *   let promise = ContractPromise.create(\n   *      ...\n   *   );\n   *   // Setting up args for the callback\n   *   let requestArgs: OnItemAddedArgs = {\n   *     \"itemAddedRequestId\": \"UNIQUE_REQUEST_ID\",\n   *   };\n   *   let callbackPromise = promise.then(\n   *      \"_onItemAdded\",\n   *      requestArgs.encode(),\n   *      2,  // Attaching 2 additional requests, in case we need to do another call\n   *   );\n   *   callbackPromise.returnAsResult();\n   * }\n   * ```\n   */\n  returnAsResult(): void {\n    return_promise(this.id);\n  }\n\n  /**\n   * Joins multiple async call promises into one, to aggregate results before the callback.\n   * NOTE: Given promises can only be new async calls and can't be callbacks.\n   * Joined promise can't be returned as a result\n   * @param promises List of async call promises to join.\n   */\n  static all(promises: ContractPromise[]): ContractPromise {\n    assert(promises.length > 0);\n    let id = promises[0].id;\n    for (let i = 1; i < promises.length; i++) {\n      id = promise_and(id, promises[i].id);\n    }\n    return { id };\n  }\n\n  /**\n   * Method to receive async (one or multiple) results from the remote contract in the callback.\n   * Example of using it.\n   * ```\n   * // This function is prefixed with `_`, so other contracts or people can't call it directly.\n   * export function _onItemAdded(itemAddedRequestId: string): bool {\n   *   // Get all results\n   *   let results = ContractPromise.getResults();\n   *   let addItemResult = results[0];\n   *   // Verifying the remote contract call succeeded.\n   *   if (addItemResult.success) {\n   *     // Decoding data from the bytes buffer into the local object.\n   *     let data = AddItemResult.decode(addItemResult.buffer);\n   *     if (data.itemPower > 9000) {\n   *       return true;\n   *     }\n   *   }\n   *   return false;\n   * }\n   * ```\n   * @returns An array of results based on the number of promises the callback was created on.\n   *     If the callback using `then` was scheduled only on one result, then one result will be returned.\n   */\n  static getResults() : ContractPromiseResult[] {\n    let count = <i32>result_count();\n    let results = new Array<ContractPromiseResult>(count);\n    for (let i = 0; i < count; i++) {\n      let isOk = result_is_ok(i);\n      if (!isOk) {\n        results[i] = { success: false }\n        continue;\n      }\n      let buffer = storage._internalReadBytes(DATA_TYPE_RESULT, 0, i);\n      results[i] = { success: isOk, buffer: buffer };\n    }\n    return results;\n  }\n}\n\n/**\n * Class to store results of the async calls on the remote contracts.\n */\nexport class ContractPromiseResult {\n  // Whether the execution of the remote call succeeded.\n  success: bool;\n  // Bytes data returned by the remote contract. Can be empty or null, if the remote\n  // method returns `void`.\n  buffer: Uint8Array;\n}\n\n@external(\"env\", \"storage_write\")\ndeclare function storage_write(key_len: usize, key_ptr: usize, value_len: usize, value_ptr: usize): void;\n@external(\"env\", \"storage_remove\")\ndeclare function storage_remove(key_len: usize, key_ptr: usize): void;\n@external(\"env\", \"storage_has_key\")\ndeclare function storage_has_key(key_len: usize, key_ptr: usize): bool;\n@external(\"env\", \"storage_iter\")\ndeclare function storage_iter(prefix_len: usize, prefix_ptr: usize): u32;\n@external(\"env\", \"storage_range\")\ndeclare function storage_range(start_len: usize, start_ptr: usize, end_len: usize, end_ptr: usize): u32;\n@external(\"env\", \"storage_iter_next\")\ndeclare function storage_iter_next(id: u32): u32;\n\n@external(\"env\", \"result_count\")\ndeclare function result_count(): u32;\n@external(\"env\", \"result_is_ok\")\ndeclare function result_is_ok(index: u32): bool;\n\n@external(\"env\", \"return_value\")\ndeclare function return_value(value_len: usize, value_ptr: usize): void;\n@external(\"env\", \"return_promise\")\ndeclare function return_promise(promise_index: u32): void;\n\n@external(\"env\", \"data_read\")\ndeclare function data_read(type_index: u32, key_len: usize, key: usize, max_buf_len: usize, buf_ptr: usize): usize;\n\n@external(\"env\", \"promise_create\")\ndeclare function promise_create(\n    account_id_len: usize, account_id_ptr: usize,\n    method_name_len: usize, method_name_ptr: usize,\n    args_len: usize, args_ptr: usize,\n    amount: u64): u32;\n\n@external(\"env\", \"promise_then\")\ndeclare function promise_then(\n    promise_index: u32,\n    method_name_len: usize, method_name_ptr: usize,\n    args_len: usize, args_ptr: usize,\n    amount: u64): u32;\n\n@external(\"env\", \"promise_and\")\ndeclare function promise_and(promise_index1: u32, promise_index2: u32): u32;\n\n/**\n * @hidden\n * Hash buffer is 32 bytes\n */\n@external(\"env\", \"hash\")\ndeclare function _near_hash(value_len: usize, value_ptr: usize, buf_ptr: usize): void;\n\n/**\n * @hidden\n */\n@external(\"env\", \"hash32\")\ndeclare function _near_hash32(value_len: usize, value_ptr: usize): u32;\n\n/**\n * @hidden\n * Fills given buffer with random u8.\n */\n@external(\"env\", \"random_buf\")\ndeclare function _near_random_buf(buf_len: u32, buf_ptr: usize): void\n\n/**\n * @hidden\n */\n@external(\"env\", \"random32\")\ndeclare function random32(): u32;\n\n/**\n * @hidden\n */\n@external(\"env\", \"log\")\ndeclare function _near_log(msg_ptr: usize): void;\n\n/**\n * @hidden\n */\n@external(\"env\", \"frozen_balance\")\ndeclare function frozen_balance(): u64;\n\n/**\n * @hidden\n */\n@external(\"env\", \"liquid_balance\")\ndeclare function liquid_balance(): u64;\n\n/**\n * @hidden\n */\n@external(\"env\", \"storage_usage\")\ndeclare function storage_usage(): u64;\n\n/**\n * @hidden\n */\n@external(\"env\", \"deposit\")\ndeclare function deposit(min_amount: u64, max_amount: u64): u64;\n\n/**\n * @hidden\n */\n@external(\"env\", \"withdraw\")\ndeclare function withdraw(min_amount: u64, max_amount: u64): u64;\n\n/**\n * @hidden\n */\n@external(\"env\", \"received_amount\")\ndeclare function received_amount(): u64;\n\n/**\n * @hidden\n */\n@external(\"env\", \"block_index\")\ndeclare function block_index(): u64;\n\n// adapted from https://gist.github.com/Juszczak/63e6d9e01decc850de03\n/**\n * base64 encoding/decoding\n */\nexport namespace base64 {\n  const PADCHAR: string = '=';\n  const ALPHA: string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n  function getByte64(s: string, i: u32): u32 {\n    return this.ALPHA.indexOf(s.charAt(i));\n  }\n\n  /**\n   * Decode base64-encoded string and return a Uint8Array.\n   * @param s Base64 encoded string.\n   */\n  export function decode (s: string): Uint8Array {\n    let i: u32, b10: u32;\n    let pads = 0,\n        imax = s.length as u32;\n\n    if (imax == 0) {\n      return new Uint8Array(0);\n    }\n\n    if (s.charAt(imax - 1) == this.PADCHAR) {\n      pads = 1;\n      if (s.charAt(imax - 2) == this.PADCHAR) {\n        pads = 2;\n      }\n      imax -= 4;\n    }\n\n    let main_chunk = imax % 4 == 0 ? imax / 4 * 3 : (imax / 4 + 1) * 3;\n    let pad_size = pads > 0 ? 3 - pads : 0;\n    let size = main_chunk + pad_size;\n\n    let x = new Uint8Array(size),\n        index = 0;\n\n    for (i = 0; i < imax; i += 4) {\n      b10 = (this.getByte64(s, i) << 18) | (this.getByte64(s, i + 1) << 12) | (this.getByte64(s, i + 2) << 6) | this.getByte64(s, i + 3);\n      x[index++] = b10 >> 16;\n      x[index++] = (b10 >> 8) & 255;\n      x[index++] = b10 & 255;\n    }\n    switch (pads) {\n      case 1:\n        b10 = (this.getByte64(s, i) << 18) | (this.getByte64(s, i + 1) << 12) | (this.getByte64(s, i + 2) << 6);\n        x[index++] = b10 >> 16;\n        x[index++] = (b10 >> 8) & 255;\n        break;\n      case 2:\n        b10 = (this.getByte64(s, i) << 18) | (this.getByte64(s, i + 1) << 12);\n        x[index++] = b10 >> 16;\n        break;\n    }\n\n    return x;\n  }\n\n  /**\n   * Encode Uint8Array in base64.\n   * @param bytes Byte array of type Uint8Array.\n   */\n  export function encode(bytes: Uint8Array): string {\n    let i: i32, b10: u32;\n    let x = new Array<string>(),\n        imax = bytes.length - bytes.length % 3;\n\n    if (bytes.length == 0) {\n      return \"\";\n    }\n\n    for (i = 0; i < imax; i += 3) {\n      b10 = (bytes[i] as u32 << 16) | (bytes[i+1] as u32 << 8) | bytes[i+2] as u32;\n      x.push(this.ALPHA.charAt(b10 >> 18));\n      x.push(this.ALPHA.charAt((b10 >> 12) & 63));\n      x.push(this.ALPHA.charAt((b10 >> 6) & 63));\n      x.push(this.ALPHA.charAt(b10 & 63));\n    }\n\n    switch (bytes.length - imax) {\n      case 1:\n        b10 = bytes[i] as u32 << 16;\n        x.push(this.ALPHA.charAt(b10 >> 18));\n        x.push(this.ALPHA.charAt((b10 >> 12) & 63));\n        x.push(this.PADCHAR);\n        x.push(this.PADCHAR);\n        break;\n      case 2:\n        b10 = (bytes[i] as u32 << 16) | (bytes[i+1] as u32 << 8);\n        x.push(this.ALPHA.charAt(b10 >> 18));\n        x.push(this.ALPHA.charAt((b10 >> 12) & 63));\n        x.push(this.ALPHA.charAt((b10 >> 6) & 63));\n        x.push(this.PADCHAR);\n        break;\n    }\n\n    return x.join('');\n  }\n}\n","import { memcmp, memmove, memset } from \"./internal/memory\";\n\n@builtin export declare const HEAP_BASE: usize; // tslint:disable-line\n\n/* tslint:disable */\n\nexport namespace memory {\n\n  @builtin export declare function size(): i32;\n\n  @builtin export declare function grow(pages: i32): i32;\n\n  @builtin @inline\n  export function fill(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n    memset(dest, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  @builtin @inline\n  export function copy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n    memmove(dest, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  @inline export function compare(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\n    return memcmp(vl, vr, n);\n  }\n\n  // Passive segments\n\n  // export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n  //   __memory_init(segmentIndex, srcOffset, dstOffset);\n  // }\n\n  // export function drop(segmentIndex: u32): void {\n  //   __memory_drop(segmentIndex);\n  // }\n\n  // Allocator\n\n  @inline export function allocate(size: usize): usize {\n    if (isDefined(__memory_allocate)) return __memory_allocate(size);\n    WARNING(\"Calling 'memory.allocate' requires a memory manager to be present.\");\n    return <usize>unreachable();\n  }\n\n  @inline export function free(ptr: usize): void {\n    if (isDefined(__memory_free)) { __memory_free(ptr); return; }\n    WARNING(\"Calling 'memory.free' requires a memory manager to be present.\");\n    unreachable();\n  }\n\n  @inline export function reset(): void {\n    if (isDefined(__memory_reset)) { __memory_reset(); return; }\n    unreachable();\n  }\n}\n","/** Number of alignment bits. */\n@inline export const AL_BITS: u32 = 3;\n/** Number of possible alignment values. */\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n/** Mask to obtain just the alignment bits. */\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n/** Maximum 32-bit allocation size. */\n@inline export const MAX_SIZE_32: usize = 1 << 30; // 1GB\n","/**\n * Arena Memory Allocator\n *\n * Provides a `memory.reset` function to reset the heap to its initial state. A user has to make\n * sure that there are no more references to cleared memory afterwards. Always aligns to 8 bytes.\n *\n * @module std/assembly/allocator/arena\n *//***/\n\nimport { AL_MASK, MAX_SIZE_32 } from \"../internal/allocator\";\n\nvar startOffset: usize = (HEAP_BASE + AL_MASK) & ~AL_MASK;\nvar offset: usize = startOffset;\n\n// Memory allocator interface\n\n@global export function __memory_allocate(size: usize): usize {\n  if (size > MAX_SIZE_32) unreachable();\n  var ptr = offset;\n  var newPtr = (ptr + max<usize>(size, 1) + AL_MASK) & ~AL_MASK;\n  var pagesBefore = memory.size();\n  if (newPtr > <usize>pagesBefore << 16) {\n    let pagesNeeded = ((newPtr - ptr + 0xffff) & ~0xffff) >>> 16;\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n    if (memory.grow(pagesWanted) < 0) {\n      if (memory.grow(pagesNeeded) < 0) {\n        unreachable(); // out of memory\n      }\n    }\n  }\n  offset = newPtr;\n  return ptr;\n}\n\n@global export function __memory_free(ptr: usize): void { /* nop */ }\n\n@global export function __memory_reset(): void {\n  offset = startOffset;\n}\n","import {\n  AL_MASK,\n  MAX_SIZE_32\n } from \"./allocator\";\n\n/** Size of an ArrayBuffer header. */\n@inline export const HEADER_SIZE: usize = (offsetof<ArrayBuffer>() + AL_MASK) & ~AL_MASK;\n/** Maximum byte length of an ArrayBuffer. */\n@inline export const MAX_BLENGTH: i32 = <i32>MAX_SIZE_32 - HEADER_SIZE;\n\nfunction computeSize(byteLength: i32): usize {\n  // round up to power of 2, with HEADER_SIZE=8:\n  // 0            -> 2^3  = 8\n  // 1..8         -> 2^4  = 16\n  // 9..24        -> 2^5  = 32\n  // ...\n  // MAX_LENGTH   -> 2^30 = 0x40000000 (MAX_SIZE_32)\n  return <usize>1 << <usize>(<u32>32 - clz<u32>(byteLength + HEADER_SIZE - 1));\n}\n\n// Low-level utility\n\nfunction __gc(ref: usize): void {}\n\nexport function allocateUnsafe(byteLength: i32): ArrayBuffer {\n  assert(<u32>byteLength <= <u32>MAX_BLENGTH);\n  var buffer: usize;\n  if (isManaged<ArrayBuffer>()) {\n    buffer = __gc_allocate(computeSize(byteLength), __gc); // tslint:disable-line\n  } else {\n    buffer = memory.allocate(computeSize(byteLength));\n  }\n  store<i32>(buffer, byteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n  return changetype<ArrayBuffer>(buffer);\n}\n\nexport function reallocateUnsafe(buffer: ArrayBuffer, newByteLength: i32): ArrayBuffer {\n  var oldByteLength = buffer.byteLength;\n  if (newByteLength > oldByteLength) {\n    assert(newByteLength <= MAX_BLENGTH);\n    if (newByteLength <= <i32>(computeSize(oldByteLength) - HEADER_SIZE)) { // fast path: zero out additional space\n      store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n    } else { // slow path: copy to new buffer\n      let newBuffer = allocateUnsafe(newByteLength);\n      memory.copy(\n        changetype<usize>(newBuffer) + HEADER_SIZE,\n        changetype<usize>(buffer) + HEADER_SIZE,\n        <usize>oldByteLength\n      );\n      if (!isManaged<ArrayBuffer>()) {\n        memory.free(changetype<usize>(buffer));\n      }\n      buffer = newBuffer;\n    }\n    memory.fill(\n      changetype<usize>(buffer) + HEADER_SIZE + <usize>oldByteLength,\n      0,\n      <usize>(newByteLength - oldByteLength)\n    );\n  } else if (newByteLength < oldByteLength) { // fast path: override size\n    // TBD: worth to copy and release if size is significantly less than before?\n    assert(newByteLength >= 0);\n    store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n  }\n  return buffer;\n}\n\n// The helpers below use two different types in order to emit loads and stores that load respectively\n// store one type to/from memory while returning/taking the desired output/input type. This allows to\n// emit instructions like\n//\n// * `i32.load8` ^= `<i32>load<i8>(...)` that reads an i8 but returns an i32, or\n// * `i64.load32_s` ^= `<i64>load<i32>(...)`) that reads a 32-bit as a 64-bit integer\n//\n// without having to emit an additional instruction for conversion purposes. The second parameter\n// can be omitted for references and other loads and stores that simply return the exact type.\n\n@inline export function LOAD<T,TOut = T>(buffer: ArrayBuffer, index: i32, byteOffset: i32 = 0): TOut {\n  return <TOut>load<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, HEADER_SIZE);\n}\n\n@inline export function STORE<T,TIn = T>(buffer: ArrayBuffer, index: i32, value: TIn, byteOffset: i32 = 0): void {\n  store<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, value, HEADER_SIZE);\n}\n","import { MAX_SIZE_32 } from \"./allocator\";\nimport { String } from \"../string\";\n\n/** Size of a String header. */\n@inline export const HEADER_SIZE = (offsetof<String>() + 1) & ~1; // 2 byte aligned\n/** Maximum length of a String. */\n@inline export const MAX_LENGTH = (<i32>MAX_SIZE_32 - HEADER_SIZE) >>> 1;\n\n// Low-level utility\n\nfunction __gc(ref: usize): void {}\n\nexport function allocateUnsafe(length: i32): String {\n  assert(length > 0 && length <= MAX_LENGTH);\n  var buffer: usize;\n  if (isManaged<String>()) {\n    buffer = __gc_allocate(HEADER_SIZE + (<usize>length << 1), __gc);  // tslint:disable-line\n  } else {\n    buffer = memory.allocate(HEADER_SIZE + (<usize>length << 1));\n  }\n  store<i32>(buffer, length);\n  return changetype<String>(buffer);\n}\n\n@inline\nexport function freeUnsafe(buffer: String): void {\n  if (!isManaged<String>()) {\n    assert(buffer);\n    memory.free(changetype<usize>(buffer));\n  }\n}\n\nexport function copyUnsafe(dest: String, destOffset: usize, src: String, srcOffset: usize, len: usize): void {\n  memory.copy(\n    changetype<usize>(dest) + (destOffset << 1) + HEADER_SIZE,\n    changetype<usize>(src)  + (srcOffset  << 1) + HEADER_SIZE,\n    len << 1\n  );\n}\n\nexport function compareUnsafe(str1: String, offset1: usize, str2: String, offset2: usize, len: usize): i32 {\n  var cmp: i32 = 0;\n  var ptr1 = changetype<usize>(str1) + (offset1 << 1);\n  var ptr2 = changetype<usize>(str2) + (offset2 << 1);\n  while (len && !(cmp = <i32>load<u16>(ptr1, HEADER_SIZE) - <i32>load<u16>(ptr2, HEADER_SIZE))) {\n    --len, ptr1 += 2, ptr2 += 2;\n  }\n  return cmp;\n}\n\nexport function repeatUnsafe(dest: String, destOffset: usize, src: String, count: i32): void {\n  var length = src.length;\n  if (ASC_SHRINK_LEVEL > 1) {\n    let strLen = length << 1;\n    let to   = changetype<usize>(dest) + HEADER_SIZE + (destOffset << 1);\n    let from = changetype<usize>(src)  + HEADER_SIZE;\n    for (let i = 0, len = strLen * count; i < len; i += strLen) {\n      memory.copy(to + i, from, strLen);\n    }\n  } else {\n    switch (length) {\n      case 0: break;\n      case 1: {\n        let cc =  load<u16>(changetype<usize>(src), HEADER_SIZE);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u16>(out + (i << 1), cc, HEADER_SIZE);\n        }\n        break;\n      }\n      case 2: {\n        let cc  = load<u32>(changetype<usize>(src), HEADER_SIZE);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u32>(out + (i << 2), cc, HEADER_SIZE);\n        }\n        break;\n      }\n      case 3: {\n        let cc1 = load<u32>(changetype<usize>(src), HEADER_SIZE + 0);\n        let cc2 = load<u16>(changetype<usize>(src), HEADER_SIZE + 4);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u32>(out + (i << 2), cc1, HEADER_SIZE + 0);\n          store<u16>(out + (i << 1), cc2, HEADER_SIZE + 4);\n        }\n        break;\n      }\n      case 4: {\n        let cc = load<u64>(changetype<usize>(src), HEADER_SIZE);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u64>(out + (i << 3), cc, HEADER_SIZE);\n        }\n        break;\n      }\n      default: {\n        let strLen = length << 1;\n        let to   = changetype<usize>(dest) + HEADER_SIZE + (destOffset << 1);\n        let from = changetype<usize>(src)  + HEADER_SIZE;\n        for (let i = 0, len = strLen * count; i < len; i += strLen) {\n          memory.copy(to + i, from, strLen);\n        }\n        break;\n      }\n    }\n  }\n}\n\n// Helpers\n\n@inline export const enum CharCode {\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5a,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  x = 0x78,\n  z = 0x7A\n}\n\nexport function isWhiteSpaceOrLineTerminator(c: u16): bool {\n  switch (c) {\n    case 9:    // <TAB>\n    case 10:   // <LF>\n    case 13:   // <CR>\n    case 11:   // <VT>\n    case 12:   // <FF>\n    case 32:   // <SP>\n    case 160:  // <NBSP>\n    case 8232: // <LS>\n    case 8233: // <PS>\n    case 65279: return true; // <ZWNBSP>\n    default: return false;\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function parse<T>(str: String, radix: i32 = 0): T {\n  var len: i32 = str.length;\n  if (!len) return <T>NaN;\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\n\n  // determine sign\n  var sign: T;\n  if (code == CharCode.MINUS) {\n    if (!--len) return <T>NaN;\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return <T>NaN;\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = 1;\n  } else {\n    sign = 1;\n  }\n\n  // determine radix\n  if (!radix) {\n    if (code == CharCode._0 && len > 2) {\n      switch (<i32>load<u16>(ptr + 2, HEADER_SIZE)) {\n        case CharCode.B:\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.O:\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.X:\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n        default: radix = 10;\n      }\n    } else radix = 10;\n  } else if (radix < 2 || radix > 36) {\n    return <T>NaN;\n  }\n\n  // calculate value\n  var num: T = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\n    if (code >= CharCode._0 && code <= CharCode._9) {\n      code -= CharCode._0;\n    } else if (code >= CharCode.A && code <= CharCode.Z) {\n      code -= CharCode.A - 10;\n    } else if (code >= CharCode.a && code <= CharCode.z) {\n      code -= CharCode.a - 10;\n    } else break;\n    if (code >= radix) break;\n    num = (num * radix) + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n","import {\n  HEADER_SIZE as AB_HEADER_SIZE,\n  MAX_BLENGTH as AB_MAX_BLENGTH,\n  allocateUnsafe,\n  LOAD,\n  STORE\n} from \"./arraybuffer\";\n\nimport {\n  SORT as SORT_IMPL\n} from \"./sort\";\n\n/** Typed array base class. Not a global object. */\nexport abstract class TypedArray<T> {\n  [key: number]: T; // compatibility only\n\n  readonly buffer: ArrayBuffer;\n  readonly byteOffset: i32;\n  readonly byteLength: i32;\n\n  constructor(length: i32) {\n    const MAX_LENGTH = <u32>AB_MAX_BLENGTH / sizeof<T>();\n    if (<u32>length > MAX_LENGTH) throw new RangeError(\"Invalid typed array length\");\n    var byteLength = length << alignof<T>();\n    var buffer = allocateUnsafe(byteLength);\n    memory.fill(changetype<usize>(buffer) + AB_HEADER_SIZE, 0, <usize>byteLength);\n    this.buffer = buffer;\n    this.byteOffset = 0;\n    this.byteLength = byteLength;\n  }\n\n  @inline\n  get length(): i32 {\n    return this.byteLength >>> alignof<T>();\n  }\n\n  @operator(\"[]\")\n  protected __get(index: i32): T {\n    if (<u32>index >= <u32>(this.byteLength >>> alignof<T>())) throw new Error(\"Index out of bounds\");\n    return LOAD<T>(this.buffer, index, this.byteOffset);\n  }\n\n  @inline @operator(\"{}\")\n  protected __unchecked_get(index: i32): T {\n    return LOAD<T>(this.buffer, index, this.byteOffset);\n  }\n\n  @operator(\"[]=\")\n  protected __set(index: i32, value: native<T>): void {\n    if (<u32>index >= <u32>(this.byteLength >>> alignof<T>())) throw new Error(\"Index out of bounds\");\n    STORE<T,native<T>>(this.buffer, index, value, this.byteOffset);\n  }\n\n  @inline @operator(\"{}=\")\n  protected __unchecked_set(index: i32, value: native<T>): void {\n    STORE<T,native<T>>(this.buffer, index, value, this.byteOffset);\n  }\n\n  // copyWithin(target: i32, start: i32, end: i32 = this.length): this\n}\n\n@inline\nexport function FILL<TArray extends TypedArray<T>, T extends number>(\n  array: TArray,\n  value: native<T>,\n  start: i32,\n  end: i32\n): TArray {\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  var len = array.length;\n  start = start < 0 ? max(len + start, 0) : min(start, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  if (sizeof<T>() == 1) {\n    if (start < end) {\n      memory.fill(\n        changetype<usize>(buffer) + start + byteOffset + AB_HEADER_SIZE,\n        <u8>value,\n        <usize>(end - start)\n      );\n    }\n  } else {\n    for (; start < end; ++start) {\n      STORE<T,native<T>>(buffer, start, value, byteOffset);\n    }\n  }\n  return array;\n}\n\n@inline\nexport function SORT<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  comparator: (a: T, b: T) => i32\n): TArray {\n  var byteOffset = array.byteOffset;\n  var length = array.length;\n  if (length <= 1) return array;\n  var buffer = array.buffer;\n  if (length == 2) {\n    let a = LOAD<T>(buffer, 1, byteOffset);\n    let b = LOAD<T>(buffer, 0, byteOffset);\n    if (comparator(a, b) < 0) {\n      STORE<T>(buffer, 1, b, byteOffset);\n      STORE<T>(buffer, 0, a, byteOffset);\n    }\n    return array;\n  }\n  SORT_IMPL<T>(buffer, byteOffset, length, comparator);\n  return array;\n}\n\n@inline\nexport function SUBARRAY<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  var length = <i32>array.length;\n  if (begin < 0) begin = max(length + begin, 0);\n  else begin = min(begin, length);\n  if (end < 0) end = max(length + end, begin);\n  else end = max(min(end, length), begin);\n  var slice = memory.allocate(offsetof<TArray>());\n  store<usize>(slice, array.buffer, offsetof<TArray>(\"buffer\"));\n  store<i32>(slice, <i32>array.byteOffset + (begin << alignof<T>()), offsetof<TArray>(\"byteOffset\"));\n  store<i32>(slice, (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\n  return changetype<TArray>(slice);\n}\n\n@inline\nexport function REDUCE<TArray extends TypedArray<T>, T, TRet>(\n  array: TArray,\n  callbackfn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    initialValue = callbackfn(\n      initialValue,\n      LOAD<T>(buffer, i, byteOffset),\n      i,\n      array,\n    );\n  }\n  return initialValue;\n}\n\n@inline\nexport function REDUCE_RIGHT<TArray extends TypedArray<T>, T, TRet>(\n  array: TArray,\n  callbackfn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = callbackfn(\n      initialValue,\n      LOAD<T>(buffer, i, byteOffset),\n      i,\n      array,\n    );\n  }\n  return initialValue;\n}\n\n@inline\nexport function MAP<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  var result = instantiate<TArray>(length);\n  var resultBuffer = result.buffer;\n  for (let i = 0; i < length; i++) {\n    STORE<T, native<T>>(resultBuffer, i, <native<T>>callbackfn(LOAD<T>(buffer, i, byteOffset), i, array));\n  }\n\n  return result;\n}\n\n@inline\nexport function FIND_INDEX<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n@inline\nexport function SOME<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n@inline\nexport function EVERY<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n\n@inline\nexport function FOREACH<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, array: TArray) => void,\n): void {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    callbackfn(LOAD<T>(buffer, i, byteOffset), i, array);\n  }\n}\n\n@inline\nexport function REVERSE<TArray extends TypedArray<T>, T>(array: TArray): TArray {\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n\n  for (let front = 0, back = array.length - 1; front < back; ++front, --back) {\n    let temp = LOAD<T>(buffer, front, byteOffset);\n    STORE<T>(buffer, front, LOAD<T>(buffer, back, byteOffset), byteOffset);\n    STORE<T>(buffer, back, temp, byteOffset);\n  }\n  return array;\n}\n","// this function will go away once `memory.copy` becomes an intrinsic\nexport function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// this function will go away once `memory.copy` becomes an intrinsic\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (src + n <= dest || dest + n <= src) {\n    memcpy(dest, src, n);\n    return;\n  }\n  if (dest < src) {\n    if ((src & 7) == (dest & 7)) {\n      while (dest & 7) {\n        if (!n) return;\n        --n;\n        store<u8>(dest++, load<u8>(src++));\n      }\n      while (n >= 8) {\n        store<u64>(dest, load<u64>(src));\n        n    -= 8;\n        dest += 8;\n        src  += 8;\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if ((src & 7) == (dest & 7)) {\n      while ((dest + n) & 7) {\n        if (!n) return;\n        store<u8>(dest + --n, load<u8>(src + n));\n      }\n      while (n >= 8) {\n        n -= 8;\n        store<u64>(dest + n, load<u64>(src + n));\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// this function will go away once `memory.fill` becomes an intrinsic\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n\n  // fill head and tail with minimal branching\n  if (!n) return;\n  store<u8>(dest, c);\n  store<u8>(dest + n - 1, c);\n  if (n <= 2) return;\n\n  store<u8>(dest + 1, c);\n  store<u8>(dest + 2, c);\n  store<u8>(dest + n - 2, c);\n  store<u8>(dest + n - 3, c);\n  if (n <= 6) return;\n  store<u8>(dest + 3, c);\n  store<u8>(dest + n - 4, c);\n  if (n <= 8) return;\n\n  // advance pointer to align it at 4-byte boundary\n  var k: usize = -dest & 3;\n  dest += k;\n  n -= k;\n  n &= -4;\n\n  var c32: u32 = <u32>-1 / 255 * c;\n\n  // fill head/tail up to 28 bytes each in preparation\n  store<u32>(dest, c32);\n  store<u32>(dest + n - 4, c32);\n  if (n <= 8) return;\n  store<u32>(dest + 4, c32);\n  store<u32>(dest + 8, c32);\n  store<u32>(dest + n - 12, c32);\n  store<u32>(dest + n - 8, c32);\n  if (n <= 24) return;\n  store<u32>(dest + 12, c32);\n  store<u32>(dest + 16, c32);\n  store<u32>(dest + 20, c32);\n  store<u32>(dest + 24, c32);\n  store<u32>(dest + n - 28, c32);\n  store<u32>(dest + n - 24, c32);\n  store<u32>(dest + n - 20, c32);\n  store<u32>(dest + n - 16, c32);\n\n  // align to a multiple of 8\n  k = 24 + (dest & 4);\n  dest += k;\n  n -= k;\n\n  // copy 32 bytes each\n  var c64: u64 = <u64>c32 | (<u64>c32 << 32);\n  while (n >= 32) {\n    store<u64>(dest, c64);\n    store<u64>(dest + 8, c64);\n    store<u64>(dest + 16, c64);\n    store<u64>(dest + 24, c64);\n    n -= 32;\n    dest += 32;\n  }\n}\n\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\n  if (vl == vr) return 0;\n  while (n != 0 && load<u8>(vl) == load<u8>(vr)) {\n    n--; vl++; vr++;\n  }\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\n}\n","declare function logStr(str: string): void;\ndeclare function logF64(val: f64): void;\n\n/**\n * Extend from this class to handle events from parser.\n * Default implementation traverses whole object tree and does nothing.\n */\nexport abstract class JSONHandler {\n    setString(name: string, value: string): void {\n    }\n\n    setBoolean(name: string, value: bool): void {\n    }\n\n    setNull(name: string): void {\n    }\n\n    setInteger(name: string, value: i64): void {\n    }\n\n    pushArray(name: string): bool {\n        return true;\n    }\n\n    popArray(): void {\n    }\n\n    pushObject(name: string): bool {\n        return true;\n    }\n\n    popObject(): void {\n    }\n}\n\n/**\n * Extend from this class to handle events from parser.\n * This implementation crashes on every unimplemented set/push method\n * to allow easier validation of input.\n */\nexport class ThrowingJSONHandler extends JSONHandler {\n    setString(name: string, value: string): void {\n       assert(false, 'Unexpected string field ' + name + ' : \"' + value + '\"');\n    }\n\n    setBoolean(name: string, value: bool): void {\n       assert(false, 'Unexpected bool field ' + name + ' : ' + (value ? 'true' : 'false'));\n    }\n\n    setNull(name: string): void {\n       assert(false, 'Unexpected null field ' + name);\n    }\n\n    setInteger(name: string, value: i64): void {\n       assert(false, 'Unexpected integer field ' + name + ' : ' + value.toString());\n    }\n\n    pushArray(name: string): bool {\n        assert(false, 'Unexpected array field ' + name);\n        return true;\n    }\n\n    pushObject(name: string): bool {\n        assert(false, 'Unexpected object field ' + name);\n        return true;\n    }\n}\n\nconst TRUE_STR = \"true\";\nconst FALSE_STR = \"false\";\nconst NULL_STR = \"null\";\nlet CHAR_0 = \"0\".charCodeAt(0);\nlet CHAR_9 = \"9\".charCodeAt(0);\nlet CHAR_A = \"A\".charCodeAt(0);\nlet CHAR_A_LOWER = \"a\".charCodeAt(0);\n\nexport class DecoderState {\n    readIndex: i32 = 0;\n    buffer: Uint8Array = null;\n    lastKey: string = null;\n}\n\nexport class JSONDecoder<JSONHandlerT extends JSONHandler> {\n\n    handler: JSONHandlerT;\n    state: DecoderState;\n\n    constructor(handler: JSONHandlerT) {\n        this.handler = handler;\n    }\n\n    deserialize(buffer: Uint8Array, decoderState: DecoderState = null): void {\n        if (decoderState) {\n            this.state = decoderState;\n        } else {\n            this.state = new DecoderState();\n            this.state.readIndex = 0;\n            this.state.buffer = buffer;\n            this.state.lastKey = null;\n        }\n\n        assert(this.parseValue(), \"Cannot parse JSON\");\n        // TODO: Error if input left\n    }\n\n    private peekChar(): i32 {\n        if (this.state.readIndex >= this.state.buffer.length) {\n          return -1;\n        }\n        return this.state.buffer[this.state.readIndex];\n    }\n\n    private readChar(): i32 {\n        assert(this.state.readIndex < this.state.buffer.length, \"Unexpected input end\");\n        return this.state.buffer[this.state.readIndex++];\n    }\n\n    private parseValue(): bool {\n        this.skipWhitespace();\n        let result = this.parseObject()\n            || this.parseArray()\n            || this.parseString()\n            || this.parseBoolean()\n            || this.parseNumber()\n            || this.parseNull()\n        this.skipWhitespace();\n        return result;\n    }\n\n    private parseObject(): bool {\n        if (this.peekChar() != \"{\".charCodeAt(0)) {\n            return false;\n        }\n        let key = this.state.lastKey;\n        this.state.lastKey = null;\n        if (this.handler.pushObject(key)) {\n            this.readChar();\n            this.skipWhitespace();\n\n            let firstItem = true;\n            while (this.peekChar() != \"}\".charCodeAt(0)) {\n                if (!firstItem) {\n                    assert(this.readChar() == \",\".charCodeAt(0), \"Expected ','\");\n                } else {\n                    firstItem = false;\n                }\n                this.parseKey();\n                this.parseValue();\n            }\n            assert(this.readChar() == \"}\".charCodeAt(0), \"Unexpected end of object\");\n        }\n        this.handler.popObject();\n        return true;\n    }\n\n    private parseKey(): void {\n        this.skipWhitespace();\n        this.state.lastKey = this.readString();\n        this.skipWhitespace();\n        assert(this.readChar() == \":\".charCodeAt(0), \"Expected ':'\");\n    }\n\n    private parseArray(): bool {\n        if (this.peekChar() != \"[\".charCodeAt(0)) {\n            return false;\n        }\n        let key = this.state.lastKey;\n        this.state.lastKey = null;\n        if (this.handler.pushArray(key)) {\n            this.readChar();\n            this.skipWhitespace();\n\n            let firstItem = true;\n            while (this.peekChar() != \"]\".charCodeAt(0)) {\n                if (!firstItem) {\n                    assert(this.readChar() == \",\".charCodeAt(0), \"Expected ','\");\n                } else {\n                    firstItem = false;\n                }\n                this.parseValue();\n            }\n            assert(this.readChar() == \"]\".charCodeAt(0), \"Unexpected end of array\");\n        }\n        this.handler.popArray();\n        return true;;\n    }\n\n    private parseString(): bool {\n        if (this.peekChar() != '\"'.charCodeAt(0)) {\n            return false;\n        }\n        this.handler.setString(this.state.lastKey, this.readString());\n        return true;\n    }\n\n    private readString(): string {\n        assert(this.readChar() == '\"'.charCodeAt(0), \"Expected double-quoted string\");\n        let savedIndex = this.state.readIndex;\n        let stringParts: Array<string> = null;\n        for (;;) {\n            let byte = this.readChar();\n            assert(byte >= 0x20, \"Unexpected control character\");\n            if (byte == '\"'.charCodeAt(0)) {\n                let s = String.fromUTF8(this.state.buffer.buffer.data + savedIndex, this.state.readIndex - savedIndex - 1);\n                if (stringParts == null) {\n                    return s;\n                }\n                stringParts.push(s);\n                return stringParts.join(\"\");\n            } else if (byte == \"\\\\\".charCodeAt(0)) {\n                if (stringParts == null) {\n                    stringParts = new Array<string>();\n                }\n                if (this.state.readIndex > savedIndex + 1) {\n                    stringParts.push(\n                        String.fromUTF8(this.state.buffer.buffer.data + savedIndex, this.state.readIndex - savedIndex - 1));\n                }\n                stringParts.push(this.readEscapedChar());\n                savedIndex = this.state.readIndex;\n            }\n        }\n        // Should never happen\n        return \"\";\n    }\n\n    private readEscapedChar(): string {\n        let byte = this.readChar();\n        // TODO: Use lookup table for anything except \\u\n        if (byte == '\"'.charCodeAt(0)) {\n            return '\"';\n        }\n        if (byte == \"\\\\\".charCodeAt(0)) {\n            return \"\\\\\";\n        }\n        if (byte == \"/\".charCodeAt(0)) {\n            return \"/\";\n        }\n        if (byte == \"b\".charCodeAt(0)) {\n            return \"\\b\";\n        }\n        if (byte == \"n\".charCodeAt(0)) {\n            return \"\\n\";\n        }\n        if (byte == \"r\".charCodeAt(0)) {\n            return \"\\r\";\n        }\n        if (byte == \"t\".charCodeAt(0)) {\n            return \"\\t\";\n        }\n        if (byte == \"u\".charCodeAt(0)) {\n            let d1 = this.readHexDigit();\n            let d2 = this.readHexDigit();\n            let d3 = this.readHexDigit();\n            let d4 = this.readHexDigit();\n            let charCode = d1 * 0x1000 + d2 * 0x100 + d3 * 0x10 + d4;\n            return String.fromCodePoint(charCode);\n        }\n        assert(false, \"Unexpected escaped character: \" + String.fromCharCode(byte));\n        return \"\";\n    }\n\n    private readHexDigit(): i32 {\n        let byte = this.readChar();\n        let digit = byte - CHAR_0;\n        if (digit > 9) {\n            digit = byte - CHAR_A + 10;\n            if (digit < 10 || digit > 15) {\n                digit = byte - CHAR_A_LOWER + 10;\n            }\n        }\n        let arr: Array<i32> = [byte, digit];\n        assert(digit >= 0 && digit < 16, \"Unexpected \\\\u digit\");\n        return digit;\n    }\n\n    private parseNumber(): bool {\n        // TODO: Parse floats\n        let number: i64 = 0;\n        let sign: i64 = 1;\n        if (this.peekChar() == \"-\".charCodeAt(0)) {\n            sign = -1;\n            this.readChar();\n        }\n        let digits = 0;\n        while (CHAR_0 <= this.peekChar() && this.peekChar() <= CHAR_9 ) {\n            let byte = this.readChar();\n            number *= 10;\n            number += byte - CHAR_0;\n            digits++;\n        }\n        if (digits > 0) {\n            this.handler.setInteger(this.state.lastKey, number * sign);\n            return true;\n        }\n        return false;\n    }\n\n    private parseBoolean(): bool {\n        if (this.peekChar() == FALSE_STR.charCodeAt(0)) {\n            this.readAndAssert(FALSE_STR);\n            this.handler.setBoolean(this.state.lastKey, false);\n            return true;\n        }\n        if (this.peekChar() == TRUE_STR.charCodeAt(0)) {\n            this.readAndAssert(TRUE_STR);\n            this.handler.setBoolean(this.state.lastKey, true);\n            return true;\n        }\n\n        return false;\n    }\n\n    private parseNull(): bool {\n        if (this.peekChar() == NULL_STR.charCodeAt(0)) {\n            this.readAndAssert(NULL_STR);\n            this.handler.setNull(this.state.lastKey);\n            return true;\n        }\n        return false;\n    }\n\n    private readAndAssert(str: string): void {\n        for (let i = 0; i < str.length; i++) {\n            assert(str.charCodeAt(i) == this.readChar(), \"Expected '\" + str + \"'\");\n        }\n    }\n\n    private skipWhitespace(): void {\n        while (this.isWhitespace(this.peekChar())) {\n            this.readChar();\n        }\n    }\n\n    private isWhitespace(charCode: i32): bool {\n        return charCode == 0x9 || charCode == 0xa || charCode == 0xd || charCode == 0x20;\n    }\n}\n","import {\n  HEADER_SIZE,\n  MAX_LENGTH,\n  allocateUnsafe,\n  compareUnsafe,\n  repeatUnsafe,\n  copyUnsafe,\n  isWhiteSpaceOrLineTerminator,\n  CharCode,\n  parse\n} from \"./internal/string\";\n\nimport {\n  STORE\n} from \"./internal/arraybuffer\";\n\n@sealed\nexport class String {\n\n  readonly length: i32; // capped to [0, MAX_LENGTH]\n\n  // TODO Add and handle second argument\n  static fromCharCode(code: i32): String {\n    var out = allocateUnsafe(1);\n    store<u16>(\n      changetype<usize>(out),\n      <u16>code,\n      HEADER_SIZE\n    );\n    return out;\n  }\n\n  static fromCodePoint(code: i32): String {\n    assert(<u32>code <= 0x10FFFF);\n    var sur = code > 0xFFFF;\n    var out = allocateUnsafe(<i32>sur + 1);\n    if (!sur) {\n      store<u16>(\n        changetype<usize>(out),\n        <u16>code,\n        HEADER_SIZE\n      );\n    } else {\n      code -= 0x10000;\n      let hi: u32 = (code >>> 10) + 0xD800;\n      let lo: u32 = (code & 0x3FF) + 0xDC00;\n      store<u32>(\n        changetype<usize>(out),\n        (hi << 16) | lo,\n        HEADER_SIZE\n      );\n    }\n    return out;\n  }\n\n  @operator(\"[]\")\n  charAt(pos: i32): String {\n    assert(this !== null);\n\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n\n    var out = allocateUnsafe(1);\n    store<u16>(\n      changetype<usize>(out),\n      load<u16>(\n        changetype<usize>(this) + (<usize>pos << 1),\n        HEADER_SIZE\n      ),\n      HEADER_SIZE\n    );\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    assert(this !== null);\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n\n    return load<u16>(\n      changetype<usize>(this) + (<usize>pos << 1),\n      HEADER_SIZE\n    );\n  }\n\n  codePointAt(pos: i32): i32 {\n    assert(this !== null);\n    if (<u32>pos >= <u32>this.length) return -1; // (undefined)\n\n    var first = <i32>load<u16>(\n      changetype<usize>(this) + (<usize>pos << 1),\n      HEADER_SIZE\n    );\n    if (first < 0xD800 || first > 0xDBFF || pos + 1 == this.length) {\n      return first;\n    }\n    var second = <i32>load<u16>(\n      changetype<usize>(this) + ((<usize>pos + 1) << 1),\n      HEADER_SIZE\n    );\n    if (second < 0xDC00 || second > 0xDFFF) return first;\n    return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\")\n  private static __concat(left: String, right: String): String {\n    if (!changetype<usize>(left)) left = changetype<String>(\"null\");\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    assert(this !== null);\n    if (other === null) other = changetype<String>(\"null\");\n\n    var thisLen: isize  = this.length;\n    var otherLen: isize = other.length;\n    var outLen: usize   = thisLen + otherLen;\n    if (outLen == 0) return changetype<String>(\"\");\n    var out = allocateUnsafe(outLen);\n    copyUnsafe(out, 0, this, 0, thisLen);\n    copyUnsafe(out, thisLen, other, 0, otherLen);\n    return out;\n  }\n\n  endsWith(searchString: String, endPosition: i32 = MAX_LENGTH): bool {\n    assert(this !== null);\n    if (searchString === null) return false;\n    var end = min(max(endPosition, 0), this.length);\n    var searchLength: isize = searchString.length;\n    var start: isize = end - searchLength;\n    if (start < 0) return false;\n    return !compareUnsafe(this, start, searchString, 0, searchLength);\n  }\n\n  @operator(\"==\")\n  private static __eq(left: String, right: String): bool {\n    if (left === right) return true;\n    if (left === null || right === null) return false;\n\n    var leftLength = left.length;\n    if (leftLength != right.length) return false;\n\n    return !compareUnsafe(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String): bool {\n    return str === null || !str.length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String, right: String): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\")\n  private static __gt(left: String, right: String): bool {\n    if (left === right || left === null || right === null) return false;\n\n    var leftLength  = left.length;\n    var rightLength = right.length;\n\n    if (!leftLength)  return false;\n    if (!rightLength) return true;\n\n    var length = <usize>min<i32>(leftLength, rightLength);\n    return compareUnsafe(left, 0, right, 0, length) > 0;\n  }\n\n  @operator(\">=\")\n  private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\")\n  private static __lt(left: String, right: String): bool {\n    if (left === right || left === null || right === null) return false;\n\n    var leftLength  = left.length;\n    var rightLength = right.length;\n\n    if (!rightLength) return false;\n    if (!leftLength)  return true;\n\n    var length = <usize>min<i32>(leftLength, rightLength);\n    return compareUnsafe(left, 0, right, 0, length) < 0;\n  }\n\n  @operator(\"<=\")\n  private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  @inline\n  includes(searchString: String, position: i32 = 0): bool {\n    return this.indexOf(searchString, position) != -1;\n  }\n\n  indexOf(searchString: String, fromIndex: i32 = 0): i32 {\n    assert(this !== null);\n    if (searchString === null) searchString = changetype<String>(\"null\");\n\n    var searchLen: isize = searchString.length;\n    if (!searchLen) return 0;\n    var len: isize = this.length;\n    if (!len) return -1;\n    var start = min<isize>(max<isize>(fromIndex, 0), len);\n    len -= searchLen;\n    for (let k: isize = start; k <= len; ++k) {\n      if (!compareUnsafe(this, k, searchString, 0, searchLen)) return <i32>k;\n    }\n    return -1;\n  }\n\n  lastIndexOf(searchString: String, fromIndex: i32 = i32.MAX_VALUE): i32 {\n    assert(this !== null);\n    if (searchString === null) searchString = changetype<String>(\"null\");\n\n    var len: isize = this.length;\n    var searchLen: isize = searchString.length;\n    if (!searchLen) return len;\n    if (!len) return -1;\n    var start = min<isize>(max(fromIndex, 0), len - searchLen);\n    for (let k = start; k >= 0; --k) {\n      if (!compareUnsafe(this, k, searchString, 0, searchLen)) return <i32>k;\n    }\n    return -1;\n  }\n\n  startsWith(searchString: String, position: i32 = 0): bool {\n    assert(this !== null);\n    if (searchString === null) searchString = changetype<String>(\"null\");\n\n    var pos: isize = position;\n    var len: isize = this.length;\n    var start = min(max(pos, 0), len);\n    var searchLength: isize = searchString.length;\n    if (searchLength + start > len) return false;\n    return !compareUnsafe(this, start, searchString, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String {\n    assert(this !== null);\n    var intStart: isize = start;\n    var end: isize = length;\n    var size: isize = this.length;\n    if (intStart < 0) intStart = max(size + intStart, 0);\n    var resultLength = min(max(end, 0), size - intStart);\n    if (resultLength <= 0) return changetype<String>(\"\");\n    var out = allocateUnsafe(resultLength);\n    copyUnsafe(out, 0, this, intStart, resultLength);\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    assert(this !== null);\n    var len = this.length;\n    var finalStart = min(max(start, 0), len);\n    var finalEnd = min(max(end, 0), len);\n    var from = min<i32>(finalStart, finalEnd);\n    var to = max<i32>(finalStart, finalEnd);\n    len = to - from;\n    if (!len) return changetype<String>(\"\");\n    if (!from && to == this.length) return this;\n    var out = allocateUnsafe(len);\n    copyUnsafe(out, 0, this, from, len);\n    return out;\n  }\n\n  trim(): String {\n    assert(this !== null);\n    var length: usize = this.length;\n\n    while (\n      length &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (length << 1), HEADER_SIZE)\n      )\n    ) {\n      --length;\n    }\n    var start: usize = 0;\n    while (\n      start < length &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (start << 1), HEADER_SIZE)\n      )\n    ) {\n      ++start, --length;\n    }\n    if (!length) return changetype<String>(\"\");\n    if (!start && length == this.length) return this;\n    var out = allocateUnsafe(length);\n    copyUnsafe(out, 0, this, start, length);\n    return out;\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    assert(this !== null);\n    var start: isize = 0;\n    var len: isize = this.length;\n    while (\n      start < len &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (start << 1), HEADER_SIZE)\n      )\n    ) {\n      ++start;\n    }\n    if (!start) return this;\n    var outLen = len - start;\n    if (!outLen) return changetype<String>(\"\");\n    var out = allocateUnsafe(outLen);\n    copyUnsafe(out, 0, this, start, outLen);\n    return out;\n  }\n\n  trimEnd(): String {\n    assert(this !== null);\n    var len: isize = this.length;\n    while (\n      len > 0 &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (len << 1), HEADER_SIZE)\n      )\n    ) {\n      --len;\n    }\n    if (len <= 0) return changetype<String>(\"\");\n    if (<i32>len == this.length) return this;\n    var out = allocateUnsafe(len);\n    copyUnsafe(out, 0, this, 0, len);\n    return out;\n  }\n\n  padStart(targetLength: i32, padString: String = changetype<String>(\" \")): String {\n    assert(this !== null);\n    var length = this.length;\n    var padLen = padString.length;\n    if (targetLength < length || !padLen) return this;\n    var len = targetLength - length;\n    var out = allocateUnsafe(targetLength);\n    if (len > padLen) {\n      let count = (len - 1) / padLen;\n      let base = count * padLen;\n      let rest = len - base;\n      repeatUnsafe(out, 0, padString, count);\n      if (rest) copyUnsafe(out, base, padString, 0, rest);\n    } else {\n      copyUnsafe(out, 0, padString, 0, len);\n    }\n    if (length) copyUnsafe(out, len, this, 0, length);\n    return out;\n  }\n\n  padEnd(targetLength: i32, padString: String = changetype<String>(\" \")): String {\n    assert(this !== null);\n    var length = this.length;\n    var padLen = padString.length;\n    if (targetLength < length || !padLen) return this;\n    var len = targetLength - length;\n    var out = allocateUnsafe(targetLength);\n    if (length) copyUnsafe(out, 0, this, 0, length);\n    if (len > padLen) {\n      let count = (len - 1) / padLen;\n      let base = count * padLen;\n      let rest = len - base;\n      repeatUnsafe(out, length, padString, count);\n      if (rest) copyUnsafe(out, base + length, padString, 0, rest);\n    } else {\n      copyUnsafe(out, length, padString, 0, len);\n    }\n    return out;\n  }\n\n  repeat(count: i32 = 0): String {\n    assert(this !== null);\n    var length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || length * count > (1 << 28)) {\n      throw new RangeError(\"Invalid count value\");\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n\n    var result = allocateUnsafe(length * count);\n    repeatUnsafe(result, 0, this, count);\n    return result;\n  }\n\n  slice(beginIndex: i32, endIndex: i32 = i32.MAX_VALUE): String {\n    var len   = this.length;\n    var begin = beginIndex < 0 ? max(beginIndex + len, 0) : min(beginIndex, len);\n    var end   = endIndex   < 0 ? max(endIndex   + len, 0) : min(endIndex,   len);\n    len = end - begin;\n    if (len <= 0) return changetype<String>(\"\");\n    var out = allocateUnsafe(len);\n    copyUnsafe(out, 0, this, begin, len);\n    return out;\n  }\n\n  split(separator: String = null, limit: i32 = i32.MAX_VALUE): String[] {\n    assert(this !== null);\n    if (!limit) return new Array<String>();\n    if (separator === null) return <String[]>[this];\n    var length: isize = this.length;\n    var sepLen: isize = separator.length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return new Array<String>();\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = new Array<String>(length);\n      let buffer = <ArrayBuffer>result.buffer_;\n      for (let i: isize = 0; i < length; ++i) {\n        let char = allocateUnsafe(1);\n        store<u16>(\n          changetype<usize>(char),\n          load<u16>(\n            changetype<usize>(this) + (<usize>i << 1),\n            HEADER_SIZE\n          ),\n          HEADER_SIZE\n        );\n        STORE<String>(buffer, i, char);\n      }\n      return result;\n    } else if (!length) {\n      let result = new Array<String>(1);\n      unchecked(result[0] = changetype<String>(\"\"));\n      return result;\n    }\n    var result = new Array<String>();\n    var end = 0, start = 0, i = 0;\n    while ((end = this.indexOf(separator, start)) != -1) {\n      let len = end - start;\n      if (len > 0) {\n        let out = allocateUnsafe(len);\n        copyUnsafe(out, 0, this, start, len);\n        result.push(out);\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) {\n      let result = new Array<String>(1);\n      unchecked(result[0] = this);\n      return result;\n    }\n    var len = length - start;\n    if (len > 0) {\n      let out = allocateUnsafe(len);\n      copyUnsafe(out, 0, this, start, len);\n      result.push(out);\n    } else {\n      result.push(changetype<String>(\"\"));\n    }\n    return result;\n  }\n\n  toString(): String {\n    return this;\n  }\n\n  get lengthUTF8(): i32 {\n    var len = 1; // null terminated\n    var pos: usize = 0;\n    var end = <usize>this.length;\n    while (pos < end) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (pos << 1), HEADER_SIZE);\n      if (c < 128) {\n        len += 1; ++pos;\n      } else if (c < 2048) {\n        len += 2; ++pos;\n      } else {\n        if (\n          (c & 0xFC00) == 0xD800 && pos + 1 < end &&\n          (<u32>load<u16>(changetype<usize>(this) + ((pos + 1) << 1), HEADER_SIZE) & 0xFC00) == 0xDC00\n        ) {\n          len += 4; pos += 2;\n        } else {\n          len += 3; ++pos;\n        }\n      }\n    }\n    return len;\n  }\n\n  static fromUTF8(ptr: usize, len: usize): String {\n    if (len < 1) return changetype<String>(\"\");\n    var ptrPos = <usize>0;\n    var buf = memory.allocate(<usize>len << 1);\n    var bufPos = <usize>0;\n    while (ptrPos < len) {\n      let cp = <u32>load<u8>(ptr + ptrPos++);\n      if (cp < 128) {\n        store<u16>(buf + bufPos, cp);\n        bufPos += 2;\n      } else if (cp > 191 && cp < 224) {\n        assert(ptrPos + 1 <= len);\n        store<u16>(buf + bufPos, (cp & 31) << 6 | load<u8>(ptr + ptrPos++) & 63);\n        bufPos += 2;\n      } else if (cp > 239 && cp < 365) {\n        assert(ptrPos + 3 <= len);\n        cp = (\n          (cp                       &  7) << 18 |\n          (load<u8>(ptr + ptrPos++) & 63) << 12 |\n          (load<u8>(ptr + ptrPos++) & 63) <<  6 |\n           load<u8>(ptr + ptrPos++) & 63\n        ) - 0x10000;\n        store<u16>(buf + bufPos, 0xD800 + (cp >> 10));\n        bufPos += 2;\n        store<u16>(buf + bufPos, 0xDC00 + (cp & 1023));\n        bufPos += 2;\n      } else {\n        assert(ptrPos + 2 <= len);\n        store<u16>(buf + bufPos,\n          (cp                       & 15) << 12 |\n          (load<u8>(ptr + ptrPos++) & 63) <<  6 |\n           load<u8>(ptr + ptrPos++) & 63\n        );\n        bufPos += 2;\n      }\n    }\n    assert(ptrPos == len);\n    var str = allocateUnsafe(<u32>(bufPos >> 1));\n    memory.copy(changetype<usize>(str) + HEADER_SIZE, buf, bufPos);\n    memory.free(buf);\n    return str;\n  }\n\n  toUTF8(): usize {\n    var buf = memory.allocate(<usize>this.lengthUTF8);\n    var pos: usize = 0;\n    var end = <usize>this.length;\n    var off: usize = 0;\n    while (pos < end) {\n      let c1 = <u32>load<u16>(changetype<usize>(this) + (pos << 1), HEADER_SIZE);\n      if (c1 < 128) {\n        store<u8>(buf + off, c1);\n        ++off; ++pos;\n      } else if (c1 < 2048) {\n        let ptr = buf + off;\n        store<u8>(ptr, c1 >> 6 | 192);\n        store<u8>(ptr, c1 & 63 | 128, 1);\n        off += 2; ++pos;\n      } else {\n        let ptr = buf + off;\n        if ((c1 & 0xFC00) == 0xD800 && pos + 1 < end) {\n          let c2 = <u32>load<u16>(changetype<usize>(this) + ((pos + 1) << 1), HEADER_SIZE);\n          if ((c2 & 0xFC00) == 0xDC00) {\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\n            store<u8>(ptr, c1 >> 18      | 240);\n            store<u8>(ptr, c1 >> 12 & 63 | 128, 1);\n            store<u8>(ptr, c1 >>  6 & 63 | 128, 2);\n            store<u8>(ptr, c1       & 63 | 128, 3);\n            off += 4; pos += 2;\n            continue;\n          }\n        }\n        store<u8>(ptr, c1 >> 12     | 224);\n        store<u8>(ptr, c1 >> 6 & 63 | 128, 1);\n        store<u8>(ptr, c1      & 63 | 128, 2);\n        off += 3; ++pos;\n      }\n    }\n    store<u8>(buf + off, 0);\n    return buf;\n  }\n}\n\nexport type string = String;\n\nexport function parseInt(str: String, radix: i32 = 0): f64 {\n  return parse<f64>(str, radix);\n}\n\nexport function parseI32(str: String, radix: i32 = 0): i32 {\n  return parse<i32>(str, radix);\n}\n\nexport function parseI64(str: String, radix: i32 = 0): i64 {\n  return parse<i64>(str, radix);\n}\n\n// FIXME: naive implementation\nexport function parseFloat(str: String): f64 {\n  var len: i32 = str.length;\n  if (!len) return NaN;\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\n\n  // determine sign\n  var sign: f64;\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = 1;\n  } else {\n    sign = 1;\n  }\n\n  // calculate value\n  var num: f64 = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\n    if (code == CharCode.DOT) {\n      ptr += 2;\n      let fac: f64 = 0.1; // precision :(\n      while (len--) {\n        code = <i32>load<u16>(ptr, HEADER_SIZE);\n        if (code == CharCode.E || code == CharCode.e) {\n          assert(false); // TODO\n        }\n        code -= CharCode._0;\n        if (<u32>code > 9) break;\n        num += <f64>code * fac;\n        fac *= 0.1;\n        ptr += 2;\n      }\n      break;\n    }\n    code -= CharCode._0;\n    if (<u32>code >= 10) break;\n    num = (num * 10) + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n","import \"allocator/arena\";\nexport { memory };\n\nimport { context, storage, near, collections, base64 } from \"./near\";\nimport { Corgi, CorgiArray, CorgiMetaData } from \"./model.near\";\n\n// --- contract code goes below\n/////////////////////////////////\n// ERC721 for Non Fungible Tokens\nconst NAME: string = \"The NEAR Corgi Token\";\nconst SYMBOL: string = \"CORG\"\nconst TOTAL_SUPPLY: u64 = 420;\nconst DNA_DIGITS: u32 = 16;\nconst HEX_ALPHABET = '0123456789abcdef';\n\nexport function init(initialOwner: string): void {\n  near.log(\"initialOwner: \" + initialOwner);\n  assert(storage.getItem(\"init\") == null, \"Already initialized token supply\");\n  storage.setU64(\"io::\" + initialOwner, TOTAL_SUPPLY);\n  storage.setItem(\"init\", \"done\");\n}\n\n// Collections where we store data\nlet balances = collections.map<string, u64>(\"b\");\nlet corgis = collections.map<string, Corgi>(\"c\");\nlet corgisByOwner = collections.map<string, CorgiArray>(\"co\");\n\nexport function login():void {\n}\n\nexport function balanceOf(owner: string): u64 {\n  return balances.get(owner);\n}\n\nexport function ownerOf(tokenId: string): string {\n  let corgi = getCorgi(tokenId);\n  let owner = corgi.owner;\n  return owner;\n}\n\nexport function totalSupply(): string {\n  return TOTAL_SUPPLY.toString();\n}\n\nexport function name(): string {\n  return NAME;\n}\n\nexport function symbol(): string {\n  return SYMBOL;\n}\n\nexport function transfer(to: string, tokenId: string):void {\n  let corgi = getCorgi(tokenId);\n  assert(corgi.owner !== context.sender, \"corgi does not belong to \" + context.sender);\n  incrementNewOwnerCorgis(to, tokenId);\n  decrementOldOwnerCorgis(corgi.owner, tokenId);\n}\n\nfunction incrementNewOwnerCorgis(to: string, tokenId: string):void {\n  let corgi = getCorgi(tokenId);\n  corgi.owner = to;\n  near.log(to);\n  setCorgisByOwner(corgi);\n  setCorgi(corgi);\n}\n\nfunction decrementOldOwnerCorgis(from: string, tokenId: string):void {\n  let _corgis = corgisByOwner.get(from).corgis;\n  for (let i = 0; i < _corgis.length; i++) {\n    if (tokenId == _corgis[i].dna) {\n      _corgis.splice(i, 1);\n      near.log(\"match\");\n    }\n  }\n  let oca = new CorgiArray()\n  oca.corgis = _corgis;\n  corgisByOwner.set(from, oca);\n}\n\nfunction updateBalance(owner: string, increment: u64): void {\n  let balance = balanceOf(owner);\n  if (balance) {\n    near.log(`${balance}`);\n  } else {\n    near.log(\"issues\");\n  }\n}\n\nfunction _createCorgi(name: string, dna: string, color:string): Corgi {\n  let corgi = new Corgi();\n  corgi.owner = context.sender;\n  corgi.dna = dna;\n  corgi.name = name;\n  corgi.color = color\n  setCorgi(corgi);\n  setCorgisByOwner(corgi);\n  return corgi;\n}\n\nexport function generateRandomDna(): string {\n  let buf = near.randomBuffer(DNA_DIGITS);\n  let b64 = base64.encode(buf);\n  near.log(b64);\n  return b64;\n}\nfunction intToHex(integer: u32): string {\n  let res = new Array<string>();\n  do {\n    let t = integer / 16;\n    let r = integer % 16;\n    integer = t;\n    res.push(HEX_ALPHABET[r]);\n  } while (integer);\n  let hex = res.reverse().join('');\n  return hex.length % 2 ? \"0\" + hex : hex;\n}\n\nexport function generateRandomColorHex(int:i32):string {\n  Math.seedRandom(int);\n  let rand = Math.floor(Math.random() * 16777215) as u32;\n  let hex = intToHex(rand);\n  return \"#\"+hex;\n}\n\nexport function createRandomCorgi(name: string, seed: i32): Corgi {\n  let randDna = generateRandomDna();\n  let color = generateRandomColorHex(seed);\n  return _createCorgi(name, randDna, color);\n}\n\nexport function getCorgi(tokenId: string): Corgi {\n  return corgis.get(tokenId);\n}\n\nexport function setCorgi(corgi: Corgi): void {\n  corgis.set(corgi.dna, corgi);\n}\n\nexport function getSender(): string {\n  return context.sender;\n}\n\nexport function getCorgisByOwner(owner: string): CorgiArray {\n  return corgisByOwner.get(owner);\n}\n\nfunction setCorgisByOwner(corgi: Corgi): void {\n  let _corgis = getCorgisByOwner(corgi.owner).corgis;\n\n  if (_corgis == null) {\n    _corgis = new Array();\n    _corgis.push(corgi);\n  } else {\n    _corgis.push(corgi);\n  }\n\n  let ca = new CorgiArray();\n\n  ca.corgis = _corgis;\n  corgisByOwner.set(corgi.owner, ca);\n}\n\nexport function setBalance(owner: string, balance: u64): void {\n  balances.set(owner, balance);\n}\n\n//ERROR handling\nfunction _corgiDNEError(corgi: Corgi): bool {\n  return assert(corgi == null, \"This corgi does not exist\");\n}\n\n// simplified version of the ERC721\n// contract ERC721 {\n   // ERC20 compatible functions\n  //  function name() constant returns (string name);\n  //  function symbol() constant returns (string symbol);\n\n  //  function totalSupply() constant returns (uint256 totalSupply);\n  //  function balanceOf(address _owner) constant returns (uint balance);\n\n   // Functions that define ownership\n  //  function ownerOf(uint256 tokenId) constant returns (address owner);\n\n  //  function approve(address to, uint256 tokenId);\n  //  function takeOwnership(uint256 tokenId);\n\n  // //  function transfer(address to, uint256 tokenId);\n  //  function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId);\n\n  //  // Token metadata\n  //  function tokenMetadata(uint256 tokenId) constant returns (string infoUrl);\n\n","\n      import { storage, near, base64 } from \"./near\";\n      import { JSONEncoder } from \"./json/encoder\";\n      import { JSONDecoder, ThrowingJSONHandler, DecoderState } from \"./json/decoder\";\n      import {init as wrapped_init, login as wrapped_login, balanceOf as wrapped_balanceOf, ownerOf as wrapped_ownerOf, totalSupply as wrapped_totalSupply, name as wrapped_name, symbol as wrapped_symbol, transfer as wrapped_transfer, generateRandomDna as wrapped_generateRandomDna, generateRandomColorHex as wrapped_generateRandomColorHex, createRandomCorgi as wrapped_createRandomCorgi, getCorgi as wrapped_getCorgi, setCorgi as wrapped_setCorgi, getSender as wrapped_getSender, getCorgisByOwner as wrapped_getCorgisByOwner, setBalance as wrapped_setBalance} from \"./main\";\n      \n      // Runtime functions\n      @external(\"env\", \"return_value\")\n      declare function return_value(value_len: usize, value_ptr: usize): void;\n    \nimport {context as context,storage as storage,near as near,collections as collections,base64 as base64} from \"./near\";\nimport {Corgi as Corgi,CorgiArray as CorgiArray,CorgiMetaData as CorgiMetaData} from \"./model.near\";\nexport class __near_ArgsParser_init extends ThrowingJSONHandler {\n        buffer: Uint8Array;\n        decoder: JSONDecoder<__near_ArgsParser_init>;\n        handledRoot: boolean = false;\n      \n__near_param_initialOwner: String;\nsetString(name: string, value: String): void {\nif (name == \"initialOwner\") {\n            this.__near_param_initialOwner = <String>value;\n            return;\n          }\n\n        super.setString(name, value);\n      }\nsetNull(name: string): void {\nif (name == \"initialOwner\") {\n        this.__near_param_initialOwner = <String>null;\n        return;\n      }\n\n      super.setNull(name);\n    }\n\n      pushObject(name: string): bool {\nif (!this.handledRoot) {\n      assert(name == null);\n      this.handledRoot = true;\n      return true;\n    } else {\n      assert(name != null);\n    }\n\n        return super.pushObject(name);\n      }\n\n      pushArray(name: string): bool {\n\n        return super.pushArray(name);\n      }\n}\nexport function init(): void {\n      // Reading input bytes.\n      let json = storage._internalReadBytes(4, 0, 0);\n      let handler = new __near_ArgsParser_init();\n      handler.buffer = json;\n      handler.decoder = new JSONDecoder<__near_ArgsParser_init>(handler);\n      handler.decoder.deserialize(json);\nwrapped_init(\nhandler.__near_param_initialOwner\n);\n}\nexport class __near_ArgsParser_login extends ThrowingJSONHandler {\n        buffer: Uint8Array;\n        decoder: JSONDecoder<__near_ArgsParser_login>;\n        handledRoot: boolean = false;\n      \nsetNull(name: string): void {\n\n      super.setNull(name);\n    }\n\n      pushObject(name: string): bool {\nif (!this.handledRoot) {\n      assert(name == null);\n      this.handledRoot = true;\n      return true;\n    } else {\n      assert(name != null);\n    }\n\n        return super.pushObject(name);\n      }\n\n      pushArray(name: string): bool {\n\n        return super.pushArray(name);\n      }\n}\nexport function login(): void {\n      // Reading input bytes.\n      let json = storage._internalReadBytes(4, 0, 0);\n      let handler = new __near_ArgsParser_login();\n      handler.buffer = json;\n      handler.decoder = new JSONDecoder<__near_ArgsParser_login>(handler);\n      handler.decoder.deserialize(json);\nwrapped_login(\n\n);\n}\nexport class __near_ArgsParser_balanceOf extends ThrowingJSONHandler {\n        buffer: Uint8Array;\n        decoder: JSONDecoder<__near_ArgsParser_balanceOf>;\n        handledRoot: boolean = false;\n      \n__near_param_owner: String;\nsetString(name: string, value: String): void {\nif (name == \"owner\") {\n            this.__near_param_owner = <String>value;\n            return;\n          }\n\n        super.setString(name, value);\n      }\nsetNull(name: string): void {\nif (name == \"owner\") {\n        this.__near_param_owner = <String>null;\n        return;\n      }\n\n      super.setNull(name);\n    }\n\n      pushObject(name: string): bool {\nif (!this.handledRoot) {\n      assert(name == null);\n      this.handledRoot = true;\n      return true;\n    } else {\n      assert(name != null);\n    }\n\n        return super.pushObject(name);\n      }\n\n      pushArray(name: string): bool {\n\n        return super.pushArray(name);\n      }\n}\nexport function balanceOf(): void {\n      // Reading input bytes.\n      let json = storage._internalReadBytes(4, 0, 0);\n      let handler = new __near_ArgsParser_balanceOf();\n      handler.buffer = json;\n      handler.decoder = new JSONDecoder<__near_ArgsParser_balanceOf>(handler);\n      handler.decoder.deserialize(json);\nlet result = wrapped_balanceOf(\nhandler.__near_param_owner\n);\n\n        let encoder = new JSONEncoder();\n      \nencoder.setString(null, result.toString());\n\n        let val = encoder.serialize();\n        return_value(val.byteLength, val.buffer.data);\n      \n}\nexport class __near_ArgsParser_ownerOf extends ThrowingJSONHandler {\n        buffer: Uint8Array;\n        decoder: JSONDecoder<__near_ArgsParser_ownerOf>;\n        handledRoot: boolean = false;\n      \n__near_param_tokenId: String;\nsetString(name: string, value: String): void {\nif (name == \"tokenId\") {\n            this.__near_param_tokenId = <String>value;\n            return;\n          }\n\n        super.setString(name, value);\n      }\nsetNull(name: string): void {\nif (name == \"tokenId\") {\n        this.__near_param_tokenId = <String>null;\n        return;\n      }\n\n      super.setNull(name);\n    }\n\n      pushObject(name: string): bool {\nif (!this.handledRoot) {\n      assert(name == null);\n      this.handledRoot = true;\n      return true;\n    } else {\n      assert(name != null);\n    }\n\n        return super.pushObject(name);\n      }\n\n      pushArray(name: string): bool {\n\n        return super.pushArray(name);\n      }\n}\nexport function ownerOf(): void {\n      // Reading input bytes.\n      let json = storage._internalReadBytes(4, 0, 0);\n      let handler = new __near_ArgsParser_ownerOf();\n      handler.buffer = json;\n      handler.decoder = new JSONDecoder<__near_ArgsParser_ownerOf>(handler);\n      handler.decoder.deserialize(json);\nlet result = wrapped_ownerOf(\nhandler.__near_param_tokenId\n);\n\n        let encoder = new JSONEncoder();\n      \nif (result != null) {\n            encoder.setString(null, result);\n          } else {\n            encoder.setNull(null);\n          }\n\n        let val = encoder.serialize();\n        return_value(val.byteLength, val.buffer.data);\n      \n}\nexport class __near_ArgsParser_totalSupply extends ThrowingJSONHandler {\n        buffer: Uint8Array;\n        decoder: JSONDecoder<__near_ArgsParser_totalSupply>;\n        handledRoot: boolean = false;\n      \nsetNull(name: string): void {\n\n      super.setNull(name);\n    }\n\n      pushObject(name: string): bool {\nif (!this.handledRoot) {\n      assert(name == null);\n      this.handledRoot = true;\n      return true;\n    } else {\n      assert(name != null);\n    }\n\n        return super.pushObject(name);\n      }\n\n      pushArray(name: string): bool {\n\n        return super.pushArray(name);\n      }\n}\nexport function totalSupply(): void {\n      // Reading input bytes.\n      let json = storage._internalReadBytes(4, 0, 0);\n      let handler = new __near_ArgsParser_totalSupply();\n      handler.buffer = json;\n      handler.decoder = new JSONDecoder<__near_ArgsParser_totalSupply>(handler);\n      handler.decoder.deserialize(json);\nlet result = wrapped_totalSupply(\n\n);\n\n        let encoder = new JSONEncoder();\n      \nif (result != null) {\n            encoder.setString(null, result);\n          } else {\n            encoder.setNull(null);\n          }\n\n        let val = encoder.serialize();\n        return_value(val.byteLength, val.buffer.data);\n      \n}\nexport class __near_ArgsParser_name extends ThrowingJSONHandler {\n        buffer: Uint8Array;\n        decoder: JSONDecoder<__near_ArgsParser_name>;\n        handledRoot: boolean = false;\n      \nsetNull(name: string): void {\n\n      super.setNull(name);\n    }\n\n      pushObject(name: string): bool {\nif (!this.handledRoot) {\n      assert(name == null);\n      this.handledRoot = true;\n      return true;\n    } else {\n      assert(name != null);\n    }\n\n        return super.pushObject(name);\n      }\n\n      pushArray(name: string): bool {\n\n        return super.pushArray(name);\n      }\n}\nexport function name(): void {\n      // Reading input bytes.\n      let json = storage._internalReadBytes(4, 0, 0);\n      let handler = new __near_ArgsParser_name();\n      handler.buffer = json;\n      handler.decoder = new JSONDecoder<__near_ArgsParser_name>(handler);\n      handler.decoder.deserialize(json);\nlet result = wrapped_name(\n\n);\n\n        let encoder = new JSONEncoder();\n      \nif (result != null) {\n            encoder.setString(null, result);\n          } else {\n            encoder.setNull(null);\n          }\n\n        let val = encoder.serialize();\n        return_value(val.byteLength, val.buffer.data);\n      \n}\nexport class __near_ArgsParser_symbol extends ThrowingJSONHandler {\n        buffer: Uint8Array;\n        decoder: JSONDecoder<__near_ArgsParser_symbol>;\n        handledRoot: boolean = false;\n      \nsetNull(name: string): void {\n\n      super.setNull(name);\n    }\n\n      pushObject(name: string): bool {\nif (!this.handledRoot) {\n      assert(name == null);\n      this.handledRoot = true;\n      return true;\n    } else {\n      assert(name != null);\n    }\n\n        return super.pushObject(name);\n      }\n\n      pushArray(name: string): bool {\n\n        return super.pushArray(name);\n      }\n}\nexport function symbol(): void {\n      // Reading input bytes.\n      let json = storage._internalReadBytes(4, 0, 0);\n      let handler = new __near_ArgsParser_symbol();\n      handler.buffer = json;\n      handler.decoder = new JSONDecoder<__near_ArgsParser_symbol>(handler);\n      handler.decoder.deserialize(json);\nlet result = wrapped_symbol(\n\n);\n\n        let encoder = new JSONEncoder();\n      \nif (result != null) {\n            encoder.setString(null, result);\n          } else {\n            encoder.setNull(null);\n          }\n\n        let val = encoder.serialize();\n        return_value(val.byteLength, val.buffer.data);\n      \n}\nexport class __near_ArgsParser_transfer extends ThrowingJSONHandler {\n        buffer: Uint8Array;\n        decoder: JSONDecoder<__near_ArgsParser_transfer>;\n        handledRoot: boolean = false;\n      \n__near_param_to: String;\n__near_param_tokenId: String;\nsetString(name: string, value: String): void {\nif (name == \"to\") {\n            this.__near_param_to = <String>value;\n            return;\n          }\nif (name == \"tokenId\") {\n            this.__near_param_tokenId = <String>value;\n            return;\n          }\n\n        super.setString(name, value);\n      }\nsetNull(name: string): void {\nif (name == \"to\") {\n        this.__near_param_to = <String>null;\n        return;\n      }\nif (name == \"tokenId\") {\n        this.__near_param_tokenId = <String>null;\n        return;\n      }\n\n      super.setNull(name);\n    }\n\n      pushObject(name: string): bool {\nif (!this.handledRoot) {\n      assert(name == null);\n      this.handledRoot = true;\n      return true;\n    } else {\n      assert(name != null);\n    }\n\n        return super.pushObject(name);\n      }\n\n      pushArray(name: string): bool {\n\n        return super.pushArray(name);\n      }\n}\nexport function transfer(): void {\n      // Reading input bytes.\n      let json = storage._internalReadBytes(4, 0, 0);\n      let handler = new __near_ArgsParser_transfer();\n      handler.buffer = json;\n      handler.decoder = new JSONDecoder<__near_ArgsParser_transfer>(handler);\n      handler.decoder.deserialize(json);\nwrapped_transfer(\nhandler.__near_param_to,handler.__near_param_tokenId\n);\n}\nexport class __near_ArgsParser_generateRandomDna extends ThrowingJSONHandler {\n        buffer: Uint8Array;\n        decoder: JSONDecoder<__near_ArgsParser_generateRandomDna>;\n        handledRoot: boolean = false;\n      \nsetNull(name: string): void {\n\n      super.setNull(name);\n    }\n\n      pushObject(name: string): bool {\nif (!this.handledRoot) {\n      assert(name == null);\n      this.handledRoot = true;\n      return true;\n    } else {\n      assert(name != null);\n    }\n\n        return super.pushObject(name);\n      }\n\n      pushArray(name: string): bool {\n\n        return super.pushArray(name);\n      }\n}\nexport function generateRandomDna(): void {\n      // Reading input bytes.\n      let json = storage._internalReadBytes(4, 0, 0);\n      let handler = new __near_ArgsParser_generateRandomDna();\n      handler.buffer = json;\n      handler.decoder = new JSONDecoder<__near_ArgsParser_generateRandomDna>(handler);\n      handler.decoder.deserialize(json);\nlet result = wrapped_generateRandomDna(\n\n);\n\n        let encoder = new JSONEncoder();\n      \nif (result != null) {\n            encoder.setString(null, result);\n          } else {\n            encoder.setNull(null);\n          }\n\n        let val = encoder.serialize();\n        return_value(val.byteLength, val.buffer.data);\n      \n}\nexport class __near_ArgsParser_generateRandomColorHex extends ThrowingJSONHandler {\n        buffer: Uint8Array;\n        decoder: JSONDecoder<__near_ArgsParser_generateRandomColorHex>;\n        handledRoot: boolean = false;\n      \n__near_param_int: i32;\nsetInteger(name: string, value: i64): void {\nif (name == \"int\") {\n            this.__near_param_int = <i32>value;\n            return;\n          }\n\n        super.setInteger(name, value);\n      }\nsetNull(name: string): void {\nif (name == \"int\") {\n        this.__near_param_int = <i32>null;\n        return;\n      }\n\n      super.setNull(name);\n    }\n\n      pushObject(name: string): bool {\nif (!this.handledRoot) {\n      assert(name == null);\n      this.handledRoot = true;\n      return true;\n    } else {\n      assert(name != null);\n    }\n\n        return super.pushObject(name);\n      }\n\n      pushArray(name: string): bool {\n\n        return super.pushArray(name);\n      }\n}\nexport function generateRandomColorHex(): void {\n      // Reading input bytes.\n      let json = storage._internalReadBytes(4, 0, 0);\n      let handler = new __near_ArgsParser_generateRandomColorHex();\n      handler.buffer = json;\n      handler.decoder = new JSONDecoder<__near_ArgsParser_generateRandomColorHex>(handler);\n      handler.decoder.deserialize(json);\nlet result = wrapped_generateRandomColorHex(\nhandler.__near_param_int\n);\n\n        let encoder = new JSONEncoder();\n      \nif (result != null) {\n            encoder.setString(null, result);\n          } else {\n            encoder.setNull(null);\n          }\n\n        let val = encoder.serialize();\n        return_value(val.byteLength, val.buffer.data);\n      \n}\nexport class __near_ArgsParser_createRandomCorgi extends ThrowingJSONHandler {\n        buffer: Uint8Array;\n        decoder: JSONDecoder<__near_ArgsParser_createRandomCorgi>;\n        handledRoot: boolean = false;\n      \n__near_param_name: String;\n__near_param_seed: i32;\nsetInteger(name: string, value: i64): void {\nif (name == \"seed\") {\n            this.__near_param_seed = <i32>value;\n            return;\n          }\n\n        super.setInteger(name, value);\n      }\nsetString(name: string, value: String): void {\nif (name == \"name\") {\n            this.__near_param_name = <String>value;\n            return;\n          }\n\n        super.setString(name, value);\n      }\nsetNull(name: string): void {\nif (name == \"name\") {\n        this.__near_param_name = <String>null;\n        return;\n      }\nif (name == \"seed\") {\n        this.__near_param_seed = <i32>null;\n        return;\n      }\n\n      super.setNull(name);\n    }\n\n      pushObject(name: string): bool {\nif (!this.handledRoot) {\n      assert(name == null);\n      this.handledRoot = true;\n      return true;\n    } else {\n      assert(name != null);\n    }\n\n        return super.pushObject(name);\n      }\n\n      pushArray(name: string): bool {\n\n        return super.pushArray(name);\n      }\n}\nimport { __near_encode_Corgi } from \"./model.near\";\nexport function createRandomCorgi(): void {\n      // Reading input bytes.\n      let json = storage._internalReadBytes(4, 0, 0);\n      let handler = new __near_ArgsParser_createRandomCorgi();\n      handler.buffer = json;\n      handler.decoder = new JSONDecoder<__near_ArgsParser_createRandomCorgi>(handler);\n      handler.decoder.deserialize(json);\nlet result = wrapped_createRandomCorgi(\nhandler.__near_param_name,handler.__near_param_seed\n);\n\n        let encoder = new JSONEncoder();\n      \nif (result != null) {\n          encoder.pushObject(null);\n          __near_encode_Corgi(result, encoder);\n          encoder.popObject();\n        } else {\n          encoder.setNull(null);\n        }\n\n        let val = encoder.serialize();\n        return_value(val.byteLength, val.buffer.data);\n      \n}\nexport class __near_ArgsParser_getCorgi extends ThrowingJSONHandler {\n        buffer: Uint8Array;\n        decoder: JSONDecoder<__near_ArgsParser_getCorgi>;\n        handledRoot: boolean = false;\n      \n__near_param_tokenId: String;\nsetString(name: string, value: String): void {\nif (name == \"tokenId\") {\n            this.__near_param_tokenId = <String>value;\n            return;\n          }\n\n        super.setString(name, value);\n      }\nsetNull(name: string): void {\nif (name == \"tokenId\") {\n        this.__near_param_tokenId = <String>null;\n        return;\n      }\n\n      super.setNull(name);\n    }\n\n      pushObject(name: string): bool {\nif (!this.handledRoot) {\n      assert(name == null);\n      this.handledRoot = true;\n      return true;\n    } else {\n      assert(name != null);\n    }\n\n        return super.pushObject(name);\n      }\n\n      pushArray(name: string): bool {\n\n        return super.pushArray(name);\n      }\n}\nexport function getCorgi(): void {\n      // Reading input bytes.\n      let json = storage._internalReadBytes(4, 0, 0);\n      let handler = new __near_ArgsParser_getCorgi();\n      handler.buffer = json;\n      handler.decoder = new JSONDecoder<__near_ArgsParser_getCorgi>(handler);\n      handler.decoder.deserialize(json);\nlet result = wrapped_getCorgi(\nhandler.__near_param_tokenId\n);\n\n        let encoder = new JSONEncoder();\n      \nif (result != null) {\n          encoder.pushObject(null);\n          __near_encode_Corgi(result, encoder);\n          encoder.popObject();\n        } else {\n          encoder.setNull(null);\n        }\n\n        let val = encoder.serialize();\n        return_value(val.byteLength, val.buffer.data);\n      \n}\nimport { __near_decode_Corgi } from \"./model.near\";\nexport class __near_ArgsParser_setCorgi extends ThrowingJSONHandler {\n        buffer: Uint8Array;\n        decoder: JSONDecoder<__near_ArgsParser_setCorgi>;\n        handledRoot: boolean = false;\n      \n__near_param_corgi: Corgi;\nsetNull(name: string): void {\nif (name == \"corgi\") {\n        this.__near_param_corgi = <Corgi>null;\n        return;\n      }\n\n      super.setNull(name);\n    }\n\n      pushObject(name: string): bool {\nif (!this.handledRoot) {\n      assert(name == null);\n      this.handledRoot = true;\n      return true;\n    } else {\n      assert(name != null);\n    }\nif (name == \"corgi\") {\n          this.__near_param_corgi = __near_decode_Corgi(this.buffer, this.decoder.state);\n          return false;\n        }\n\n        return super.pushObject(name);\n      }\n\n      pushArray(name: string): bool {\n\n        return super.pushArray(name);\n      }\n}\nexport function setCorgi(): void {\n      // Reading input bytes.\n      let json = storage._internalReadBytes(4, 0, 0);\n      let handler = new __near_ArgsParser_setCorgi();\n      handler.buffer = json;\n      handler.decoder = new JSONDecoder<__near_ArgsParser_setCorgi>(handler);\n      handler.decoder.deserialize(json);\nwrapped_setCorgi(\nhandler.__near_param_corgi\n);\n}\nexport class __near_ArgsParser_getSender extends ThrowingJSONHandler {\n        buffer: Uint8Array;\n        decoder: JSONDecoder<__near_ArgsParser_getSender>;\n        handledRoot: boolean = false;\n      \nsetNull(name: string): void {\n\n      super.setNull(name);\n    }\n\n      pushObject(name: string): bool {\nif (!this.handledRoot) {\n      assert(name == null);\n      this.handledRoot = true;\n      return true;\n    } else {\n      assert(name != null);\n    }\n\n        return super.pushObject(name);\n      }\n\n      pushArray(name: string): bool {\n\n        return super.pushArray(name);\n      }\n}\nexport function getSender(): void {\n      // Reading input bytes.\n      let json = storage._internalReadBytes(4, 0, 0);\n      let handler = new __near_ArgsParser_getSender();\n      handler.buffer = json;\n      handler.decoder = new JSONDecoder<__near_ArgsParser_getSender>(handler);\n      handler.decoder.deserialize(json);\nlet result = wrapped_getSender(\n\n);\n\n        let encoder = new JSONEncoder();\n      \nif (result != null) {\n            encoder.setString(null, result);\n          } else {\n            encoder.setNull(null);\n          }\n\n        let val = encoder.serialize();\n        return_value(val.byteLength, val.buffer.data);\n      \n}\nexport class __near_ArgsParser_getCorgisByOwner extends ThrowingJSONHandler {\n        buffer: Uint8Array;\n        decoder: JSONDecoder<__near_ArgsParser_getCorgisByOwner>;\n        handledRoot: boolean = false;\n      \n__near_param_owner: String;\nsetString(name: string, value: String): void {\nif (name == \"owner\") {\n            this.__near_param_owner = <String>value;\n            return;\n          }\n\n        super.setString(name, value);\n      }\nsetNull(name: string): void {\nif (name == \"owner\") {\n        this.__near_param_owner = <String>null;\n        return;\n      }\n\n      super.setNull(name);\n    }\n\n      pushObject(name: string): bool {\nif (!this.handledRoot) {\n      assert(name == null);\n      this.handledRoot = true;\n      return true;\n    } else {\n      assert(name != null);\n    }\n\n        return super.pushObject(name);\n      }\n\n      pushArray(name: string): bool {\n\n        return super.pushArray(name);\n      }\n}\nimport { __near_encode_CorgiArray } from \"./model.near\";\nexport function getCorgisByOwner(): void {\n      // Reading input bytes.\n      let json = storage._internalReadBytes(4, 0, 0);\n      let handler = new __near_ArgsParser_getCorgisByOwner();\n      handler.buffer = json;\n      handler.decoder = new JSONDecoder<__near_ArgsParser_getCorgisByOwner>(handler);\n      handler.decoder.deserialize(json);\nlet result = wrapped_getCorgisByOwner(\nhandler.__near_param_owner\n);\n\n        let encoder = new JSONEncoder();\n      \nif (result != null) {\n          encoder.pushObject(null);\n          __near_encode_CorgiArray(result, encoder);\n          encoder.popObject();\n        } else {\n          encoder.setNull(null);\n        }\n\n        let val = encoder.serialize();\n        return_value(val.byteLength, val.buffer.data);\n      \n}\nexport class __near_ArgsParser_setBalance extends ThrowingJSONHandler {\n        buffer: Uint8Array;\n        decoder: JSONDecoder<__near_ArgsParser_setBalance>;\n        handledRoot: boolean = false;\n      \n__near_param_owner: String;\n__near_param_balance: u64;\nsetString(name: string, value: String): void {\nif (name == \"owner\") {\n            this.__near_param_owner = <String>value;\n            return;\n          }\nif (name == \"balance\") {\n              this.__near_param_balance = U64.parseInt(value);\n              return;\n            }\n\n        super.setString(name, value);\n      }\nsetNull(name: string): void {\nif (name == \"owner\") {\n        this.__near_param_owner = <String>null;\n        return;\n      }\nif (name == \"balance\") {\n        this.__near_param_balance = <u64>null;\n        return;\n      }\n\n      super.setNull(name);\n    }\n\n      pushObject(name: string): bool {\nif (!this.handledRoot) {\n      assert(name == null);\n      this.handledRoot = true;\n      return true;\n    } else {\n      assert(name != null);\n    }\n\n        return super.pushObject(name);\n      }\n\n      pushArray(name: string): bool {\n\n        return super.pushArray(name);\n      }\n}\nexport function setBalance(): void {\n      // Reading input bytes.\n      let json = storage._internalReadBytes(4, 0, 0);\n      let handler = new __near_ArgsParser_setBalance();\n      handler.buffer = json;\n      handler.decoder = new JSONDecoder<__near_ArgsParser_setBalance>(handler);\n      handler.decoder.deserialize(json);\nwrapped_setBalance(\nhandler.__near_param_owner,handler.__near_param_balance\n);\n}","import {\n  itoa,\n  dtoa\n} from \"./internal/number\";\n\nimport {\n  isNaN as builtin_isNaN,\n  isFinite as builtin_isFinite\n} from \"./builtins\";\n\n@sealed\nexport abstract class I8 {\n\n  @lazy static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i8 {\n    return <i8>parseI32(value, radix);\n  }\n\n  toString(this: i8): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed\nexport abstract class I16 {\n\n  @lazy static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i16 {\n    return <i16>parseI32(value, radix);\n  }\n\n  toString(this: i16): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed\nexport abstract class I32 {\n\n  @lazy static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i32 {\n    return <i32>parseI32(value, radix);\n  }\n\n  toString(this: i32): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed\nexport abstract class I64 {\n\n  @lazy static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i64 {\n    return <i64>parseI64(value, radix);\n  }\n\n  toString(this: i64): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed\nexport abstract class Isize {\n\n  @lazy static readonly MIN_VALUE: isize = isize.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: isize = isize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): isize {\n    return <isize>parseI64(value, radix);\n  }\n\n  toString(this: isize): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed\nexport abstract class U8 {\n\n  @lazy static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u8 {\n    return <u8>parseI32(value, radix);\n  }\n\n  toString(this: u8): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed\nexport abstract class U16 {\n\n  @lazy static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u16 {\n    return <u16>parseI32(value, radix);\n  }\n\n  toString(this: u16): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed\nexport abstract class U32 {\n\n  @lazy static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u32 {\n    return <u32>parseI32(value, radix);\n  }\n\n  toString(this: u32): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed\nexport abstract class U64 {\n\n  @lazy static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u64 {\n    return <u64>parseI64(value, radix);\n  }\n\n  toString(this: u64): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed\nexport abstract class Usize {\n\n  @lazy static readonly MIN_VALUE: usize = usize.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: usize = usize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): usize {\n    return <usize>parseI64(value, radix);\n  }\n\n  toString(this: usize): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed\nexport abstract class Bool {\n\n  @lazy static readonly MIN_VALUE: bool = bool.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: bool = bool.MAX_VALUE;\n\n  toString(this: bool): String {\n    // TODO: radix?\n    return this ? \"true\" : \"false\";\n  }\n}\n\nexport { Bool as Boolean };\n\n@sealed\nexport abstract class F32 {\n\n  @lazy static readonly EPSILON: f32 = f32.EPSILON;\n  @lazy static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\n  @lazy static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\n  @lazy static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\n  @lazy static readonly POSITIVE_INFINITY: f32 = Infinity;\n  @lazy static readonly NEGATIVE_INFINITY: f32 = -Infinity;\n  @lazy static readonly NaN: f32 = NaN;\n\n  static isNaN(value: f32): bool {\n    return isNaN<f32>(value);\n  }\n\n  static isFinite(value: f32): bool {\n    return isFinite<f32>(value);\n  }\n\n  static isSafeInteger(value: f32): bool {\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\n  }\n\n  static isInteger(value: f32): bool {\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f32 {\n    return <f32>parseI64(value, radix);\n  }\n\n  static parseFloat(value: string): f32 {\n    return <f32>parseFloat(value);\n  }\n\n  toString(this: f32): String {\n    // TODO: radix\n    return dtoa(this);\n  }\n}\n\n@sealed\nexport abstract class F64 {\n\n  @lazy static readonly EPSILON: f64 = f64.EPSILON;\n  @lazy static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\n  @lazy static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\n  @lazy static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\n  @lazy static readonly POSITIVE_INFINITY: f64 = Infinity;\n  @lazy static readonly NEGATIVE_INFINITY: f64 = -Infinity;\n  @lazy static readonly NaN: f64 = NaN;\n\n  static isNaN(value: f64): bool {\n    return builtin_isNaN<f64>(value);\n  }\n\n  static isFinite(value: f64): bool {\n    return builtin_isFinite<f64>(value);\n  }\n\n  static isSafeInteger(value: f64): bool {\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\n  }\n\n  static isInteger(value: f64): bool {\n    return builtin_isFinite<f64>(value) && trunc<f64>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f64 {\n    return <f64>parseI64(value, radix);\n  }\n\n  static parseFloat(value: string): f64 {\n    return parseFloat(value);\n  }\n\n  toString(this: f64): String {\n    // TODO: radix\n    return dtoa(this);\n  }\n}\n\nexport { F64 as Number };\n","import {\n  CharCode,\n  allocateUnsafe as allocateUnsafeString,\n  freeUnsafe as freeUnsafeString,\n  HEADER_SIZE as STRING_HEADER_SIZE\n} from \"./string\";\n\nimport {\n  LOAD\n} from \"./arraybuffer\";\n\n@inline export const MAX_DOUBLE_LENGTH = 28;\n\n@lazy @inline const POWERS10: u32[] = [\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n];\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n@lazy @inline const DIGITS: u32[] = [\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n];\n\n@lazy @inline const EXP_POWERS: i16[] = [\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n];\n\n// 1e-348, 1e-340, ..., 1e340\n@lazy @inline const FRC_POWERS: u64[] = [\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n];\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    let l: u32 = 32 - clz<u32>(value); // log2\n    let t = l * 1233 >>> 12; // log10\n\n    let lutbuf = <ArrayBuffer>POWERS10.buffer_;\n    let power  = LOAD<u32>(lutbuf, t);\n    t -= <u32>(value < power);\n    return t + 1;\n  } else {\n    if (value < 100000) {\n      if (value < 100) {\n        return select<u32>(1, 2, value < 10);\n      } else {\n        let m = select<u32>(4, 5, value < 10000);\n        return select<u32>(3, m, value < 1000);\n      }\n    } else {\n      if (value < 10000000) {\n        return select<u32>(6, 7, value < 1000000);\n      } else {\n        let m = select<u32>(9, 10, value < 1000000000);\n        return select<u32>(8, m, value < 100000000);\n      }\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64(value: u64): u32 {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    let l: u32 = 64 - <u32>clz<u64>(value); // log2\n    let t = l * 1233 >>> 12; // log10\n\n    let lutbuf = <ArrayBuffer>POWERS10.buffer_;\n    let power  = LOAD<u32,u64>(lutbuf, t - 10);\n    t -= <u32>(value < 10000000000 * power);\n    return t + 1;\n  } else {\n    if (value < 1000000000000000) {\n      if (value < 1000000000000) {\n        return select<u32>(11, 12, value < 100000000000);\n      } else {\n        let m = select<u32>(14, 15, value < 100000000000000);\n        return select<u32>(13, m, value < 10000000000000);\n      }\n    } else {\n      if (value < 100000000000000000) {\n        return select<u32>(16, 17, value < 10000000000000000);\n      } else {\n        let m = select<u32>(19, 20, value < 10000000000000000000);\n        return select<u32>(18, m, value < 1000000000000000000);\n      }\n    }\n  }\n}\n\nfunction utoa32_lut(buffer: usize, num: u32, offset: usize): void {\n  var lutbuf = <ArrayBuffer>DIGITS.buffer_;\n\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = LOAD<u32,u64>(lutbuf, d1);\n    let digits2 = LOAD<u32,u64>(lutbuf, d2);\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32), STRING_HEADER_SIZE);\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = LOAD<u32>(lutbuf, d1);\n    store<u32>(buffer + (offset << 1), digits, STRING_HEADER_SIZE);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = LOAD<u32>(lutbuf, num);\n    store<u32>(buffer + (offset << 1), digits, STRING_HEADER_SIZE);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit, STRING_HEADER_SIZE);\n  }\n}\n\nfunction utoa64_lut(buffer: usize, num: u64, offset: usize): void {\n  var lutbuf = <ArrayBuffer>DIGITS.buffer_;\n\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = LOAD<u32,u64>(lutbuf, c1);\n    let digits2 = LOAD<u32,u64>(lutbuf, c2);\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32), STRING_HEADER_SIZE);\n\n    digits1 = LOAD<u32,u64>(lutbuf, b1);\n    digits2 = LOAD<u32,u64>(lutbuf, b2);\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32), STRING_HEADER_SIZE);\n  }\n\n  utoa32_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_simple<T>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = t;\n    offset -= 1;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r, STRING_HEADER_SIZE);\n  } while (num);\n}\n\n@inline\nexport function utoa32_core(buffer: usize, num: u32, offset: u32): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_simple(buffer, num, offset);\n  } else {\n    utoa32_lut(buffer, num, offset);\n  }\n}\n\n@inline\nexport function utoa64_core(buffer: usize, num: u64, offset: u32): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_simple(buffer, num, offset);\n  } else {\n    utoa64_lut(buffer, num, offset);\n  }\n}\n\nexport function utoa32(value: u32): String {\n  if (!value) return \"0\";\n\n  var decimals = decimalCount32(value);\n  var buffer   = allocateUnsafeString(decimals);\n\n  utoa32_core(changetype<usize>(buffer), value, decimals);\n  return buffer;\n}\n\nexport function itoa32(value: i32): String {\n  if (!value) return \"0\";\n\n  var sign = value < 0;\n  if (sign) value = -value;\n\n  var decimals = decimalCount32(value) + <u32>sign;\n  var buffer   = allocateUnsafeString(decimals);\n\n  utoa32_core(changetype<usize>(buffer), value, decimals);\n  if (sign) store<u16>(changetype<usize>(buffer), CharCode.MINUS, STRING_HEADER_SIZE);\n\n  return buffer;\n}\n\nexport function utoa64(value: u64): String {\n  if (!value) return \"0\";\n\n  var buffer: String;\n  if (value <= u32.MAX_VALUE) {\n    let val32    = <u32>value;\n    let decimals = decimalCount32(val32);\n    buffer = allocateUnsafeString(decimals);\n    utoa32_core(changetype<usize>(buffer), val32, decimals);\n  } else {\n    let decimals = decimalCount64(value);\n    buffer = allocateUnsafeString(decimals);\n    utoa64_core(changetype<usize>(buffer), value, decimals);\n  }\n  return buffer;\n}\n\nexport function itoa64(value: i64): String {\n  if (!value) return \"0\";\n\n  var sign = value < 0;\n  if (sign) value = -value;\n\n  var buffer: String;\n  if (<u64>value <= <u64>u32.MAX_VALUE) {\n    let val32    = <u32>value;\n    let decimals = decimalCount32(val32) + <u32>sign;\n    buffer = allocateUnsafeString(decimals);\n    utoa32_core(changetype<usize>(buffer), val32, decimals);\n  } else {\n    let decimals = decimalCount64(value) + <u32>sign;\n    buffer = allocateUnsafeString(decimals);\n    utoa64_core(changetype<usize>(buffer), value, decimals);\n  }\n  if (sign) store<u16>(changetype<usize>(buffer), CharCode.MINUS, STRING_HEADER_SIZE);\n\n  return buffer;\n}\n\nexport function itoa<T>(value: T): String {\n  if (!isInteger<T>()) {\n    assert(false); // unexpecteble non-integer generic type\n  } else {\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        return itoa32(<i32>value);\n      } else {\n        return itoa64(<i64>value);\n      }\n    } else {\n      if (sizeof<T>() <= 4) {\n        return utoa32(<u32>value);\n      } else {\n        return utoa64(<u64>value);\n      }\n    }\n  }\n}\n\n@lazy var _K: i32 = 0;\n// @lazy var _frc: u64 = 0;\n@lazy var _exp: i32 = 0;\n@lazy var _frc_minus: u64 = 0;\n@lazy var _frc_plus:  u64 = 0;\n@lazy var _frc_pow: u64 = 0;\n@lazy var _exp_pow: i32 = 0;\n\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  var u0 = u & 0xFFFFFFFF;\n  var v0 = v & 0xFFFFFFFF;\n\n  var u1 = u >> 32;\n  var v1 = v >> 32;\n\n  var l = u0 * v0;\n  var t = u1 * v0 + (l >> 32);\n  var w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  var frc = (f << 1) + 1;\n  var exp = e - 1;\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var m = 1 + <i32>(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  var lastp = buffer + ((len - 1) << 1);\n  var digit = load<u16>(lastp, STRING_HEADER_SIZE);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit, STRING_HEADER_SIZE);\n}\n\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  var dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  var k = <i32>dk;\n      k += <i32>(k != dk); // conversion with ceil\n\n  var index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  var frcPowers = <ArrayBuffer>FRC_POWERS.buffer_;\n  var expPowers = <ArrayBuffer>EXP_POWERS.buffer_;\n  _frc_pow = LOAD<u64>(frcPowers, index);\n  _exp_pow = LOAD<i16,i32>(expPowers, index);\n}\n\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  var uv  = reinterpret<u64>(value);\n  var exp = <i32>((uv & 0x7FF0000000000000) >>> 52);\n  var sid = uv & 0x000FFFFFFFFFFFFF;\n  var frc = (<u64>(exp != 0) << 52) + sid;\n      exp = select<i32>(exp, 1, exp != 0) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var frc_pow = _frc_pow;\n  var exp_pow = _exp_pow;\n\n  var w_frc = umul64f(frc, frc_pow);\n  var w_exp = umul64e(exp, exp_pow);\n\n  var wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  var wp_exp = umul64e(_exp,      exp_pow);\n\n  var wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  var delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  var one_exp = -mp_exp;\n  var one_frc = (<u64>1) << one_exp;\n  var mask    = one_frc - 1;\n\n  var wp_w_frc = mp_frc - w_frc;\n  var wp_w_exp = mp_exp;\n\n  var p1 = <u32>(mp_frc >> one_exp);\n  var p2 = mp_frc & mask;\n\n  var kappa = <i32>decimalCount32(p1);\n  var len = sign;\n\n  var powers10 = <ArrayBuffer>POWERS10.buffer_;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d, STRING_HEADER_SIZE);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, LOAD<u32,u64>(powers10, kappa) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (1) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d, STRING_HEADER_SIZE);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= LOAD<u32,u64>(powers10, -kappa);\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n\n  return len;\n}\n\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  var sign = k < 0;\n  if (sign) k = -k;\n  var decimals = decimalCount32(k) + 1;\n  utoa32_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign), STRING_HEADER_SIZE);\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16), STRING_HEADER_SIZE);\n    return length + 2;\n  }\n\n  var kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0, STRING_HEADER_SIZE);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16), STRING_HEADER_SIZE);\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + STRING_HEADER_SIZE + 2,\n      ptr + STRING_HEADER_SIZE,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT, STRING_HEADER_SIZE);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + STRING_HEADER_SIZE + (offset << 1),\n      buffer + STRING_HEADER_SIZE,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16), STRING_HEADER_SIZE);\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0, STRING_HEADER_SIZE);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, STRING_HEADER_SIZE + 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + STRING_HEADER_SIZE + 4,\n      buffer + STRING_HEADER_SIZE + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, STRING_HEADER_SIZE + 2);\n    store<u16>(buffer + len, CharCode.e,   STRING_HEADER_SIZE + 2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nexport function dtoa_core(buffer: usize, value: f64): i32 {\n  var sign = <i32>(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS, STRING_HEADER_SIZE);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  var len = grisu2(value, buffer, sign);\n      len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite(value)) {\n    if (isNaN(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  var buffer = allocateUnsafeString(MAX_DOUBLE_LENGTH);\n  var length = dtoa_core(changetype<usize>(buffer), value);\n  var result = buffer.substring(0, length);\n  freeUnsafeString(buffer);\n  return result;\n}\n\nexport function itoa_stream<T>(buffer: usize, offset: usize, value: T): u32 {\n  buffer += (offset << 1);\n  if (!value) {\n    store<u16>(buffer, CharCode._0, STRING_HEADER_SIZE);\n    return 1;\n  }\n  var decimals: u32 = 0;\n  if (isSigned<T>()) {\n    let sign = value < 0;\n    if (sign) value = -value;\n    if (sizeof<T>() <= 4) {\n      decimals = decimalCount32(value) + <u32>sign;\n      utoa32_core(buffer, value, decimals);\n    } else {\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\n        let val32 = <u32>value;\n        decimals = decimalCount32(val32) + <u32>sign;\n        utoa32_core(buffer, val32, decimals);\n      } else {\n        decimals = decimalCount64(value) + <u32>sign;\n        utoa64_core(buffer, value, decimals);\n      }\n    }\n    if (sign) store<u16>(buffer, CharCode.MINUS, STRING_HEADER_SIZE);\n  } else {\n    if (sizeof<T>() <= 4) {\n      decimals = decimalCount32(value);\n      utoa32_core(buffer, value, decimals);\n    } else {\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\n        let val32 = <u32>value;\n        decimals = decimalCount32(val32);\n        utoa32_core(buffer, val32, decimals);\n      } else {\n        decimals = decimalCount64(value);\n        utoa64_core(buffer, value, decimals);\n      }\n    }\n  }\n  return decimals;\n}\n\nexport function dtoa_stream(buffer: usize, offset: usize, value: f64): u32 {\n  buffer += (offset << 1);\n  if (value == 0.0) {\n    store<u16>(buffer, CharCode._0,  STRING_HEADER_SIZE + 0);\n    store<u16>(buffer, CharCode.DOT, STRING_HEADER_SIZE + 2);\n    store<u16>(buffer, CharCode._0,  STRING_HEADER_SIZE + 4);\n    return 3;\n  }\n  if (!isFinite(value)) {\n    if (isNaN(value)) {\n      store<u16>(buffer, CharCode.N, STRING_HEADER_SIZE + 0);\n      store<u16>(buffer, CharCode.a, STRING_HEADER_SIZE + 2);\n      store<u16>(buffer, CharCode.N, STRING_HEADER_SIZE + 4);\n      return 3;\n    } else {\n      let sign = <i32>(value < 0);\n      let len  = 8 + sign;\n      let source = changetype<usize>(select<String>(\"-Infinity\", \"Infinity\", sign));\n      memory.copy(buffer + STRING_HEADER_SIZE, source + STRING_HEADER_SIZE, len << 1);\n      return len;\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n","/* tslint:disable */\n\n@builtin @inline export const NaN: f64 = 0 / 0;\n@builtin @inline export const Infinity: f64 = 1 / 0;\n\n@builtin export declare function isInteger<T>(value?: T): bool;\n@builtin export declare function isFloat<T>(value?: T): bool;\n@builtin export declare function isSigned<T>(value?: T): bool;\n@builtin export declare function isReference<T>(value?: T): bool;\n@builtin export declare function isString<T>(value?: T): bool;\n@builtin export declare function isArray<T>(value?: T): bool;\n@builtin export declare function isArrayLike<T>(value?: T): bool;\n@builtin export declare function isFunction<T>(value?: T): bool;\n@builtin export declare function isNullable<T>(value?: T): bool;\n@builtin export declare function isDefined(expression: void): bool;\n@builtin export declare function isConstant(expression: void): bool;\n@builtin export declare function isManaged<T>(value?: T): bool;\n@inline export function isNaN<T>(value: T): bool { return value != value; }\n@inline export function isFinite<T>(value: T): bool { return value - value == 0; }\n\n@builtin export declare function clz<T>(value: T): T;\n@builtin export declare function ctz<T>(value: T): T;\n@builtin export declare function popcnt<T>(value: T): T;\n@builtin export declare function rotl<T>(value: T, shift: T): T;\n@builtin export declare function rotr<T>(value: T, shift: T): T;\n@builtin export declare function abs<T>(value: T): T;\n@builtin export declare function max<T>(left: T, right: T): T;\n@builtin export declare function min<T>(left: T, right: T): T;\n@builtin export declare function ceil<T>(value: T): T;\n@builtin export declare function floor<T>(value: T): T;\n@builtin export declare function copysign<T>(left: T, right: T): T;\n@builtin export declare function nearest<T>(value: T): T;\n@builtin export declare function reinterpret<T>(value: void): T;\n@builtin export declare function sqrt<T>(value: T): T;\n@builtin export declare function trunc<T>(value: T): T;\n@builtin export declare function load<T>(offset: usize, immOffset?: usize, immAlign?: usize): T;\n@builtin export declare function store<T>(offset: usize, value: void, immOffset?: usize, immAlign?: usize): void;\n@builtin export declare function sizeof<T>(): usize; // | u32 / u64\n@builtin export declare function alignof<T>(): usize; // | u32 / u64\n@builtin export declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n@builtin export declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n@builtin export declare function unreachable(): void;\n@builtin export declare function changetype<T>(value: void): T;\n@builtin export declare function assert<T>(isTrueish: T, message?: string): T;\n@builtin export declare function unchecked<T>(expr: T): T;\n@builtin export declare function call_indirect<T>(target: void, ...args: void[]): T;\n@builtin export declare function instantiate<T>(...args: void[]): T;\n\nexport namespace atomic {\n  @builtin export declare function load<T>(offset: usize, immOffset?: usize): T;\n  @builtin export declare function store<T>(offset: usize, value: T, immOffset?: usize): void;\n  @builtin export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n  @builtin export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n  @builtin export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n  @builtin export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n  @builtin export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n  @builtin export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n  @builtin export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n  @builtin export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n  @builtin export declare function notify(ptr: usize, count: i32): i32;\n}\n\n@lazy export const enum AtomicWaitResult {\n  OK = 0,\n  NOT_EQUAL = 1,\n  TIMED_OUT = 2\n}\n\n@builtin export declare function i8(value: void): i8;\nexport namespace i8 {\n  @lazy export const MIN_VALUE: i8 = -128;\n  @lazy export const MAX_VALUE: i8 =  127;\n}\n\n@builtin export declare function i16(value: void): i16;\nexport namespace i16 {\n  @lazy export const MIN_VALUE: i16 = -32768;\n  @lazy export const MAX_VALUE: i16 =  32767;\n}\n\n@builtin export declare function i32(value: void): i32;\nexport namespace i32 {\n  @lazy export const MIN_VALUE: i32 = -2147483648;\n  @lazy export const MAX_VALUE: i32 =  2147483647;\n  @builtin export declare function clz(value: i32): i32;\n  @builtin export declare function ctz(value: i32): i32;\n  @builtin export declare function popcnt(value: i32): i32;\n  @builtin export declare function rotl(value: i32, shift: i32): i32;\n  @builtin export declare function rotr(value: i32, shift: i32): i32;\n  @builtin export declare function reinterpret_f32(value: f32): i32;\n  @builtin export declare function load8_s(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n  @builtin export declare function load8_u(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n  @builtin export declare function load16_s(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n  @builtin export declare function load16_u(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n  @builtin export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n  @builtin export declare function store8(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function store16(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function store(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n  \n  export namespace atomic {\n    @builtin export declare function load8_u(offset: usize, immOffset?: usize): i32;\n    @builtin export declare function load16_u(offset: usize, immOffset?: usize): i32;\n    @builtin export declare function load(offset: usize, immOffset?: usize): i32;\n    @builtin export declare function store8(offset: usize, value: i32, immOffset?: usize): void;\n    @builtin export declare function store16(offset: usize, value: i32, immOffset?: usize): void;\n    @builtin export declare function store(offset: usize, value: i32, immOffset?: usize): void;\n    @builtin export declare function wait(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n      @builtin export declare function add_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function sub_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function and_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function or_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function xor_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function xchg_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n    export namespace rmw16 {\n      @builtin export declare function add_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function sub_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function and_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function or_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function xor_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function xchg_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n    export namespace rmw {\n      @builtin export declare function add(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function sub(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function and(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function or(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function xor(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function xchg(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function cmpxchg(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n\n@builtin export declare function i64(value: void): i64;\nexport namespace i64 {\n  @lazy export const MIN_VALUE: i64 = -9223372036854775808;\n  @lazy export const MAX_VALUE: i64 =  9223372036854775807;\n  @builtin export declare function clz(value: i64): i64;\n  @builtin export declare function ctz(value: i64): i64;\n  @builtin export declare function load8_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  @builtin export declare function load8_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  @builtin export declare function load16_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  @builtin export declare function load16_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  @builtin export declare function load32_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  @builtin export declare function load32_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  @builtin export declare function load(offset: usize, immOffset?: usize): i64;\n  @builtin export declare function popcnt(value: i64): i64;\n  @builtin export declare function rotl(value: i64, shift: i64): i64;\n  @builtin export declare function rotr(value: i64, shift: i64): i64;\n  @builtin export declare function reinterpret_f64(value: f64): i64;\n  @builtin export declare function store8(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function store16(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function store32(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function store(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n    @builtin export declare function load8_u(offset: usize, immOffset?: usize): i64;\n    @builtin export declare function load16_u(offset: usize, immOffset?: usize): i64;\n    @builtin export declare function load32_u(offset: usize, immOffset?: usize): i64;\n    @builtin export declare function load(offset: usize, immOffset?: usize): i64;\n    @builtin export declare function store8(offset: usize, value: i64, immOffset?: usize): void;\n    @builtin export declare function store16(offset: usize, value: i64, immOffset?: usize): void;\n    @builtin export declare function store32(offset: usize, value: i64, immOffset?: usize): void;\n    @builtin export declare function store(offset: usize, value: i64, immOffset?: usize): void;\n    @builtin export declare function wait(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n      @builtin export declare function add_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function and_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function or_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n    export namespace rmw16 {\n      @builtin export declare function add_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function and_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function or_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n    export namespace rmw32 {\n      @builtin export declare function add_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function and_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function or_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n    export namespace rmw {\n      @builtin export declare function add(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function sub(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function and(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function or(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xor(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xchg(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function cmpxchg(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n\n@builtin export declare function isize(value: void): isize;\nexport namespace isize {\n  @lazy export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n  @lazy export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n}\n\n@builtin export declare function u8(value: void): u8;\nexport namespace u8 {\n  @lazy export const MIN_VALUE: u8 = 0;\n  @lazy export const MAX_VALUE: u8 = 255;\n}\n\n@builtin export declare function u16(value: void): u16;\nexport namespace u16 {\n  @lazy export const MIN_VALUE: u16 = 0;\n  @lazy export const MAX_VALUE: u16 = 65535;\n}\n\n@builtin export declare function u32(value: void): u32;\nexport namespace u32 {\n  @lazy export const MIN_VALUE: u32 = 0;\n  @lazy export const MAX_VALUE: u32 = 4294967295;\n}\n\n@builtin export declare function u64(value: void): u64;\nexport namespace u64 {\n  @lazy export const MIN_VALUE: u64 = 0;\n  @lazy export const MAX_VALUE: u64 = 18446744073709551615;\n}\n\n@builtin export declare function usize(value: void): usize;\nexport namespace usize {\n  @lazy export const MIN_VALUE: usize = 0;\n  @lazy export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n}\n\n@builtin export declare function bool(value: void): bool;\nexport namespace bool {\n  @lazy export const MIN_VALUE: bool = false;\n  @lazy export const MAX_VALUE: bool = true;\n}\n\n@builtin export declare function f32(value: void): f32;\nexport namespace f32 {\n  @lazy export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n  @lazy export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n  @lazy export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n  @lazy export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n  @lazy export const MIN_SAFE_INTEGER: f32 = -16777215;\n  @lazy export const MAX_SAFE_INTEGER: f32 =  16777215;\n  @builtin export declare function abs(value: f32): f32;\n  @builtin export declare function ceil(value: f32): f32;\n  @builtin export declare function copysign(x: f32, y: f32): f32;\n  @builtin export declare function floor(value: f32): f32;\n  @builtin export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): f32;\n  @builtin export declare function max(left: f32, right: f32): f32;\n  @builtin export declare function min(left: f32, right: f32): f32;\n  @builtin export declare function nearest(value: f32): f32;\n  @builtin export declare function reinterpret_i32(value: i32): f32;\n  @builtin export declare function sqrt(value: f32): f32;\n  @builtin export declare function store(offset: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function trunc(value: f32): f32;\n}\n\n@builtin export declare function f64(value: void): f64;\nexport namespace f64 {\n  @lazy export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n  @lazy export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n  @lazy export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n  @lazy export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n  @lazy export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n  @lazy export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n  @builtin export declare function abs(value: f64): f64;\n  @builtin export declare function ceil(value: f64): f64;\n  @builtin export declare function copysign(x: f64, y: f64): f64;\n  @builtin export declare function floor(value: f64): f64;\n  @builtin export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): f64;\n  @builtin export declare function max(left: f64, right: f64): f64;\n  @builtin export declare function min(left: f64, right: f64): f64;\n  @builtin export declare function nearest(value: f64): f64;\n  @builtin export declare function reinterpret_i64(value: i64): f64;\n  @builtin export declare function sqrt(value: f64): f64;\n  @builtin export declare function store(offset: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function trunc(value: f64): f64;\n}\n\n@builtin export declare function v128(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8, i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8): v128;\nexport namespace v128 {\n  @builtin export declare function splat<T>(x: T): v128;\n  @builtin export declare function extract_lane<T>(x: v128, idx: u8): T;\n  @builtin export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n  @builtin export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n  @builtin export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): v128;\n  @builtin export declare function store(offset: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function add<T>(a: v128, b: v128): v128;\n  @builtin export declare function sub<T>(a: v128, b: v128): v128;\n  @builtin export declare function mul<T>(a: v128, b: v128): v128; // except i64\n  @builtin export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\n  @builtin export declare function neg<T>(a: v128): v128;\n  @builtin export declare function add_saturate<T>(a: v128, b: v128): v128;\n  @builtin export declare function sub_saturate<T>(a: v128, b: v128): v128;\n  @builtin export declare function shl<T>(a: v128, b: i32): v128;\n  @builtin export declare function shr<T>(a: v128, b: i32): v128;\n  @builtin export declare function and(a: v128, b: v128): v128;\n  @builtin export declare function or(a: v128, b: v128): v128;\n  @builtin export declare function xor(a: v128, b: v128): v128;\n  @builtin export declare function not(a: v128): v128;\n  @builtin export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\n  @builtin export declare function any_true<T>(a: v128): bool;\n  @builtin export declare function all_true<T>(a: v128): bool;\n  @builtin export declare function min<T>(a: v128, b: v128): v128; // f32, f64 only\n  @builtin export declare function max<T>(a: v128, b: v128): v128; // f32, f64 only\n  @builtin export declare function abs<T>(a: v128): v128; // f32, f64 only\n  @builtin export declare function sqrt<T>(a: v128): v128; // f32, f64 only\n  @builtin export declare function eq<T>(a: v128, b: v128): v128;\n  @builtin export declare function ne<T>(a: v128, b: v128): v128;\n  @builtin export declare function lt<T>(a: v128, b: v128): v128;\n  @builtin export declare function le<T>(a: v128, b: v128): v128;\n  @builtin export declare function gt<T>(a: v128, b: v128): v128;\n  @builtin export declare function ge<T>(a: v128, b: v128): v128;\n  @builtin export declare function convert<T>(a: v128): v128;\n  @builtin export declare function trunc<T>(a: v128): v128;\n}\n\n@builtin export declare function i8x16(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8, i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8): v128;\nexport namespace i8x16 {\n  @builtin export declare function splat(x: i8): v128;\n  @builtin export declare function extract_lane_s(x: v128, idx: u8): i8;\n  @builtin export declare function extract_lane_u(x: v128, idx: u8): u8;\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\n  @builtin export declare function add(a: v128, b: v128): v128;\n  @builtin export declare function sub(a: v128, b: v128): v128;\n  @builtin export declare function mul(a: v128, b: v128): v128;\n  @builtin export declare function neg(a: v128): v128;\n  @builtin export declare function add_saturate_s(a: v128, b: v128): v128;\n  @builtin export declare function add_saturate_u(a: v128, b: v128): v128;\n  @builtin export declare function sub_saturate_s(a: v128, b: v128): v128;\n  @builtin export declare function sub_saturate_u(a: v128, b: v128): v128;\n  @builtin export declare function shl(a: v128, b: i32): v128;\n  @builtin export declare function shr_s(a: v128, b: i32): v128;\n  @builtin export declare function shr_u(a: v128, b: i32): v128;\n  @builtin export declare function any_true(a: v128): bool;\n  @builtin export declare function all_true(a: v128): bool;\n  @builtin export declare function eq(a: v128, b: v128): v128;\n  @builtin export declare function ne(a: v128, b: v128): v128;\n  @builtin export declare function lt_s(a: v128, b: v128): v128;\n  @builtin export declare function lt_u(a: v128, b: v128): v128;\n  @builtin export declare function le_s(a: v128, b: v128): v128;\n  @builtin export declare function le_u(a: v128, b: v128): v128;\n  @builtin export declare function gt_s(a: v128, b: v128): v128;\n  @builtin export declare function gt_u(a: v128, b: v128): v128;\n  @builtin export declare function ge_s(a: v128, b: v128): v128;\n  @builtin export declare function ge_u(a: v128, b: v128): v128;\n}\n\n@builtin export declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\nexport namespace i16x8 {\n  @builtin export declare function splat(x: i16): v128;\n  @builtin export declare function extract_lane_s(x: v128, idx: u8): i16;\n  @builtin export declare function extract_lane_u(x: v128, idx: u8): u16;\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\n  @builtin export declare function add(a: v128, b: v128): v128;\n  @builtin export declare function sub(a: v128, b: v128): v128;\n  @builtin export declare function mul(a: v128, b: v128): v128;\n  @builtin export declare function neg(a: v128): v128;\n  @builtin export declare function add_saturate_s(a: v128, b: v128): v128;\n  @builtin export declare function add_saturate_u(a: v128, b: v128): v128;\n  @builtin export declare function sub_saturate_s(a: v128, b: v128): v128;\n  @builtin export declare function sub_saturate_u(a: v128, b: v128): v128;\n  @builtin export declare function shl(a: v128, b: i32): v128;\n  @builtin export declare function shr_s(a: v128, b: i32): v128;\n  @builtin export declare function shr_u(a: v128, b: i32): v128;\n  @builtin export declare function any_true(a: v128): bool;\n  @builtin export declare function all_true(a: v128): bool;\n  @builtin export declare function eq(a: v128, b: v128): v128;\n  @builtin export declare function ne(a: v128, b: v128): v128;\n  @builtin export declare function lt_s(a: v128, b: v128): v128;\n  @builtin export declare function lt_u(a: v128, b: v128): v128;\n  @builtin export declare function le_s(a: v128, b: v128): v128;\n  @builtin export declare function le_u(a: v128, b: v128): v128;\n  @builtin export declare function gt_s(a: v128, b: v128): v128;\n  @builtin export declare function gt_u(a: v128, b: v128): v128;\n  @builtin export declare function ge_s(a: v128, b: v128): v128;\n  @builtin export declare function ge_u(a: v128, b: v128): v128;\n}\n\n@builtin export declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\nexport namespace i32x4 {\n  @builtin export declare function splat(x: i32): v128;\n  @builtin export declare function extract_lane(x: v128, idx: u8): i32;\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\n  @builtin export declare function add(a: v128, b: v128): v128;\n  @builtin export declare function sub(a: v128, b: v128): v128;\n  @builtin export declare function mul(a: v128, b: v128): v128;\n  @builtin export declare function neg(a: v128): v128;\n  @builtin export declare function shl(a: v128, b: i32): v128;\n  @builtin export declare function shr_s(a: v128, b: i32): v128;\n  @builtin export declare function shr_u(a: v128, b: i32): v128;\n  @builtin export declare function any_true(a: v128): bool;\n  @builtin export declare function all_true(a: v128): bool;\n  @builtin export declare function eq(a: v128, b: v128): v128;\n  @builtin export declare function ne(a: v128, b: v128): v128;\n  @builtin export declare function lt_s(a: v128, b: v128): v128;\n  @builtin export declare function lt_u(a: v128, b: v128): v128;\n  @builtin export declare function le_s(a: v128, b: v128): v128;\n  @builtin export declare function le_u(a: v128, b: v128): v128;\n  @builtin export declare function gt_s(a: v128, b: v128): v128;\n  @builtin export declare function gt_u(a: v128, b: v128): v128;\n  @builtin export declare function ge_s(a: v128, b: v128): v128;\n  @builtin export declare function ge_u(a: v128, b: v128): v128;\n  @builtin export declare function trunc_s_f32x4_sat(a: v128): v128;\n  @builtin export declare function trunc_u_f32x4_sat(a: v128): v128;\n}\n\n@builtin export declare function i64x2(a: i64, b: i64): v128;\nexport namespace i64x2 {\n  @builtin export declare function splat(x: i64): v128;\n  @builtin export declare function extract_lane(x: v128, idx: u8): i64;\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\n  @builtin export declare function add(a: v128, b: v128): v128;\n  @builtin export declare function sub(a: v128, b: v128): v128;\n  @builtin export declare function mul(a: v128, b: v128): v128;\n  @builtin export declare function neg(a: v128): v128;\n  @builtin export declare function shl(a: v128, b: i32): v128;\n  @builtin export declare function shr_s(a: v128, b: i32): v128;\n  @builtin export declare function shr_u(a: v128, b: i32): v128;\n  @builtin export declare function any_true(a: v128): bool;\n  @builtin export declare function all_true(a: v128): bool;\n  @builtin export declare function trunc_s_f64x2_sat(a: v128): v128;\n  @builtin export declare function trunc_u_f64x2_sat(a: v128): v128;\n}\n\n@builtin export declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\nexport namespace f32x4 {\n  @builtin export declare function splat(x: f32): v128;\n  @builtin export declare function extract_lane(x: v128, idx: u8): f32;\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\n  @builtin export declare function add(a: v128, b: v128): v128;\n  @builtin export declare function sub(a: v128, b: v128): v128;\n  @builtin export declare function mul(a: v128, b: v128): v128;\n  @builtin export declare function div(a: v128, b: v128): v128;\n  @builtin export declare function neg(a: v128): v128;\n  @builtin export declare function min(a: v128, b: v128): v128;\n  @builtin export declare function max(a: v128, b: v128): v128;\n  @builtin export declare function abs(a: v128): v128;\n  @builtin export declare function sqrt(a: v128): v128;\n  @builtin export declare function eq(a: v128, b: v128): v128;\n  @builtin export declare function ne(a: v128, b: v128): v128;\n  @builtin export declare function lt(a: v128, b: v128): v128;\n  @builtin export declare function le(a: v128, b: v128): v128;\n  @builtin export declare function gt(a: v128, b: v128): v128;\n  @builtin export declare function ge(a: v128, b: v128): v128;\n  @builtin export declare function convert_s_i32x4(a: v128): v128;\n  @builtin export declare function convert_u_i32x4(a: v128): v128;\n}\n\n@builtin export declare function f64x2(a: f64, b: f64): v128;\nexport namespace f64x2 {\n  @builtin export declare function splat(x: f64): v128;\n  @builtin export declare function extract_lane(x: v128, idx: u8): f64;\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\n  @builtin export declare function add(a: v128, b: v128): v128;\n  @builtin export declare function sub(a: v128, b: v128): v128;\n  @builtin export declare function mul(a: v128, b: v128): v128;\n  @builtin export declare function div(a: v128, b: v128): v128;\n  @builtin export declare function neg(a: v128): v128;\n  @builtin export declare function min(a: v128, b: v128): v128;\n  @builtin export declare function max(a: v128, b: v128): v128;\n  @builtin export declare function abs(a: v128): v128;\n  @builtin export declare function sqrt(a: v128): v128;\n  @builtin export declare function eq(a: v128, b: v128): v128;\n  @builtin export declare function ne(a: v128, b: v128): v128;\n  @builtin export declare function lt(a: v128, b: v128): v128;\n  @builtin export declare function le(a: v128, b: v128): v128;\n  @builtin export declare function gt(a: v128, b: v128): v128;\n  @builtin export declare function ge(a: v128, b: v128): v128;\n  @builtin export declare function convert_s_i64x2(a: v128): v128;\n  @builtin export declare function convert_u_i64x2(a: v128): v128;\n}\n\nexport namespace v8x16 {\n  @builtin export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8, l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8): v128;\n}\n\n@builtin export declare function start(): void;\n","import {\n  HEADER_SIZE,\n  MAX_BLENGTH,\n  allocateUnsafe\n} from \"./internal/arraybuffer\";\n\nimport {\n  Uint8ClampedArray,\n  Uint8Array,\n  Int8Array,\n  Uint16Array,\n  Int16Array,\n  Uint32Array,\n  Int32Array,\n  Uint64Array,\n  Int64Array\n} from \"./typedarray\";\n\nimport {\n  DataView\n} from \"./dataview\";\n\n@sealed\nexport class ArrayBuffer {\n\n  readonly byteLength: i32; // capped to [0, MAX_LENGTH]\n\n  @inline static isView<T>(value: T): bool {\n    if (value === null) return false;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  // @unsafe\n  @inline get data(): usize { return changetype<usize>(this) + HEADER_SIZE; }\n\n  constructor(length: i32, unsafe: bool = false) {\n    if (<u32>length > <u32>MAX_BLENGTH) throw new RangeError(\"Invalid array buffer length\");\n    var buffer = allocateUnsafe(length);\n    if (!unsafe) memory.fill(changetype<usize>(buffer) + HEADER_SIZE, 0, <usize>length);\n    return buffer;\n  }\n\n  slice(begin: i32 = 0, end: i32 = MAX_BLENGTH): ArrayBuffer {\n    var len = this.byteLength;\n    begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\n    end = end < 0 ? max(len + end, 0) : min(end, len);\n    len = max(end - begin, 0);\n    var buffer = allocateUnsafe(len);\n    memory.copy(\n      changetype<usize>(buffer) + HEADER_SIZE,\n      changetype<usize>(this) + HEADER_SIZE + begin,\n      len\n    );\n    return buffer;\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","import {\n  MAX_BLENGTH,\n  HEADER_SIZE,\n  allocateUnsafe,\n  reallocateUnsafe,\n  LOAD,\n  STORE\n} from \"./internal/arraybuffer\";\n\nimport {\n  allocateUnsafe as allocateUnsafeString,\n  freeUnsafe as freeUnsafeString,\n  copyUnsafe as copyUnsafeString\n} from \"./internal/string\";\n\nimport {\n  COMPARATOR,\n  SORT\n} from \"./internal/sort\";\n\nimport {\n  itoa,\n  dtoa,\n  itoa_stream,\n  dtoa_stream,\n  MAX_DOUBLE_LENGTH\n} from \"./internal/number\";\n\nimport {\n  isArray as builtin_isArray\n} from \"./builtins\";\n\nexport class Array<T> {\n  [key: number]: T; // compatibility only\n\n  /* @internal */ buffer_: ArrayBuffer;\n  /* @internal */ length_: i32;\n\n  @inline static isArray<U>(value: U): bool {\n    return builtin_isArray(value) && value !== null;\n  }\n\n  constructor(length: i32 = 0) {\n    const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n    if (<u32>length > <u32>MAX_LENGTH) throw new RangeError(\"Invalid array length\");\n    var byteLength = length << alignof<T>();\n    var buffer = allocateUnsafe(byteLength);\n    this.buffer_ = buffer;\n    this.length_ = length;\n    memory.fill(\n      changetype<usize>(buffer) + HEADER_SIZE,\n      0,\n      <usize>byteLength\n    );\n  }\n\n  @inline\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(length: i32) {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    if (<u32>length > <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length > <u32>MAX_LENGTH) throw new RangeError(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, length << alignof<T>());\n      this.buffer_ = buffer;\n    }\n    this.length_ = length;\n  }\n\n  every(callbackfn: (element: T, index: i32, array: Array<T>) => bool): bool {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (!callbackfn(LOAD<T>(this.buffer_, index), index, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(predicate: (element: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (predicate(LOAD<T>(this.buffer_, index), index, this)) return index;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): T {\n    var buffer = this.buffer_;\n    return <u32>index < <u32>(buffer.byteLength >>> alignof<T>())\n      ? LOAD<T>(buffer, index)\n      : <T>unreachable();\n  }\n\n  @operator(\"{}\")\n  private __unchecked_get(index: i32): T {\n    return LOAD<T>(this.buffer_, index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: T): void {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    if (<u32>index >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>index >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, (index + 1) << alignof<T>());\n      this.buffer_ = buffer;\n      this.length_ = index + 1;\n    }\n    STORE<T>(buffer, index, value);\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\n  }\n\n  @operator(\"{}=\")\n  private __unchecked_set(index: i32, value: T): void {\n    STORE<T>(this.buffer_, index, value);\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\n    var buffer = this.buffer_;\n    var len    = this.length_;\n\n    start = start < 0 ? max(len + start, 0) : min(start, len);\n    end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n\n    if (sizeof<T>() == 1) {\n      if (start < end) {\n        memory.fill(\n          changetype<usize>(buffer) + start + HEADER_SIZE,\n          <u8>value,\n          <usize>(end - start)\n        );\n      }\n    } else {\n      for (; start < end; ++start) {\n        STORE<T>(buffer, start, value);\n      }\n    }\n    return this;\n  }\n\n  @inline\n  includes(searchElement: T, fromIndex: i32 = 0): bool {\n    return this.indexOf(searchElement, fromIndex) >= 0;\n  }\n\n  indexOf(searchElement: T, fromIndex: i32 = 0): i32 {\n    var length = this.length_;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    var buffer = this.buffer_;\n    while (fromIndex < length) {\n      if (LOAD<T>(buffer, fromIndex) == searchElement) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(searchElement: T, fromIndex: i32 = this.length_): i32 {\n    var length = this.length_;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex; // no need to clamp\n    else if (fromIndex >= length) fromIndex = length - 1;\n    var buffer = this.buffer_;\n    while (fromIndex >= 0) {                           // ^\n      if (LOAD<T>(buffer, fromIndex) == searchElement) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(element: T): i32 {\n    var length = this.length_;\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    var newLength = length + 1; // safe only if length is checked\n    if (<u32>length >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, newLength << alignof<T>());\n      this.buffer_ = buffer;\n    }\n    this.length_ = newLength;\n    STORE<T>(buffer, length, element);\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(element)); // tslint:disable-line\n    return newLength;\n  }\n\n  concat(items: Array<T>): Array<T> {\n    var thisLen = this.length_;\n    var otherLen = select(0, items.length_, items === null);\n    var outLen = thisLen + otherLen;\n    var out = new Array<T>(outLen);\n\n    if (thisLen) {\n      memory.copy(\n        changetype<usize>(out.buffer_)  + HEADER_SIZE,\n        changetype<usize>(this.buffer_) + HEADER_SIZE,\n        <usize>thisLen << alignof<T>()\n      );\n    }\n    if (otherLen) {\n      memory.copy(\n        changetype<usize>(out.buffer_)   + HEADER_SIZE + (<usize>thisLen << alignof<T>()),\n        changetype<usize>(items.buffer_) + HEADER_SIZE,\n        <usize>otherLen << alignof<T>()\n      );\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\n    var buffer = this.buffer_;\n    var len = this.length_;\n\n        end   = min<i32>(end, len);\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\n    var count = min(last - from, len - to);\n\n    if (from < to && to < (from + count)) {\n      from += count - 1;\n      to   += count - 1;\n      while (count) {\n        STORE<T>(buffer, to, LOAD<T>(buffer, from));\n        --from, --to, --count;\n      }\n    } else {\n      memory.copy(\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>to << alignof<T>()),\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>from << alignof<T>()),\n        <usize>count << alignof<T>()\n      );\n    }\n    return this;\n  }\n\n  pop(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(\"Array is empty\");\n    var element = LOAD<T>(this.buffer_, --length);\n    this.length_ = length;\n    return element;\n  }\n\n  forEach(callbackfn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      callbackfn(LOAD<T>(this.buffer_, index), index, this);\n    }\n  }\n\n  map<U>(callbackfn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    var length = this.length_;\n    var result = new Array<U>(length);\n    var buffer = result.buffer_;\n    for (let index = 0; index < min(length, this.length_); ++index) {\n      STORE<U>(buffer, index, callbackfn(LOAD<T>(this.buffer_, index), index, this));\n    }\n    return result;\n  }\n\n  filter(callbackfn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    var result = new Array<T>();\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      let value = LOAD<T>(this.buffer_, index);\n      if (callbackfn(value, index, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      accum = callbackfn(accum, LOAD<T>(this.buffer_, index), index, this);\n    }\n    return accum;\n  }\n\n  reduceRight<U>(\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    for (let index = this.length_ - 1; index >= 0; --index) {\n      accum = callbackfn(accum, LOAD<T>(this.buffer_, index), index, this);\n    }\n    return accum;\n  }\n\n  shift(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(\"Array is empty\");\n    var buffer = this.buffer_;\n    var element = LOAD<T>(buffer, 0);\n    var lastIndex = length - 1;\n    memory.copy(\n      changetype<usize>(buffer) + HEADER_SIZE,\n      changetype<usize>(buffer) + HEADER_SIZE + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    STORE<T>(buffer, lastIndex, <T>null);\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(callbackfn: (element: T, index: i32, array: Array<T>) => bool): bool {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (callbackfn(LOAD<T>(this.buffer_, index), index, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(element: T): i32 {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    var length = this.length_;\n    var newLength = length + 1; // safe only if length is checked\n    if (<u32>length >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, newLength << alignof<T>());\n      capacity = buffer.byteLength >>> alignof<T>();\n      this.buffer_ = buffer;\n    }\n    memory.copy(\n      changetype<usize>(buffer) + HEADER_SIZE + sizeof<T>(),\n      changetype<usize>(buffer) + HEADER_SIZE,\n      <usize>(capacity - 1) << alignof<T>()\n    );\n    STORE<T>(buffer, 0, element);\n    this.length_ = newLength;\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(element)); // tslint:disable-line\n    return newLength;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var len = this.length_;\n    begin = begin < 0 ? max(begin + len, 0) : min(begin, len);\n    end = end < 0 ? max(end + len, 0) : min(end, len);\n    len = max(end - begin, 0);\n    var sliced = new Array<T>(len);\n    if (len) {\n      memory.copy(\n        changetype<usize>(sliced.buffer_) + HEADER_SIZE,\n        changetype<usize>(this.buffer_) + HEADER_SIZE + (<usize>begin << alignof<T>()),\n        <usize>len << alignof<T>()\n      );\n    }\n    return sliced;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    var length  = this.length_;\n    start       = start < 0 ? max<i32>(length + start, 0) : min<i32>(start, length);\n    deleteCount = max<i32>(min<i32>(deleteCount, length - start), 0);\n    var buffer  = this.buffer_;\n    var spliced = new Array<T>(deleteCount);\n    var source  = changetype<usize>(buffer) + HEADER_SIZE + (<usize>start << alignof<T>());\n    memory.copy(\n      changetype<usize>(spliced.buffer_) + HEADER_SIZE,\n      source,\n      <usize>deleteCount << alignof<T>()\n    );\n    var offset = start + deleteCount;\n    if (length != offset) {\n      memory.copy(\n        source,\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>offset << alignof<T>()),\n        <usize>(length - offset) << alignof<T>()\n      );\n    }\n    this.length_ = length - deleteCount;\n    return spliced;\n  }\n\n  reverse(): Array<T> {\n    var buffer = this.buffer_;\n    for (let front = 0, back = this.length_ - 1; front < back; ++front, --back) {\n      let temp = LOAD<T>(buffer, front);\n      STORE<T>(buffer, front, LOAD<T>(buffer, back));\n      STORE<T>(buffer, back, temp);\n    }\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\n    // TODO remove this when flow will allow trackcing null\n    assert(comparator); // The comparison function must be a function\n\n    var length = this.length_;\n    if (length <= 1) return this;\n    var buffer = this.buffer_;\n    if (length == 2) {\n      let a = LOAD<T>(buffer, 1); // a = arr[1]\n      let b = LOAD<T>(buffer, 0); // b = arr[0]\n      if (comparator(a, b) < 0) {\n        STORE<T>(buffer, 1, b);   // arr[1] = b;\n        STORE<T>(buffer, 0, a);   // arr[0] = a;\n      }\n      return this;\n    }\n    SORT<T>(buffer, 0, length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    var lastIndex = this.length_ - 1;\n    if (lastIndex < 0) return \"\";\n    var result = \"\";\n    var value: T;\n    var buffer = this.buffer_;\n    var sepLen = separator.length;\n    var hasSeparator = sepLen != 0;\n    if (value instanceof bool) {\n      if (!lastIndex) return select<string>(\"true\", \"false\", LOAD<T,bool>(buffer, 0));\n\n      let valueLen = 5; // max possible length of element len(\"false\")\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n      let result = allocateUnsafeString(estLen);\n      let offset = 0;\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T,bool>(buffer, i);\n        valueLen = 4 + <i32>(!value);\n        copyUnsafeString(result, offset, select<string>(\"true\", \"false\", value), 0, valueLen);\n        offset += valueLen;\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, changetype<String>(separator), 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      value = LOAD<T,bool>(buffer, lastIndex);\n      valueLen = 4 + <i32>(!value);\n      copyUnsafeString(result, offset, select<string>(\"true\", \"false\", value), 0, valueLen);\n      offset += valueLen;\n\n      let out = result;\n      if (estLen > offset) {\n        out = result.substring(0, offset);\n        freeUnsafeString(result);\n      }\n      return out;\n    } else if (isInteger<T>()) {\n      if (!lastIndex) return changetype<string>(itoa<T>(LOAD<T>(buffer, 0)));\n\n      const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + <i32>isSigned<T>();\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n      let result = allocateUnsafeString(estLen);\n      let offset = 0;\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T>(buffer, i);\n        offset += itoa_stream<T>(changetype<usize>(result), offset, value);\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, separator, 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      value = LOAD<T>(buffer, lastIndex);\n      offset += itoa_stream<T>(changetype<usize>(result), offset, value);\n      let out = result;\n      if (estLen > offset) {\n        out = result.substring(0, offset);\n        freeUnsafeString(result);\n      }\n      return out;\n    } else if (isFloat<T>()) {\n      if (!lastIndex) return changetype<string>(dtoa(LOAD<T,f64>(buffer, 0)));\n\n      const valueLen = MAX_DOUBLE_LENGTH;\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n      let result = allocateUnsafeString(estLen);\n      let offset = 0;\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T,f64>(buffer, i);\n        offset += dtoa_stream(changetype<usize>(result), offset, value);\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, separator, 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      value = LOAD<T,f64>(buffer, lastIndex);\n      offset += dtoa_stream(changetype<usize>(result), offset, value);\n      let out = result;\n      if (estLen > offset) {\n        out = result.substring(0, offset);\n        freeUnsafeString(result);\n      }\n      return out;\n    } else if (isString<T>()) {\n      if (!lastIndex) return LOAD<string>(buffer, 0);\n\n      let estLen = 0;\n      for (let i = 0, len = lastIndex + 1; i < len; ++i) {\n        estLen += LOAD<string>(buffer, i).length;\n      }\n      let offset = 0;\n      let result = allocateUnsafeString(estLen + sepLen * lastIndex);\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<string>(buffer, i);\n        if (value) {\n          let valueLen = value.length;                          // tslint:disable-line:no-unsafe-any\n          copyUnsafeString(result, offset, value, 0, valueLen); // tslint:disable-line:no-unsafe-any\n          offset += valueLen;                                   // tslint:disable-line:no-unsafe-any\n        }\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, separator, 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      value = LOAD<string>(buffer, lastIndex);\n      if (value) {\n        let valueLen = value.length;                          // tslint:disable-line:no-unsafe-any\n        copyUnsafeString(result, offset, value, 0, valueLen); // tslint:disable-line:no-unsafe-any\n      }\n      return result;\n    } else if (isArray<T>()) {\n      if (!lastIndex) {\n        value = LOAD<T>(buffer, 0);\n        return value ? value.join(separator) : \"\"; // tslint:disable-line:no-unsafe-any\n      }\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T>(buffer, i);\n        if (value) result += value.join(separator); // tslint:disable-line:no-unsafe-any\n        if (hasSeparator) result += separator;\n      }\n      value = LOAD<T>(buffer, lastIndex);\n      if (value) result += value.join(separator); // tslint:disable-line:no-unsafe-any\n      return result;\n    } else if (isReference<T>()) { // References\n      if (!lastIndex) return \"[object Object]\";\n      const valueLen = 15; // max possible length of element len(\"[object Object]\")\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n      let result = allocateUnsafeString(estLen);\n      let offset = 0;\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T>(buffer, i);\n        if (value) {\n          copyUnsafeString(result, offset, changetype<String>(\"[object Object]\"), 0, valueLen);\n          offset += valueLen;\n        }\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, changetype<String>(separator), 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      if (LOAD<T>(buffer, lastIndex)) {\n        copyUnsafeString(result, offset, changetype<String>(\"[object Object]\"), 0, valueLen);\n        offset += valueLen;\n      }\n      let out = result;\n      if (estLen > offset) {\n        out = result.substring(0, offset);\n        freeUnsafeString(result);\n      }\n      return out;\n    } else {\n      assert(false); // Unsupported generic typename\n    }\n  }\n\n  @inline\n  toString(): string {\n    return this.join();\n  }\n\n  private __gc(): void {\n    var buffer = this.buffer_;\n    __gc_mark(changetype<usize>(buffer)); // tslint:disable-line\n    if (isManaged<T>()) {\n      let offset: usize = 0;\n      let end = <usize>this.length_ << alignof<usize>();\n      while (offset < end) {\n        __gc_mark(load<usize>(changetype<usize>(buffer) + offset, HEADER_SIZE)); // tslint:disable-line\n        offset += sizeof<usize>();\n      }\n    }\n  }\n}\n","declare function logStr(str: string): void;\ndeclare function logF64(val: f64): void;\n\nexport class JSONEncoder {\n    private isFirstKey: bool[] = new Array<bool>(1);\n    private result: string[] = new Array<string>();\n\n    constructor() {\n      this.isFirstKey[0] = true;\n    }\n\n    serialize(): Uint8Array {\n        // TODO: Write directly to UTF8 bytes\n        let result = this.toString();\n        let utf8ptr = result.toUTF8();\n        let buffer = new Uint8Array(result.lengthUTF8 - 1);\n        memory.copy(buffer.buffer.data, utf8ptr, buffer.byteLength);\n        return buffer;\n    }\n\n    toString(): String {\n        return this.result.join(\"\");\n    }\n\n    setString(name: string, value: string): void {\n        this.writeKey(name);\n        this.writeString(value);\n    }\n\n    setBoolean(name: string, value: bool): void {\n        this.writeKey(name);\n        this.writeBoolean(value);\n    }\n\n    setNull(name: string): void {\n        this.writeKey(name);\n        this.write(\"null\");\n    }\n\n    setInteger(name: string, value: i64): void {\n        this.writeKey(name);\n        this.writeInteger(value);\n    }\n\n    pushArray(name: string): bool {\n        this.writeKey(name);\n        this.write(\"[\");\n        this.isFirstKey.push(true);\n        return true;\n    }\n\n    popArray(): void {\n        this.write(\"]\");\n        this.isFirstKey.pop();\n    }\n\n    pushObject(name: string): bool {\n        this.writeKey(name);\n        this.write(\"{\");\n        this.isFirstKey.push(true);\n        return true;\n    }\n\n    popObject(): void {\n        this.write(\"}\");\n        this.isFirstKey.pop();\n    }\n\n    private writeKey(str: string): void {\n        if (!this.isFirstKey[this.isFirstKey.length - 1]) {\n            this.write(\",\");\n        } else {\n            this.isFirstKey[this.isFirstKey.length - 1] = false;\n        }\n        if (str != null) {\n            this.writeString(str);\n            this.write(\":\");\n        }\n    }\n\n    private writeString(str: string): void {\n        this.write('\"');\n        let savedIndex = 0;\n        for (let i = 0; i < str.length; i++) {\n            let char = str.charCodeAt(i);\n            let needsEscaping = char < 0x20 || char == '\"'.charCodeAt(0) || char == '\\\\'.charCodeAt(0);\n            if (needsEscaping) {\n                this.write(str.substring(savedIndex, i));\n                savedIndex = i + 1;\n                if (char == '\"'.charCodeAt(0)) {\n                    this.write('\\\\\"');\n                } else if (char == \"\\\\\".charCodeAt(0)) {\n                    this.write(\"\\\\\\\\\");\n                } else if (char == \"\\b\".charCodeAt(0)) {\n                    this.write(\"\\\\b\");\n                } else if (char == \"\\n\".charCodeAt(0)) {\n                    this.write(\"\\\\n\");\n                } else if (char == \"\\r\".charCodeAt(0)) {\n                    this.write(\"\\\\r\");\n                } else if (char == \"\\t\".charCodeAt(0)) {\n                    this.write(\"\\\\t\");\n                } else {\n                    // TODO: Implement encoding for other contol characters\n                    assert(false, \"Unsupported control character code: \" + char.toString());\n                }\n            }\n        }\n        this.write(str.substring(savedIndex, str.length));\n        this.write('\"');\n    }\n\n    private writeBoolean(value: bool): void {\n        this.write(value ? \"true\" : \"false\");\n    }\n\n    private writeInteger(value: i64): void {\n        this.write(value.toString());\n    }\n\n    private write(str: string): void {\n        this.result.push(str);\n    }\n}\n","\n      import { storage, near, base64 } from \"./near\";\n      import { JSONEncoder } from \"./json/encoder\";\n      import { JSONDecoder, ThrowingJSONHandler, DecoderState } from \"./json/decoder\";\n      import {Corgi as wrapped_Corgi, CorgiMetaData as wrapped_CorgiMetaData, CorgiArray as wrapped_CorgiArray} from \"./model\";\n      \n      // Runtime functions\n      @external(\"env\", \"return_value\")\n      declare function return_value(value_len: usize, value_ptr: usize): void;\n    \nexport function __near_encode_Array_String(\n          value: Array<String>,\n          encoder: JSONEncoder): void {\nfor (let i = 0; i < value.length; i++) {\nif (value[i] != null) {\n            encoder.setString(null, value[i]);\n          } else {\n            encoder.setNull(null);\n          }\n}\n}\nexport function __near_encode_CorgiMetaData(\n          value: CorgiMetaData,\n          encoder: JSONEncoder): void {\nif (value.attributes != null) {\n          encoder.pushArray(\"attributes\");\n          __near_encode_Array_String(value.attributes, encoder);\n          encoder.popArray();\n        } else {\n          encoder.setNull(\"attributes\");\n        }\n}\nexport function __near_encode_Corgi(\n          value: Corgi,\n          encoder: JSONEncoder): void {\nif (value.owner != null) {\n            encoder.setString(\"owner\", value.owner);\n          } else {\n            encoder.setNull(\"owner\");\n          }\nif (value.name != null) {\n            encoder.setString(\"name\", value.name);\n          } else {\n            encoder.setNull(\"name\");\n          }\nif (value.dna != null) {\n            encoder.setString(\"dna\", value.dna);\n          } else {\n            encoder.setNull(\"dna\");\n          }\nif (value.color != null) {\n            encoder.setString(\"color\", value.color);\n          } else {\n            encoder.setNull(\"color\");\n          }\nencoder.setInteger(\"level\", value.level);\nif (value.metadata != null) {\n          encoder.pushObject(\"metadata\");\n          __near_encode_CorgiMetaData(value.metadata, encoder);\n          encoder.popObject();\n        } else {\n          encoder.setNull(\"metadata\");\n        }\n}\nexport class __near_JSONHandler_Corgi extends ThrowingJSONHandler {\n      buffer: Uint8Array;\n      decoder: JSONDecoder<__near_JSONHandler_Corgi>;\n      handledRoot: boolean = false;\n      value: Corgi;\n      \n      constructor(value_: Corgi) {\n        super();\n        this.value = value_;\n      }\n    \nsetInteger(name: string, value: i64): void {\nif (name == \"level\") {\n            this.value.level = <i32>value;\n            return;\n          }\n\n        super.setInteger(name, value);\n      }\nsetString(name: string, value: String): void {\nif (name == \"owner\") {\n            this.value.owner = <String>value;\n            return;\n          }\nif (name == \"name\") {\n            this.value.name = <String>value;\n            return;\n          }\nif (name == \"dna\") {\n            this.value.dna = <String>value;\n            return;\n          }\nif (name == \"color\") {\n            this.value.color = <String>value;\n            return;\n          }\n\n        super.setString(name, value);\n      }\nsetNull(name: string): void {\nif (name == \"owner\") {\n        this.value.owner = <String>null;\n        return;\n      }\nif (name == \"name\") {\n        this.value.name = <String>null;\n        return;\n      }\nif (name == \"dna\") {\n        this.value.dna = <String>null;\n        return;\n      }\nif (name == \"color\") {\n        this.value.color = <String>null;\n        return;\n      }\nif (name == \"level\") {\n        this.value.level = <i32>null;\n        return;\n      }\nif (name == \"metadata\") {\n        this.value.metadata = <CorgiMetaData>null;\n        return;\n      }\n\n      super.setNull(name);\n    }\n\n      pushObject(name: string): bool {\nif (!this.handledRoot) {\n      assert(name == null);\n      this.handledRoot = true;\n      return true;\n    } else {\n      assert(name != null);\n    }\nif (name == \"metadata\") {\n          this.value.metadata = __near_decode_CorgiMetaData(this.buffer, this.decoder.state);\n          return false;\n        }\n\n        return super.pushObject(name);\n      }\n\n      pushArray(name: string): bool {\n\n        return super.pushArray(name);\n      }\n}\n\nexport class __near_JSONHandler_CorgiMetaData extends ThrowingJSONHandler {\n      buffer: Uint8Array;\n      decoder: JSONDecoder<__near_JSONHandler_CorgiMetaData>;\n      handledRoot: boolean = false;\n      value: CorgiMetaData;\n      \n      constructor(value_: CorgiMetaData) {\n        super();\n        this.value = value_;\n      }\n    \nsetNull(name: string): void {\nif (name == \"attributes\") {\n        this.value.attributes = <Array<String>>null;\n        return;\n      }\n\n      super.setNull(name);\n    }\n\n      pushObject(name: string): bool {\nif (!this.handledRoot) {\n      assert(name == null);\n      this.handledRoot = true;\n      return true;\n    } else {\n      assert(name != null);\n    }\n\n        return super.pushObject(name);\n      }\n\n      pushArray(name: string): bool {\nif (name == \"attributes\") {\n          this.value.attributes = __near_decode_Array_String(this.buffer, this.decoder.state);\n          return false;\n        }\n\n        return super.pushArray(name);\n      }\n}\n\nexport class __near_JSONHandler_Array_String extends ThrowingJSONHandler {\n      buffer: Uint8Array;\n      decoder: JSONDecoder<__near_JSONHandler_Array_String>;\n      handledRoot: boolean = false;\n      value: Array<String>;\n      \n      constructor(value_: Array<String>) {\n        super();\n        this.value = value_;\n      }\n    \nsetString(name: string, value: String): void {\n          this.value.push(<String>value);\n        }\nsetNull(name: string): void {\n        this.value.push(<String>null);\n      }\n      pushArray(name: string): bool {\n        assert(name == null && !this.handledRoot);\n        this.handledRoot = true;\n        return true;\n      }\n}\n\nexport function __near_decode_Array_String(\n        buffer: Uint8Array, state: DecoderState, value: Array<String> = null):Array<String> {\n      if (value == null) {\n        value = new Array<String>();\n      }\n      let handler = new __near_JSONHandler_Array_String(value);\n      handler.buffer = buffer;\n      handler.decoder = new JSONDecoder<__near_JSONHandler_Array_String>(handler);\n      handler.decoder.deserialize(buffer, state);\n      return value;\n    }\n\nexport function __near_decode_CorgiMetaData(\n        buffer: Uint8Array, state: DecoderState, value: CorgiMetaData = null):CorgiMetaData {\n      if (value == null) {\n        value = new CorgiMetaData();\n      }\n      let handler = new __near_JSONHandler_CorgiMetaData(value);\n      handler.buffer = buffer;\n      handler.decoder = new JSONDecoder<__near_JSONHandler_CorgiMetaData>(handler);\n      handler.decoder.deserialize(buffer, state);\n      return value;\n    }\n\nexport function __near_decode_Corgi(\n        buffer: Uint8Array, state: DecoderState, value: Corgi = null):Corgi {\n      if (value == null) {\n        value = new Corgi();\n      }\n      let handler = new __near_JSONHandler_Corgi(value);\n      handler.buffer = buffer;\n      handler.decoder = new JSONDecoder<__near_JSONHandler_Corgi>(handler);\n      handler.decoder.deserialize(buffer, state);\n      return value;\n    }\n\nexport function __near_encode_Array_Corgi(\n          value: Array<Corgi>,\n          encoder: JSONEncoder): void {\nfor (let i = 0; i < value.length; i++) {\nif (value[i] != null) {\n          encoder.pushObject(null);\n          __near_encode_Corgi(value[i], encoder);\n          encoder.popObject();\n        } else {\n          encoder.setNull(null);\n        }\n}\n}\nexport function __near_encode_CorgiArray(\n          value: CorgiArray,\n          encoder: JSONEncoder): void {\nif (value.corgis != null) {\n          encoder.pushArray(\"corgis\");\n          __near_encode_Array_Corgi(value.corgis, encoder);\n          encoder.popArray();\n        } else {\n          encoder.setNull(\"corgis\");\n        }\n}\nexport class __near_JSONHandler_CorgiArray extends ThrowingJSONHandler {\n      buffer: Uint8Array;\n      decoder: JSONDecoder<__near_JSONHandler_CorgiArray>;\n      handledRoot: boolean = false;\n      value: CorgiArray;\n      \n      constructor(value_: CorgiArray) {\n        super();\n        this.value = value_;\n      }\n    \nsetNull(name: string): void {\nif (name == \"corgis\") {\n        this.value.corgis = <Array<Corgi>>null;\n        return;\n      }\n\n      super.setNull(name);\n    }\n\n      pushObject(name: string): bool {\nif (!this.handledRoot) {\n      assert(name == null);\n      this.handledRoot = true;\n      return true;\n    } else {\n      assert(name != null);\n    }\n\n        return super.pushObject(name);\n      }\n\n      pushArray(name: string): bool {\nif (name == \"corgis\") {\n          this.value.corgis = __near_decode_Array_Corgi(this.buffer, this.decoder.state);\n          return false;\n        }\n\n        return super.pushArray(name);\n      }\n}\n\nexport class __near_JSONHandler_Array_Corgi extends ThrowingJSONHandler {\n      buffer: Uint8Array;\n      decoder: JSONDecoder<__near_JSONHandler_Array_Corgi>;\n      handledRoot: boolean = false;\n      value: Array<Corgi>;\n      \n      constructor(value_: Array<Corgi>) {\n        super();\n        this.value = value_;\n      }\n    \npushObject(name: string): bool {\n        this.value.push(__near_decode_Corgi(this.buffer, this.decoder.state));\n        return false;\n      }\n      pushArray(name: string): bool {\n        assert(name == null);\n        if (!this.handledRoot) {\n          this.handledRoot = true;\n          return true;\n        }\n        this.value.push(__near_decode_Corgi(this.buffer, this.decoder.state));\n        return false;\n      }\n}\n\nexport function __near_decode_Array_Corgi(\n        buffer: Uint8Array, state: DecoderState, value: Array<Corgi> = null):Array<Corgi> {\n      if (value == null) {\n        value = new Array<Corgi>();\n      }\n      let handler = new __near_JSONHandler_Array_Corgi(value);\n      handler.buffer = buffer;\n      handler.decoder = new JSONDecoder<__near_JSONHandler_Array_Corgi>(handler);\n      handler.decoder.deserialize(buffer, state);\n      return value;\n    }\n\nexport function __near_decode_CorgiArray(\n        buffer: Uint8Array, state: DecoderState, value: CorgiArray = null):CorgiArray {\n      if (value == null) {\n        value = new CorgiArray();\n      }\n      let handler = new __near_JSONHandler_CorgiArray(value);\n      handler.buffer = buffer;\n      handler.decoder = new JSONDecoder<__near_JSONHandler_CorgiArray>(handler);\n      handler.decoder.deserialize(buffer, state);\n      return value;\n    }\n\nexport class Corgi {\n  owner: string;\n  name: string;\n  dna: string;\n  color:string;\n  level: i32;\n  metadata: CorgiMetaData;\n\n\n        static decode(json: Uint8Array): Corgi {\n          let value = new Corgi();\n          value.decode(json);\n          return value;\n        }\n\n        decode(json: Uint8Array): Corgi {\n          __near_decode_Corgi(json, null, this);\n          return this;\n        }\n\n        private _encoder(): JSONEncoder {\n          let encoder: JSONEncoder = new JSONEncoder();\n          encoder.pushObject(null);\n          __near_encode_Corgi(this, encoder);\n          encoder.popObject();\n          return encoder;\n        }\n\n        encode(): Uint8Array {\n          return this._encoder().serialize();\n        }\n\n        toString(): string {\n          return this._encoder().toString();\n        }\n      \n}\nexport class CorgiMetaData {\n  attributes: string[];\n\n\n        static decode(json: Uint8Array): CorgiMetaData {\n          let value = new CorgiMetaData();\n          value.decode(json);\n          return value;\n        }\n\n        decode(json: Uint8Array): CorgiMetaData {\n          __near_decode_CorgiMetaData(json, null, this);\n          return this;\n        }\n\n        private _encoder(): JSONEncoder {\n          let encoder: JSONEncoder = new JSONEncoder();\n          encoder.pushObject(null);\n          __near_encode_CorgiMetaData(this, encoder);\n          encoder.popObject();\n          return encoder;\n        }\n\n        encode(): Uint8Array {\n          return this._encoder().serialize();\n        }\n\n        toString(): string {\n          return this._encoder().toString();\n        }\n      \n}\nexport class CorgiArray {\n  corgis: Array<Corgi>;\n\n\n        static decode(json: Uint8Array): CorgiArray {\n          let value = new CorgiArray();\n          value.decode(json);\n          return value;\n        }\n\n        decode(json: Uint8Array): CorgiArray {\n          __near_decode_CorgiArray(json, null, this);\n          return this;\n        }\n\n        private _encoder(): JSONEncoder {\n          let encoder: JSONEncoder = new JSONEncoder();\n          encoder.pushObject(null);\n          __near_encode_CorgiArray(this, encoder);\n          encoder.popObject();\n          return encoder;\n        }\n\n        encode(): Uint8Array {\n          return this._encoder().serialize();\n        }\n\n        toString(): string {\n          return this._encoder().toString();\n        }\n      \n}","import * as JSMath from \"./bindings/Math\";\nexport { JSMath };\n\nimport {\n  abs as builtin_abs,\n  ceil as builtin_ceil,\n  clz as builtin_clz,\n  copysign as builtin_copysign,\n  floor as builtin_floor,\n  max as builtin_max,\n  min as builtin_min,\n  sqrt as builtin_sqrt,\n  trunc as builtin_trunc\n} from \"./builtins\";\n\n// SUN COPYRIGHT NOTICE\n//\n// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n// Developed at SunPro, a Sun Microsystems, Inc. business.\n// Permission to use, copy, modify, and distribute this software\n// is freely granted, provided that this notice is preserved.\n//\n// Applies to all functions marked with a comment referring here.\n\n// TODO: sin, cos, tan for Math namespace\n\n/** @internal */\nfunction R(z: f64): f64 { // Rational approximation of (asin(x)-x)/x^3\n  const                   // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f64>(0x3FC5555555555555), //  1.66666666666666657415e-01\n    pS1 = reinterpret<f64>(0xBFD4D61203EB6F7D), // -3.25565818622400915405e-01\n    pS2 = reinterpret<f64>(0x3FC9C1550E884455), //  2.01212532134862925881e-01\n    pS3 = reinterpret<f64>(0xBFA48228B5688F3B), // -4.00555345006794114027e-02\n    pS4 = reinterpret<f64>(0x3F49EFE07501B288), //  7.91534994289814532176e-04\n    pS5 = reinterpret<f64>(0x3F023DE10DFDF709), //  3.47933107596021167570e-05\n    qS1 = reinterpret<f64>(0xC0033A271C8A2D4B), // -2.40339491173441421878e+00\n    qS2 = reinterpret<f64>(0x40002AE59C598AC8), //  2.02094576023350569471e+00\n    qS3 = reinterpret<f64>(0xBFE6066C1B8D0159), // -6.88283971605453293030e-01\n    qS4 = reinterpret<f64>(0x3FB3B8C5B12E9282); //  7.70381505559019352791e-02\n  var p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));\n  var q = 1.0 + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));\n  return p / q;\n}\n\n@inline function expo2(x: f64): f64 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                       // see: musl/src/math/__expo2.c\n    k    = <u32>2043,\n    kln2 = reinterpret<f64>(0x40962066151ADD8B); // 0x1.62066151add8bp+10\n  var scale = reinterpret<f64>(<u64>((<u32>0x3FF + k / 2) << 20) << 32);\n  return NativeMath.exp(x - kln2) * scale * scale;\n}\n\n/** @internal */\n@lazy var random_seeded = false;\n@lazy var random_state0_64: u64;\n@lazy var random_state1_64: u64;\n@lazy var random_state0_32: u32;\n@lazy var random_state1_32: u32;\n\nfunction murmurHash3(h: u64): u64 { // Force all bits of a hash block to avalanche\n  h ^= h >> 33;                     // see: https://github.com/aappleby/smhasher\n  h *= 0xFF51AFD7ED558CCD;\n  h ^= h >> 33;\n  h *= 0xC4CEB9FE1A85EC53;\n  h ^= h >> 33;\n  return h;\n}\n\nfunction splitMix32(h: u32): u32 {\n  h += 0x6D2B79F5;\n  h  = (h ^ (h >> 15)) * (h | 1);\n  h ^= h + (h ^ (h >> 7)) * (h | 61);\n  return h ^ (h >> 14);\n}\n\nexport namespace NativeMath {\n\n  @lazy export const E       = reinterpret<f64>(0x4005BF0A8B145769); // 2.7182818284590452354\n  @lazy export const LN2     = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.69314718055994530942\n  @lazy export const LN10    = reinterpret<f64>(0x40026BB1BBB55516); // 2.30258509299404568402\n  @lazy export const LOG2E   = reinterpret<f64>(0x3FF71547652B82FE); // 1.4426950408889634074\n  @lazy export const LOG10E  = reinterpret<f64>(0x3FDBCB7B1526E50E); // 0.43429448190325182765\n  @lazy export const PI      = reinterpret<f64>(0x400921FB54442D18); // 3.14159265358979323846\n  @lazy export const SQRT1_2 = reinterpret<f64>(0x3FE6A09E667F3BCD); // 0.70710678118654752440\n  @lazy export const SQRT2   = reinterpret<f64>(0x3FF6A09E667F3BCD); // 1.41421356237309504880\n\n  @inline\n  export function abs(x: f64): f64 {\n    return builtin_abs<f64>(x);\n  }\n\n  export function acos(x: f64): f64 { // see: musl/src/math/acos.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) {\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix <= 0x3C600000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * R(x * x)));\n    }\n    var s: f64, w: f64, z: f64;\n    if (hx >> 31) {\n      // z = (1.0 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f64>(z);\n      w = R(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1.0 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f64>(z);\n    var df = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n    var c = (z - df * df) / (s + df);\n    w = R(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f64): f64 { // see: musl/src/math/acosh.c\n    const s = reinterpret<f64>(0x3FE62E42FEFA39EF);\n    var e = reinterpret<u64>(x) >> 52 & 0x7FF;\n    if (e < 0x3FF + 1) return log1p(x - 1 + builtin_sqrt<f64>((x - 1) * (x - 1) + 2 * (x - 1)));\n    if (e < 0x3FF + 26) return log(2 * x - 1 / (x + builtin_sqrt<f64>(x * x - 1)));\n    return log(x) + s;\n  }\n\n  export function asin(x: f64): f64 { // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) return x * pio2_hi + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix < 0x3E500000 && ix >= 0x00100000) return x;\n      return x + x * R(x * x);\n    }\n    // var z = (1.0 - builtin_abs<f64>(x)) * 0.5;\n    var z = 0.5 - builtin_abs<f64>(x) * 0.5;\n    var s = builtin_sqrt<f64>(z);\n    var r = R(z);\n    if (ix >= 0x3FEF3333) x = pio2_hi - (2 * (s + s * r) - pio2_lo);\n    else {\n      let f = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n      let c = (z - f * f) / (s + f);\n      x = 0.5 * pio2_hi - (2 * s * r - (pio2_lo - 2 * c) - (0.5 * pio2_hi - 2 * f));\n    }\n    if (hx >> 31) return -x;\n    return x;\n  }\n\n  export function asinh(x: f64): f64 { // see: musl/src/math/asinh.c\n    const c = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.693147180559945309417232121458176568\n    var u = reinterpret<u64>(x);\n    var e = u >> 52 & 0x7FF;\n    var y = reinterpret<f64>(u & 0x7FFFFFFFFFFFFFFF);\n    if (e >= 0x3FF + 26) y = log(y) + c;\n    else if (e >= 0x3FF + 1)  y =   log(2 * y + 1 / (builtin_sqrt<f64>(y * y + 1) + y));\n    else if (e >= 0x3FF - 26) y = log1p(y + y * y / (builtin_sqrt<f64>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f64): f64 { // see musl/src/math/atan.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f64>(0x3FDDAC670561BB4F), //  4.63647609000806093515e-01\n      atanhi1   = reinterpret<f64>(0x3FE921FB54442D18), //  7.85398163397448278999e-01\n      atanhi2   = reinterpret<f64>(0x3FEF730BD281F69B), //  9.82793723247329054082e-01\n      atanhi3   = reinterpret<f64>(0x3FF921FB54442D18), //  1.57079632679489655800e+00\n      atanlo0   = reinterpret<f64>(0x3C7A2B7F222F65E2), //  2.26987774529616870924e-17\n      atanlo1   = reinterpret<f64>(0x3C81A62633145C07), //  3.06161699786838301793e-17\n      atanlo2   = reinterpret<f64>(0x3C7007887AF0CBBD), //  1.39033110312309984516e-17\n      atanlo3   = reinterpret<f64>(0x3C91A62633145C07), //  6.12323399573676603587e-17\n      aT0       = reinterpret<f64>(0x3FD555555555550D), //  3.33333333333329318027e-01\n      aT1       = reinterpret<f64>(0xBFC999999998EBC4), // -1.99999999998764832476e-01\n      aT2       = reinterpret<f64>(0x3FC24924920083FF), //  1.42857142725034663711e-01\n      aT3       = reinterpret<f64>(0xBFBC71C6FE231671), // -1.11111104054623557880e-01,\n      aT4       = reinterpret<f64>(0x3FB745CDC54C206E), //  9.09088713343650656196e-02\n      aT5       = reinterpret<f64>(0xBFB3B0F2AF749A6D), // -7.69187620504482999495e-02\n      aT6       = reinterpret<f64>(0x3FB10D66A0D03D51), //  6.66107313738753120669e-02\n      aT7       = reinterpret<f64>(0xBFADDE2D52DEFD9A), // -5.83357013379057348645e-02\n      aT8       = reinterpret<f64>(0x3FA97B4B24760DEB), //  4.97687799461593236017e-02\n      aT9       = reinterpret<f64>(0xBFA2B4442C6A6C2F), // -3.65315727442169155270e-02\n      aT10      = reinterpret<f64>(0x3F90AD3AE322DA11), //  1.62858201153657823623e-02\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var ix = <u32>(reinterpret<u64>(x) >> 32);\n    var sx = x;\n    ix &= 0x7FFFFFFF;\n    var z: f64;\n    if (ix >= 0x44100000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign<f64>(z, sx);\n    }\n    var id: i32;\n    if (ix < 0x3FDC0000) {\n      if (ix < 0x3E400000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f64>(x);\n      if (ix < 0x3FF30000) {\n        if (ix < 0x3FE60000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x40038000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    var w = z * z;\n    var s1 = z * (aT0 + w * (aT2 + w * (aT4 + w * (aT6 + w * (aT8 + w * aT10)))));\n    var s2 = w * (aT1 + w * (aT3 + w * (aT5 + w * (aT7 + w * aT9))));\n    var s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign<f64>(z, sx);\n  }\n\n  export function atanh(x: f64): f64 { // see: musl/src/math/atanh.c\n    var u = reinterpret<u64>(x);\n    var e = u >> 52 & 0x7FF;\n    var s = u >> 63;\n    u &= 0x7FFFFFFFFFFFFFFF;\n    var y = reinterpret<f64>(u);\n    if (e < 0x3FF - 1) {\n      if (e >= 0x3FF - 32) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));\n    } else {\n      y = 0.5 * log1p(2 * (y / (1 - y)));\n    }\n    return builtin_copysign<f64>(y, x);\n  }\n\n  export function atan2(y: f64, x: f64): f64 { // see: musl/src/math/atan2.c and SUN COPYRIGHT NOTICE above\n    const pi_lo = reinterpret<f64>(0x3CA1A62633145C07); // 1.2246467991473531772E-16\n    if (isNaN(x) || isNaN(y)) return x + y;\n    var u = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var lx = <u32>u;\n    u = reinterpret<u64>(y);\n    var iy = <u32>(u >> 32);\n    var ly = <u32>u;\n    if ((ix - 0x3FF00000 | lx) == 0) return atan(y);\n    var m = ((iy >> 31) & 1) | ((ix >> 30) & 2);\n    ix = ix & 0x7FFFFFFF;\n    iy = iy & 0x7FFFFFFF;\n    if ((iy | ly) == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  PI;\n        case 3: return -PI;\n      }\n    }\n    if ((ix | lx) == 0) return m & 1 ? -PI / 2 : PI / 2;\n    if (ix == 0x7FF00000) {\n      if (iy == 0x7FF00000) {\n        switch (m) {\n          case 0: return  PI / 4;\n          case 1: return -PI / 4;\n          case 2: return  3 * PI / 4;\n          case 3: return -3 * PI / 4;\n        }\n      } else {\n        switch (m) {\n          case 0: return  0.0;\n          case 1: return -0.0;\n          case 2: return  PI;\n          case 3: return -PI;\n        }\n      }\n    }\n    var z: f64;\n    if (ix + (64 << 20) < iy || iy == 0x7FF00000) return m & 1 ? -PI / 2 : PI / 2;\n    if ((m & 2) && iy + (64 << 20) < ix) z = 0;\n    else z = atan(builtin_abs<f64>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return PI - (z - pi_lo);\n      case 3: return (z - pi_lo) - PI;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f64): f64 { // see: musl/src/math/cbrt.c and SUN COPYRIGHT NOTICE above\n    const\n      B1     = <u32>715094163,\n      B2     = <u32>696219795,\n      P0     = reinterpret<f64>(0x3FFE03E60F61E692), //  1.87595182427177009643\n      P1     = reinterpret<f64>(0xBFFE28E092F02420), // -1.88497979543377169875\n      P2     = reinterpret<f64>(0x3FF9F1604A49D6C2), //  1.621429720105354466140\n      P3     = reinterpret<f64>(0xBFE844CBBEE751D9), // -0.758397934778766047437\n      P4     = reinterpret<f64>(0x3FC2B000D4E4EDD7), //  0.145996192886612446982\n      Ox1p54 = reinterpret<f64>(0x4350000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32) & 0x7FFFFFFF;\n    if (hx >= 0x7FF00000) return x + x;\n    if (hx < 0x00100000) {\n      u = reinterpret<u64>(x * Ox1p54);\n      hx = <u32>(u >> 32) & 0x7FFFFFFF;\n      if (hx == 0) return x;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 1 << 63;\n    u |= <u64>hx << 32;\n    var t = reinterpret<f64>(u);\n    var r = (t * t) * (t / x);\n    t = t * ((P0 + r * (P1 + r * P2)) + ((r * r) * r) * (P3 + r * P4));\n    t = reinterpret<f64>((reinterpret<u64>(t) + 0x80000000) & 0xFFFFFFFFC0000000);\n    var s = t * t;\n    r = x / s;\n    r = (r - t) / (2 * t + r);\n    t = t + t * r;\n    return t;\n  }\n\n  @inline\n  export function ceil(x: f64): f64 {\n    return builtin_ceil<f64>(x);\n  }\n\n  export function clz32(x: f64): f64 {\n    if (!isFinite(x)) return 32;\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    return builtin_clz(\n      <i32><i64>(x - 4294967296 * builtin_floor(x * (1.0 / 4294967296)))\n    );\n  }\n\n  export function cos(x: f64): f64 { // TODO\n    unreachable();\n    return 0;\n  }\n\n  export function cosh(x: f64): f64 { // see: musl/src/math/cosh.c\n    var u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    x = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var t: f64;\n    if (w < 0x3FE62E42) {\n      if (w < 0x3FF00000 - (26 << 20)) return 1;\n      t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (w < 0x40862E42) {\n      t = exp(x);\n      return 0.5 * (t + 1 / t);\n    }\n    t = expo2(x);\n    return t;\n  }\n\n  export function exp(x: f64): f64 { // see: musl/src/math/exp.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2hi     = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n      ln2lo     = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n      invln2    = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      P1        = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n      P2        = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n      P3        = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n      P4        = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n      P5        = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n      overflow  = reinterpret<f64>(0x40862E42FEFA39EF), //  709.782712893383973096\n      underflow = reinterpret<f64>(0xC0874910D52D3051), // -745.13321910194110842\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000);\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\n    var sign_ = <i32>(hx >> 31);\n    hx &= 0x7FFFFFFF;\n    if (hx >= 0x4086232B) {\n      if (isNaN(x)) return x;\n      if (x > overflow)  return x * Ox1p1023;\n      if (x < underflow) return 0;\n    }\n    var hi: f64, lo: f64 = 0;\n    var k = 0;\n    if (hx > 0x3FD62E42) {\n      if (hx >= 0x3FF0A2B2) {\n        k = <i32>(invln2 * x + builtin_copysign<f64>(0.5, x));\n      } else {\n        k = 1 - (sign_ << 1);\n      }\n      hi = x - k * ln2hi;\n      lo = k * ln2lo;\n      x = hi - lo;\n    } else if (hx > 0x3E300000) {\n      hi = x;\n    } else return 1.0 + x;\n    var xs = x * x;\n    // var c = x - xp2 * (P1 + xp2 * (P2 + xp2 * (P3 + xp2 * (P4 + xp2 * P5))));\n    var xq = xs * xs;\n    var c = x - (xs * P1 + xq * ((P2 + xs * P3) + xq * (P4 + xs * P5)));\n    var y = 1.0 + (x * c / (2 - c) - lo + hi);\n    if (k == 0) return y;\n    return scalbn(y, k);\n  }\n\n  export function expm1(x: f64): f64 { // see: musl/src/math/expm1.c and SUN COPYRIGHT NOTICE above\n    const\n      o_threshold = reinterpret<f64>(0x40862E42FEFA39EF), //  7.09782712893383973096e+02\n      ln2_hi      = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n      ln2_lo      = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n      invln2      = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      Q1          = reinterpret<f64>(0xBFA11111111110F4), // -3.33333333333331316428e-02\n      Q2          = reinterpret<f64>(0x3F5A01A019FE5585), //  1.58730158725481460165e-03\n      Q3          = reinterpret<f64>(0xBF14CE199EAADBB7), // -7.93650757867487942473e-05\n      Q4          = reinterpret<f64>(0x3ED0CFCA86E65239), //  4.00821782732936239552e-06\n      Q5          = reinterpret<f64>(0xBE8AFDB76E09C32D), // -2.01099218183624371326e-07\n      Ox1p1023    = reinterpret<f64>(0x7FE0000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32 & 0x7FFFFFFF);\n    var k = 0, sign_ = <i32>(u >> 63);\n    if (hx >= 0x4043687A) {\n      if (isNaN(x)) return x;\n      if (sign_) return -1;\n      if (x > o_threshold) return x * Ox1p1023;\n    }\n    var c = 0.0, t: f64;\n    if (hx > 0x3FD62E42) {\n      k = select<i32>(\n        1 - (sign_ << 1),\n        <i32>(invln2 * x + builtin_copysign<f64>(0.5, x)),\n        hx < 0x3FF0A2B2\n      );\n      t = <f64>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x3C900000) return x;\n    var hfx = 0.5 * x;\n    var hxs = x * hfx;\n    // var r1 = 1.0 + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));\n    var hxq = hxs * hxs;\n    var r1 = (1.0 + hxs * Q1) + hxq * ((Q2 + hxs * Q3) + hxq * (Q4 + hxs * Q5));\n    t = 3.0 - r1 * hfx;\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x3FF + k) << 52;\n    var twopk = reinterpret<f64>(u);\n    var y: f64;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 1024) y = y * 2.0 * Ox1p1023;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x3FF - k) << 52;\n    y = reinterpret<f64>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  @inline\n  export function floor(x: f64): f64 {\n    return builtin_floor<f64>(x);\n  }\n\n  @inline\n  export function fround(x: f64): f32 {\n    return <f32>x;\n  }\n\n  export function hypot(x: f64, y: f64): f64 { // see: musl/src/math/hypot.c\n    const\n      SPLIT    = reinterpret<f64>(0x41A0000000000000) + 1, // 0x1p27 + 1\n      Ox1p700  = reinterpret<f64>(0x6BB0000000000000),\n      Ox1p_700 = reinterpret<f64>(0x1430000000000000);\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    ux &= 0x7FFFFFFFFFFFFFFF;\n    uy &= 0x7FFFFFFFFFFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    var ex = <i32>(ux >> 52);\n    var ey = <i32>(uy >> 52);\n    y = reinterpret<f64>(uy);\n    if (ey == 0x7FF) return y;\n    x = reinterpret<f64>(ux);\n    if (ex == 0x7FF || uy == 0) return x;\n    if (ex - ey > 64) return x + y;\n    var z = 1.0;\n    if (ex > 0x3FF + 510) {\n      z  = Ox1p700;\n      x *= Ox1p_700;\n      y *= Ox1p_700;\n    } else if (ey < 0x3FF - 450) {\n      z  = Ox1p_700;\n      x *= Ox1p700;\n      y *= Ox1p700;\n    }\n    var c = x * SPLIT;\n    var h = x - c + c;\n    var l = x - h;\n    var hx = x * x;\n    var lx = h * h - hx + (2 * h + l) * l;\n    c = y * SPLIT;\n    h = y - c + c;\n    l = y - h;\n    var hy = y * y;\n    var ly = h * h - hy + (2 * h + l) * l;\n    return z * builtin_sqrt(ly + lx + hy + hx);\n  }\n\n  export function imul(x: f64, y: f64): f64 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    const inv32 = 1.0 / 4294967296;\n    return (\n      <i32><i64>(x - 4294967296 * builtin_floor(x * inv32)) *\n      <i32><i64>(y - 4294967296 * builtin_floor(y * inv32))\n    );\n  }\n\n  export function log(x: f64): f64 { // see: musl/src/math/log.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54 = reinterpret<f64>(0x4350000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 0;\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (hx >> 31)    return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = <u32>(u >> 32);\n    } else if (hx >= 0x7FF00000) return x;\n      else if (hx == 0x3FF00000 && u << 32 == 0) return 0;\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += (<i32>hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    var f = x - 1.0;\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var dk = k;\n    return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log10(x: f64): f64 { // see: musl/src/math/log10.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f64>(0x3FDBCB7B15200000), // 4.34294481878168880939e-01\n      ivln10lo  = reinterpret<f64>(0x3DBB9438CA9AADD5), // 2.50829467116452752298e-11\n      log10_2hi = reinterpret<f64>(0x3FD34413509F6000), // 3.01029995663611771306e-01\n      log10_2lo = reinterpret<f64>(0x3D59FEF311F12B36), // 3.69423907715893078616e-13\n      Lg1       = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2       = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3       = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4       = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5       = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6       = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7       = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54    = reinterpret<f64>(0x4350000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 0;\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (hx >> 31) return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = <u32>(u >> 32);\n    } else if (hx >= 0x7FF00000) return x;\n      else if (hx == 0x3FF00000 && u << 32 == 0) return 0;\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += <i32>(hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    var f = x - 1.0;\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var hi = f - hfsq;\n    u = reinterpret<u64>(hi);\n    u &= 0xFFFFFFFF00000000;\n    hi = reinterpret<f64>(u);\n    var lo = f - hi - hfsq + s * (hfsq + r);\n    var val_hi = hi * ivln10hi;\n    var dk = <f64>k;\n    var y = dk * log10_2hi;\n    var val_lo = dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi;\n    w = y + val_hi;\n    val_lo += (y - w) + val_hi;\n    return val_lo + w;\n  }\n\n  export function log1p(x: f64): f64 { // see: musl/src/math/log1p.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244); // 1.479819860511658591e-01\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 1;\n    var c = 0.0, f = 0.0;\n    if (hx < 0x3FDA827A || <bool>(hx >> 31)) {\n      if (hx >= 0xBFF00000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (hx << 1 < 0x3CA00000 << 1) return x;\n      if (hx <= 0xBFD2BEC4) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (hx >= 0x7FF00000) return x;\n    if (k) {\n      u = reinterpret<u64>(1 + x);\n      let hu = <u32>(u >> 32);\n      hu += 0x3FF00000 - 0x3FE6A09E;\n      k = <i32>(hu >> 20) - 0x3FF;\n      if (k < 54) {\n        let uf = reinterpret<f64>(u);\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      hu = (hu & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hu << 32 | (u & 0xFFFFFFFF);\n      f = reinterpret<f64>(u) - 1;\n    }\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var dk = <f64>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f64): f64 { // see: musl/src/math/log2.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln2hi = reinterpret<f64>(0x3FF7154765200000), // 1.44269504072144627571e+00\n      ivln2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 1.67517131648865118353e-10\n      Lg1     = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2     = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3     = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4     = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5     = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6     = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7     = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54  = reinterpret<f64>(0x4350000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 0;\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (hx >> 31) return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = <u32>(u >> 32);\n    } else if (hx >= 0x7FF00000) return x;\n      else if (hx == 0x3FF00000 && u << 32 == 0) return 0;\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += <i32>(hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    var f = x - 1.0;\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var hi = f - hfsq;\n    u = reinterpret<u64>(hi);\n    u &= 0xFFFFFFFF00000000;\n    hi = reinterpret<f64>(u);\n    var lo = f - hi - hfsq + s * (hfsq + r);\n    var val_hi = hi * ivln2hi;\n    var val_lo = (lo + hi) * ivln2lo + lo * ivln2hi;\n    var y = <f64>k;\n    w = y + val_hi;\n    val_lo += (y - w) + val_hi;\n    val_hi = w;\n    return val_lo + val_hi;\n  }\n\n  @inline\n  export function max(value1: f64, value2: f64): f64 {\n    return builtin_max<f64>(value1, value2);\n  }\n\n  @inline\n  export function min(value1: f64, value2: f64): f64 {\n    return builtin_min<f64>(value1, value2);\n  }\n\n  export function pow(x: f64, y: f64): f64 { // see: musl/src/math/pow.c and SUN COPYRIGHT NOTICE above\n    const\n      dp_h1   = reinterpret<f64>(0x3FE2B80340000000), //  5.84962487220764160156e-01\n      dp_l1   = reinterpret<f64>(0x3E4CFDEB43CFD006), //  1.35003920212974897128e-08\n      two53   = reinterpret<f64>(0x4340000000000000), //  9007199254740992.0\n      huge    = reinterpret<f64>(0x7E37E43C8800759C), //  1e+300\n      tiny    = reinterpret<f64>(0x01A56E1FC2F8F359), //  1e-300\n      L1      = reinterpret<f64>(0x3FE3333333333303), //  5.99999999999994648725e-01\n      L2      = reinterpret<f64>(0x3FDB6DB6DB6FABFF), //  4.28571428578550184252e-01\n      L3      = reinterpret<f64>(0x3FD55555518F264D), //  3.33333329818377432918e-01\n      L4      = reinterpret<f64>(0x3FD17460A91D4101), //  2.72728123808534006489e-01\n      L5      = reinterpret<f64>(0x3FCD864A93C9DB65), //  2.30660745775561754067e-01\n      L6      = reinterpret<f64>(0x3FCA7E284A454EEF), //  2.06975017800338417784e-01\n      P1      = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n      P2      = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n      P3      = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n      P4      = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n      P5      = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n      lg2     = reinterpret<f64>(0x3FE62E42FEFA39EF), //  6.93147180559945286227e-01\n      lg2_h   = reinterpret<f64>(0x3FE62E4300000000), //  6.93147182464599609375e-01\n      lg2_l   = reinterpret<f64>(0xBE205C610CA86C39), // -1.90465429995776804525e-09\n      ovt     = reinterpret<f64>(0x3C971547652B82FE), //  8.0085662595372944372e-017\n      cp      = reinterpret<f64>(0x3FEEC709DC3A03FD), //  9.61796693925975554329e-01\n      cp_h    = reinterpret<f64>(0x3FEEC709E0000000), //  9.61796700954437255859e-01\n      cp_l    = reinterpret<f64>(0xBE3E2FE0145B01F5), // -7.02846165095275826516e-09\n      ivln2   = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      ivln2_h = reinterpret<f64>(0x3FF7154760000000), //  1.44269502162933349609e+00\n      ivln2_l = reinterpret<f64>(0x3E54AE0BF85DDF44), //  1.92596299112661746887e-08\n      inv3    = reinterpret<f64>(0x3FD5555555555555); //  0.3333333333333333333333\n    var u_ = reinterpret<u64>(x);\n    var hx = <i32>(u_ >> 32);\n    var lx = <u32>u_;\n    u_ = reinterpret<u64>(y);\n    var hy = <i32>(u_ >> 32);\n    var ly = <u32>u_;\n    var ix = hx & 0x7FFFFFFF;\n    var iy = hy & 0x7FFFFFFF;\n    if ((iy | ly) == 0) return 1.0; // x**0 = 1, even if x is NaN\n    // if (hx == 0x3FF00000 && lx == 0) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\n    if ( // NaN if either arg is NaN\n      ix > 0x7FF00000 || (ix == 0x7FF00000 && lx != 0) ||\n      iy > 0x7FF00000 || (iy == 0x7FF00000 && ly != 0)\n    ) return x + y;\n    var yisint = 0, k: i32;\n    if (hx < 0) {\n      if (iy >= 0x43400000) yisint = 2;\n      else if (iy >= 0x3FF00000) {\n        k = (iy >> 20) - 0x3FF;\n        let kcond = k > 20;\n        let offset = select<i32>(52, 20, kcond) - k;\n        let Ly = select<i32>(ly, iy, kcond);\n        let jj = Ly >> offset;\n        if ((jj << offset) == Ly) yisint = 2 - (jj & 1);\n      }\n    }\n    if (ly == 0) {\n      if (iy == 0x7FF00000) { // y is +-inf\n        if (((ix - 0x3FF00000) | lx) == 0) return NaN; // C: (-1)**+-inf is 1, JS: NaN\n        else if (ix >= 0x3FF00000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\n        else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\n      }\n      if (iy == 0x3FF00000) {\n        if (hy >= 0) return x;\n        return 1 / x;\n      }\n      if (hy == 0x40000000) return x * x;\n      if (hy == 0x3FE00000) {\n        if (hx >= 0) return builtin_sqrt(x);\n      }\n    }\n    var ax = builtin_abs<f64>(x), z: f64;\n    if (lx == 0) {\n      if (ix == 0 || ix == 0x7FF00000 || ix == 0x3FF00000) {\n        z = ax;\n        if (hy < 0) z = 1.0 / z;\n        if (hx < 0) {\n          if (((ix - 0x3FF00000) | yisint) == 0) {\n            let d = z - z;\n            z = d / d;\n          } else if (yisint == 1) z = -z;\n        }\n        return z;\n      }\n    }\n    var s = 1.0;\n    if (hx < 0) {\n      if (yisint == 0) {\n        let d = x - x;\n        return d / d;\n      }\n      if (yisint == 1) s = -1.0;\n    }\n    var t1: f64, t2: f64, p_h: f64, p_l: f64, r: f64, t: f64, u: f64, v: f64, w: f64;\n    var j: i32, n: i32;\n    if (iy > 0x41E00000) {\n      if (iy > 0x43F00000) {\n        if (ix <= 0x3FEFFFFF) return hy < 0 ? huge * huge : tiny * tiny;\n        if (ix >= 0x3FF00000) return hy > 0 ? huge * huge : tiny * tiny;\n      }\n      if (ix < 0x3FEFFFFF) return hy < 0 ? s * huge * huge : s * tiny * tiny;\n      if (ix > 0x3FF00000) return hy > 0 ? s * huge * huge : s * tiny * tiny;\n      t = ax - 1.0;\n      w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\n      u = ivln2_h * t;\n      v = t * ivln2_l - w * ivln2;\n      t1 = u + v;\n      t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n      t2 = v - (t1 - u);\n    } else {\n      let ss: f64, s2: f64, s_h: f64, s_l: f64, t_h: f64, t_l: f64;\n      n = 0;\n      if (ix < 0x00100000) {\n        ax *= two53;\n        n -= 53;\n        ix = <u32>(reinterpret<u64>(ax) >> 32);\n      }\n      n += (ix >> 20) - 0x3FF;\n      j = ix & 0x000FFFFF;\n      ix = j | 0x3FF00000;\n      if (j <= 0x3988E) k = 0;\n      else if (j < 0xBB67A) k = 1;\n      else {\n        k = 0;\n        n += 1;\n        ix -= 0x00100000;\n      }\n      ax = reinterpret<f64>(reinterpret<u64>(ax) & 0xFFFFFFFF | (<u64>ix << 32));\n      let bp = select<f64>(1.5, 1.0, k); // k ? 1.5 : 1.0\n      u = ax - bp;\n      v = 1.0 / (ax + bp);\n      ss = u * v;\n      s_h = ss;\n      s_h = reinterpret<f64>(reinterpret<u64>(s_h) & 0xFFFFFFFF00000000);\n      t_h = reinterpret<f64>(<u64>(((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18)) << 32);\n      t_l = ax - (t_h - bp);\n      s_l = v * ((u - s_h * t_h) - s_h * t_l);\n      s2 = ss * ss;\n      r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\n      r += s_l * (s_h + ss);\n      s2 = s_h * s_h;\n      t_h = 3.0 + s2 + r;\n      t_h = reinterpret<f64>(reinterpret<u64>(t_h) & 0xFFFFFFFF00000000);\n      t_l = r - ((t_h - 3.0) - s2);\n      u = s_h * t_h;\n      v = s_l * t_h + t_l * ss;\n      p_h = u + v;\n      p_h = reinterpret<f64>(reinterpret<u64>(p_h) & 0xFFFFFFFF00000000);\n      p_l = v - (p_h - u);\n      let z_h = cp_h * p_h;\n      let dp_l = select<f64>(dp_l1, 0.0, k);\n      let z_l = cp_l * p_h + p_l * cp + dp_l;\n      t = <f64>n;\n      let dp_h = select<f64>(dp_h1, 0.0, k);\n      t1 = ((z_h + z_l) + dp_h) + t;\n      t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n      t2 = z_l - (((t1 - t) - dp_h) - z_h);\n    }\n    var y1 = y;\n    y1 = reinterpret<f64>(reinterpret<u64>(y1) & 0xFFFFFFFF00000000);\n    p_l = (y - y1) * t1 + y * t2;\n    p_h = y1 * t1;\n    z = p_l + p_h;\n    u_ = reinterpret<u64>(z);\n    j = <u32>(u_ >> 32);\n    var i = <i32>u_;\n    if (j >= 0x40900000) {\n      if (((j - 0x40900000) | i) != 0) return s * huge * huge;\n      if (p_l + ovt > z - p_h) return s * huge * huge;\n    } else if ((j & 0x7FFFFFFF) >= 0x4090CC00) {\n      if (((j - 0xC090CC00) | i) != 0) return s * tiny * tiny;\n      if (p_l <= z - p_h) return s * tiny * tiny;\n    }\n    i = j & 0x7FFFFFFF;\n    k = (i >> 20) - 0x3FF;\n    n = 0;\n    if (i > 0x3FE00000) {\n      n = j + (0x00100000 >> (k + 1));\n      k = ((n & 0x7FFFFFFF) >> 20) - 0x3FF;\n      t = 0.0;\n      t = reinterpret<f64>(<u64>(n & ~(0x000FFFFF >> k)) << 32);\n      n = ((n & 0x000FFFFF) | 0x00100000) >> (20 - k);\n      if (j < 0) n = -n;\n      p_h -= t;\n    }\n    t = p_l + p_h;\n    t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n    u = t * lg2_h;\n    v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\n    z = u + v;\n    w = v - (z - u);\n    t = z * z;\n    t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\n    r = (z * t1) / (t1 - 2.0) - (w + z * w);\n    z = 1.0 - (r - z);\n    j = <u32>(reinterpret<u64>(z) >> 32);\n    j += n << 20;\n    if ((j >> 20) <= 0) z = scalbn(z, n);\n    else z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF | (<u64>j << 32));\n    return s * z;\n  }\n\n  export function seedRandom(value: i64): void {\n    assert(value);\n    random_seeded = true;\n    random_state0_64 = murmurHash3(value);\n    random_state1_64 = murmurHash3(~random_state0_64);\n    random_state0_32 = splitMix32(<u32>value);\n    random_state1_32 = splitMix32(random_state0_32);\n  }\n\n  export function random(): f64 { // see: v8/src/base/random-number-generator.cc\n    if (!random_seeded) throw new Error(\"PRNG must be seeded.\");\n    var s1 = random_state0_64;\n    var s0 = random_state1_64;\n    random_state0_64 = s0;\n    s1 ^= s1 << 23;\n    s1 ^= s1 >> 17;\n    s1 ^= s0;\n    s1 ^= s0 >> 26;\n    random_state1_64 = s1;\n    var r = ((s0 + s1) & 0x000FFFFFFFFFFFFF) | 0x3FF0000000000000;\n    return reinterpret<f64>(r) - 1;\n  }\n\n  @inline\n  export function round(x: f64): f64 {\n    return builtin_copysign<f64>(builtin_floor<f64>(x + 0.5), x);\n  }\n\n  @inline\n  export function sign(x: f64): f64 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_abs(x) > 0 ? builtin_copysign<f64>(1, x) : x;\n    } else {\n      return x > 0 ? 1 : x < 0 ? -1 : x;\n    }\n  }\n\n  @inline\n  export function signbit(x: f64): bool {\n    // In ECMAScript all NaN values are indistinguishable from each other\n    // so we need handle NaN and negative NaN in similar way\n    return <bool>(<i32>(reinterpret<u64>(x) >>> 63) & (x == x));\n  }\n\n  export function sin(x: f64): f64 { // TODO\n    unreachable();\n    return 0;\n  }\n\n  export function sinh(x: f64): f64 { // see: musl/src/math/sinh.c\n    var u = reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF;\n    var absx = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var t: f64;\n    var h = builtin_copysign(0.5, x);\n    if (w < 0x40862E42) {\n      t = expm1(absx);\n      if (w < 0x3FF00000) {\n        if (w < 0x3FF00000 - (26 << 20)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    t = 2 * h * expo2(absx);\n    return t;\n  }\n\n  @inline\n  export function sqrt(x: f64): f64 {\n    return builtin_sqrt<f64>(x);\n  }\n\n  export function tan(x: f64): f64 { // TODO\n    unreachable();\n    return 0;\n  }\n\n  export function tanh(x: f64): f64 { // see: musl/src/math/tanh.c\n    var u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    var y = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var t: f64;\n    if (w > 0x3FE193EA) {\n      if (w > 0x40340000) {\n        t = 1 - 0 / y;\n      } else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (w > 0x3FD058AE) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (w >= 0x00100000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f64>(t, x);\n  }\n\n  @inline\n  export function trunc(x: f64): f64 {\n    return builtin_trunc<f64>(x);\n  }\n\n  export function scalbn(x: f64, n: i32): f64 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbn.c\n    const\n      Ox1p53    = reinterpret<f64>(0x4340000000000000),\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000),\n      Ox1p_1022 = reinterpret<f64>(0x0010000000000000);\n    var y = x;\n    if (n > 1023) {\n      y *= Ox1p1023;\n      n -= 1023;\n      if (n > 1023) {\n        y *= Ox1p1023;\n        n = builtin_min<i32>(n - 1023, 1023);\n      }\n    } else if (n < -1022) {\n      /* make sure final n < -53 to avoid double\n       rounding in the subnormal range */\n      y *= Ox1p_1022 * Ox1p53;\n      n += 1022 - 53;\n      if (n < -1022) {\n        y *= Ox1p_1022 * Ox1p53;\n        n = builtin_max<i32>(n + 1022 - 53, -1022);\n      }\n    }\n    return y * reinterpret<f64>(<u64>(0x3FF + n) << 52);\n  }\n\n  export function mod(x: f64, y: f64): f64 { // see: musl/src/math/fmod.c\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    var ex = <i64>(ux >> 52 & 0x7FF);\n    var ey = <i64>(uy >> 52 & 0x7FF);\n    var sx = ux >> 63;\n    var uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0x7FF || isNaN<f64>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    var ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      if (ux1 == uy1) return 0 * x;\n      return x;\n    }\n    if (!ex) {\n      ex -= builtin_clz<i64>(ux << 12);\n      ux <<= -ex + 1;\n    } else {\n      ux &= <u64>-1 >> 12;\n      ux |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= -ey + 1;\n    } else {\n      uy &= <u64>-1 >> 12;\n      uy |= 1 << 52;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 52); ux <<= 1) --ex;\n    var shift = builtin_clz<i64>(ux << 11);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 52;\n      ux |= ex << 52;\n    } else {\n      ux >>= -ex + 1;\n    }\n    ux |= sx << 63;\n    return reinterpret<f64>(ux);\n  }\n\n  export function rem(x: f64, y: f64): f64 { // see: musl/src/math/remquo.c\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    var ex = <i64>(ux >> 52 & 0x7FF);\n    var ey = <i64>(uy >> 52 & 0x7FF);\n    var sx = <i32>(ux >> 63);\n    if (uy << 1 == 0 || ex == 0x7FF || isNaN(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    if (ux << 1 == 0) return x;\n    var uxi = ux;\n    if (!ex) {\n      ex -= builtin_clz<i64>(uxi << 12);\n      uxi <<= -ex + 1;\n    } else {\n      uxi &= <u64>-1 >> 12;\n      uxi |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= -ey + 1;\n    } else {\n      uy &= <u64>-1 >> 12;\n      uy |= 1 << 52;\n    }\n    var q: u32 = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -60;\n      else {\n        let shift = builtin_clz<i64>(uxi << 11);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n  // end:\n    if (ex > 0) {\n      uxi -= 1 << 52;\n      uxi |= ex << 52;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f64>(uxi);\n    y = builtin_abs<f64>(y);\n    var x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (x2 > y || (x2 == y && <bool>(q & 1))))) {\n      x -= y;\n      // ++q;\n    }\n    return sx ? -x : x;\n  }\n}\n\n/** @internal */\n@lazy var rempio2f_y: f64;\n@lazy const PIO2_TABLE: u64[] = [\n  0xA2F9836E4E441529,\n  0xFC2757D1F534DDC0,\n  0xDB6295993C439041,\n  0xFE5163ABDEBBC561\n];\n\n/** @internal */\nfunction Rf(z: f32): f32 { // Rational approximation of (asin(x)-x)/x^3\n  const                    // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f32>(0x3E2AAA75), //  1.6666586697e-01f\n    pS1 = reinterpret<f32>(0xBD2F13BA), // -4.2743422091e-02f\n    pS2 = reinterpret<f32>(0xBC0DD36B), // -8.6563630030e-03f\n    qS1 = reinterpret<f32>(0xBF34E5AE); // -7.0662963390e-01f\n  var p = z * (pS0 + z * (pS1 + z * pS2));\n  var q: f32 = 1 + z * qS1;\n  return p / q;\n}\n\n@inline function expo2f(x: f32): f32 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                                // see: musl/src/math/__expo2f.c\n    k    = <u32>235,\n    kln2 = reinterpret<f32>(0x4322E3BC); // 0x1.45c778p+7f\n  var scale = reinterpret<f32>(<u32>(0x7F + (k >> 1)) << 23);\n  return NativeMathf.exp(x - kln2) * scale * scale;\n}\n\n@inline /** @internal */\nfunction pio2_large_quot(x: f32, u: i32): i32 {       // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const coeff = reinterpret<f64>(0x3BF921FB54442D18); // π * 0x1p-65 = 8.51530395021638647334e-20\n  const bits = PIO2_TABLE;\n\n  var offset = (u >> 23) - 152;\n  var index  = offset >> 6;\n  var shift  = offset & 63;\n\n  var b0 = unchecked(bits[index + 0]);\n  var b1 = unchecked(bits[index + 1]);\n  var lo: u64;\n\n  if (shift > 32) {\n    let b2 = unchecked(bits[index + 2]);\n    lo  = b2 >> (96 - shift);\n    lo |= b1 << (shift - 32);\n  } else {\n    lo = b1 >> (32 - shift);\n  }\n\n  var hi = (b1 >> (64 - shift)) | (b0 << shift);\n  var mantissa: u64 = (u & 0x007FFFFF) | 0x00800000;\n  var product: u64 = mantissa * hi + (mantissa * lo >> 32);\n  var r: i64 = product << 2;\n  var q: i32 = <i32>((product >> 62) + (r >>> 63));\n  rempio2f_y = copysign<f64>(coeff, x) * <f64>r;\n  return q;\n}\n\n@inline /** @internal */\nfunction rempio2f(x: f32, u: u32, sign: i32): i32 {   // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const pi2hi = reinterpret<f64>(0x3FF921FB50000000); // 1.57079631090164184570\n  const pi2lo = reinterpret<f64>(0x3E5110B4611A6263); // 1.58932547735281966916e-8\n  const _2_pi = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  if (u < 0x4DC90FDB) { /* π * 0x1p28 */\n    let q = nearest(x * _2_pi);\n    rempio2f_y = x - q * pi2hi - q * pi2lo;\n    return <i32>q;\n  }\n\n  var q = pio2_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n/* |sin(x)/x - s(x)| < 2**-37.5 (~[-4.89e-12, 4.824e-12]). */\n@inline /** @internal */\nfunction sin_kernf(x: f64): f32 { // see: musl/tree/src/math/__sindf.c\n  const S1 = reinterpret<f64>(0xBFC5555554CBAC77); // -0x15555554cbac77.0p-55\n  const S2 = reinterpret<f64>(0x3F811110896EFBB2); //  0x111110896efbb2.0p-59\n  const S3 = reinterpret<f64>(0xBF2A00F9E2CAE774); // -0x1a00f9e2cae774.0p-65\n  const S4 = reinterpret<f64>(0x3EC6CD878C3B46A7); //  0x16cd878c3b46a7.0p-71\n\n  var z = x * x;\n  var w = z * z;\n  var r = S3 + z * S4;\n  var s = z * x;\n  return <f32>((x + s * (S1 + z * S2)) + s * w * r);\n}\n\n/* |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]). */\n@inline /** @internal */\nfunction cos_kernf(x: f64): f32 { // see: musl/tree/src/math/__cosdf.c\n  const C0 = reinterpret<f64>(0xBFDFFFFFFD0C5E81); // -0x1ffffffd0c5e81.0p-54\n  const C1 = reinterpret<f64>(0x3FA55553E1053A42); //  0x155553e1053a42.0p-57\n  const C2 = reinterpret<f64>(0xBF56C087E80F1E27); // -0x16c087e80f1e27.0p-62\n  const C3 = reinterpret<f64>(0x3EF99342E0EE5069); //  0x199342e0ee5069.0p-68\n\n  var z = x * x;\n  var w = z * z;\n  var r = C2 + z * C3;\n  return <f32>(((1 + z * C0) + w * C1) + (w * z) * r);\n}\n\n/* |tan(x)/x - t(x)| < 2**-25.5 (~[-2e-08, 2e-08]). */\n@inline /** @internal */\nfunction tan_kernf(x: f64, odd: i32): f32 { // see: musl/tree/src/math/__tandf.c\n\n  const T0 = reinterpret<f64>(0x3FD5554D3418C99F); /* 0x15554d3418c99f.0p-54 */\n  const T1 = reinterpret<f64>(0x3FC112FD38999F72); /* 0x1112fd38999f72.0p-55 */\n  const T2 = reinterpret<f64>(0x3FAB54C91D865AFE); /* 0x1b54c91d865afe.0p-57 */\n  const T3 = reinterpret<f64>(0x3F991DF3908C33CE); /* 0x191df3908c33ce.0p-58 */\n  const T4 = reinterpret<f64>(0x3F685DADFCECF44E); /* 0x185dadfcecf44e.0p-61 */\n  const T5 = reinterpret<f64>(0x3F8362B9BF971BCD); /* 0x1362b9bf971bcd.0p-59 */\n\n  var z = x * x;\n  var r = T4 + z * T5;\n  var t = T2 + z * T3;\n  var w = z * z;\n  var s = z * x;\n  var u = T0 + z * T1;\n\n  r = (x + s * u) + (s * w) * (t + w * r);\n  return <f32>(odd ? -1 / r : r);\n}\n\nexport namespace NativeMathf {\n\n  @lazy export const E       = <f32>NativeMath.E;\n  @lazy export const LN2     = <f32>NativeMath.LN2;\n  @lazy export const LN10    = <f32>NativeMath.LN10;\n  @lazy export const LOG2E   = <f32>NativeMath.LOG2E;\n  @lazy export const LOG10E  = <f32>NativeMath.LOG10E;\n  @lazy export const PI      = <f32>NativeMath.PI;\n  @lazy export const SQRT1_2 = <f32>NativeMath.SQRT1_2;\n  @lazy export const SQRT2   = <f32>NativeMath.SQRT2;\n\n  /** Used as return values from Mathf.sincos */\n  @lazy export var sincos_sin: f32 = 0;\n  @lazy export var sincos_cos: f32 = 0;\n\n  @inline\n  export function abs(x: f32): f32 {\n    return builtin_abs<f32>(x);\n  }\n\n  export function acos(x: f32): f32 { // see: musl/src/math/acosf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f32>(0x3FC90FDA), // 1.5707962513e+00f\n      pio2_lo   = reinterpret<f32>(0x33A22168), // 7.5497894159e-08f\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var hx = reinterpret<u32>(x);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3F800000) {\n      if (ix == 0x3F800000) {\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3F000000) {\n      if (ix <= 0x32800000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * Rf(x * x)));\n    }\n    var z: f32, w: f32, s: f32;\n    if (hx >> 31) {\n      // z = (1 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f32>(z);\n      w = Rf(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f32>(z);\n    hx = reinterpret<u32>(s);\n    var df = reinterpret<f32>(hx & 0xFFFFF000);\n    var c = (z - df * df) / (s + df);\n    w = Rf(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f32): f32 { // see: musl/src/math/acoshf.c\n    const s = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    var u = reinterpret<u32>(x);\n    var a = u & 0x7FFFFFFF;\n    if (a < 0x3F800000 + (1 << 23)) {\n      let xm1 = x - 1;\n      return log1p(xm1 + builtin_sqrt(xm1 * (xm1 + 2)));\n    }\n    if (a < 0x3F800000 + (12 << 23)) return log(2 * x - 1 / (x + builtin_sqrt<f32>(x * x - 1)));\n    return log(x) + s;\n  }\n\n  export function asin(x: f32): f32 { // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2      = reinterpret<f32>(0x3FC90FDB), // 1.570796326794896558e+00f\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var sx = x;\n    var hx = reinterpret<u32>(x) & 0x7FFFFFFF;\n    if (hx >= 0x3F800000) {\n      if (hx == 0x3F800000) return x * pio2 + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (hx < 0x3F000000) {\n      if (hx < 0x39800000 && hx >= 0x00800000) return x;\n      return x + x * Rf(x * x);\n    }\n    // var z: f32 = (1 - builtin_abs<f32>(x)) * 0.5;\n    var z: f32 = 0.5 - builtin_abs<f32>(x) * 0.5;\n    var s = builtin_sqrt<f64>(z); // sic\n    x = <f32>(pio2 - 2 * (s + s * Rf(z)));\n    return builtin_copysign(x, sx);\n  }\n\n  export function asinh(x: f32): f32 { // see: musl/src/math/asinhf.c\n    const c = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    var u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    var y = reinterpret<f32>(u);\n    if (u >= 0x3F800000 + (12 << 23)) y = log(y) + c;\n    else if (u >= 0x3F800000 + (1 << 23))  y =   log(2 * y + 1 / (builtin_sqrt<f32>(y * y + 1) + y));\n    else if (u >= 0x3F800000 - (12 << 23)) y = log1p(y + y * y / (builtin_sqrt<f32>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f32): f32 { // see: musl/src/math/atanf.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f32>(0x3EED6338), //  4.6364760399e-01f\n      atanhi1   = reinterpret<f32>(0x3F490FDA), //  7.8539812565e-01f\n      atanhi2   = reinterpret<f32>(0x3F7B985E), //  9.8279368877e-01f\n      atanhi3   = reinterpret<f32>(0x3FC90FDA), //  1.5707962513e+00f\n      atanlo0   = reinterpret<f32>(0x31AC3769), //  5.0121582440e-09f\n      atanlo1   = reinterpret<f32>(0x33222168), //  3.7748947079e-08f\n      atanlo2   = reinterpret<f32>(0x33140FB4), //  3.4473217170e-08f\n      atanlo3   = reinterpret<f32>(0x33A22168), //  7.5497894159e-08f\n      aT0       = reinterpret<f32>(0x3EAAAAA9), //  3.3333328366e-01f\n      aT1       = reinterpret<f32>(0xBE4CCA98), // -1.9999158382e-01f\n      aT2       = reinterpret<f32>(0x3E11F50D), //  1.4253635705e-01f\n      aT3       = reinterpret<f32>(0xBDDA1247), // -1.0648017377e-01f\n      aT4       = reinterpret<f32>(0x3D7CAC25), //  6.1687607318e-02f\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var ix = reinterpret<u32>(x);\n    var sx = x;\n    ix &= 0x7FFFFFFF;\n    var z: f32;\n    if (ix >= 0x4C800000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign(z, sx);\n    }\n    var id: i32;\n    if (ix < 0x3EE00000) {\n      if (ix < 0x39800000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f32>(x);\n      if (ix < 0x3F980000) {\n        if (ix < 0x3F300000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x401C0000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    var w = z * z;\n    var s1 = z * (aT0 + w * (aT2 + w * aT4));\n    var s2 = w * (aT1 + w * aT3);\n    var s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign(z, sx);\n  }\n\n  export function atanh(x: f32): f32 { // see: musl/src/math/atanhf.c\n    var u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    var y = reinterpret<f32>(u);\n    if (u < 0x3F800000 - (1 << 23)) {\n      if (u >= 0x3F800000 - (32 << 23)) y = 0.5 * log1p(2 * y * (1.0 + y / (1 - y)));\n    } else y = 0.5 * log1p(2 * (y / (1 - y)));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan2(y: f32, x: f32): f32 { // see: musl/src/math/atan2f.c and SUN COPYRIGHT NOTICE above\n    const\n      pi    = reinterpret<f32>(0x40490FDB), //  3.1415927410e+00f\n      pi_lo = reinterpret<f32>(0xB3BBBD2E); // -8.7422776573e-08f\n    if (isNaN(x) || isNaN(y)) return x + y;\n    var ix = reinterpret<u32>(x);\n    var iy = reinterpret<u32>(y);\n    if (ix == 0x3F800000) return atan(y);\n    var m = <u32>(((iy >> 31) & 1) | ((ix >> 30) & 2));\n    ix &= 0x7FFFFFFF;\n    iy &= 0x7FFFFFFF;\n    if (iy == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  pi;\n        case 3: return -pi;\n      }\n    }\n    if (ix == 0) return m & 1 ? -pi / 2 : pi / 2;\n    if (ix == 0x7F800000) {\n      if (iy == 0x7F800000) {\n        switch (m) {\n          case 0: return  pi / 4;\n          case 1: return -pi / 4;\n          case 2: return  3 * pi / 4;\n          case 3: return -3 * pi / 4;\n        }\n      } else {\n        switch (m) {\n          case 0: return  0;\n          case 1: return -0;\n          case 2: return  pi;\n          case 3: return -pi;\n        }\n      }\n    }\n    if (ix + (26 << 23) < iy || iy == 0x7F800000) return m & 1 ? -pi / 2 : pi / 2;\n    var z: f32;\n    if ((m & 2) && iy + (26 << 23) < ix) z = 0.0;\n    else z = atan(builtin_abs<f32>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return pi - (z - pi_lo);\n      case 3: return (z - pi_lo) - pi;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f32): f32 { // see: musl/src/math/cbrtf.c and SUN COPYRIGHT NOTICE above\n    const\n      B1      = <u32>709958130,\n      B2      = <u32>642849266,\n      Ox1p24f = reinterpret<f32>(0x4B800000);\n    var u = reinterpret<u32>(x);\n    var hx = u & 0x7FFFFFFF;\n    if (hx >= 0x7F800000) return x + x;\n    if (hx < 0x00800000) {\n      if (hx == 0) return x;\n      u = reinterpret<u32>(x * Ox1p24f);\n      hx = u & 0x7FFFFFFF;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 0x80000000;\n    u |= hx;\n    var t = <f64>reinterpret<f32>(u);\n    var r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    return <f32>t;\n  }\n\n  @inline\n  export function ceil(x: f32): f32 {\n    return builtin_ceil<f32>(x);\n  }\n\n  export function clz32(x: f32): f32 {\n    if (!isFinite(x)) return 32;\n    return builtin_clz(\n      <i32><i64>(x - 4294967296 * builtin_floor(x * (1.0 / 4294967296)))\n    );\n  }\n\n  export function cos(x: f32): f32 { // see: musl/src/math/cosf.c\n    const c1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // M_PI_2 * 1\n    const c2pio2 = reinterpret<f64>(0x400921FB54442D18); // M_PI_2 * 2\n    const c3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // M_PI_2 * 3\n    const c4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3f490fda) {  /* |x| ~<= π/4 */\n      if (ix < 0x39800000) { /* |x| < 2**-12 */\n        /* raise inexact if x != 0 */\n        return 1;\n      }\n      return cos_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407b53d1) {  /* |x| ~<= 5π/4 */\n        if (ix > 0x4016cbe3) { /* |x|  ~> 3π/4 */\n          return -cos_kernf(sign ? x + c2pio2 : x - c2pio2);\n        } else {\n          return sign ? sin_kernf(x + c1pio2) : sin_kernf(c1pio2 - x);\n        }\n      }\n      if (ix <= 0x40e231d5) {  /* |x| ~<= 9π/4 */\n        if (ix > 0x40afeddf) { /* |x|  ~> 7π/4 */\n          return cos_kernf(sign ? x + c4pio2 : x - c4pio2);\n        } else {\n          return sign ? sin_kernf(-x - c3pio2) : sin_kernf(x - c3pio2);\n        }\n      }\n    }\n\n    /* cos(Inf or NaN) is NaN */\n    if (ix >= 0x7f800000) return x - x;\n\n    /* general argument reduction needed */\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n\n    var t = n & 1 ? sin_kernf(y) : cos_kernf(y);\n    return (n + 1) & 2 ? -t : t;\n  }\n\n  export function cosh(x: f32): f32 { // see: musl/src/math/coshf.c\n    var u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    x = reinterpret<f32>(u);\n    if (u < 0x3F317217) {\n      if (u < 0x3F800000 - (12 << 23)) return 1;\n      let t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (u < 0x42B17217) {\n      let t = exp(x);\n      // return 0.5 * (t + 1 / t);\n      return 0.5 * t + 0.5 / t;\n    }\n    return expo2f(x);\n  }\n\n  @inline\n  export function floor(x: f32): f32 {\n    return builtin_floor<f32>(x);\n  }\n\n  export function exp(x: f32): f32 { // see: musl/src/math/expf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2hi    = reinterpret<f32>(0x3F317200), //  6.9314575195e-1f\n      ln2lo    = reinterpret<f32>(0x35BFBE8E), //  1.4286067653e-6f\n      invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+0f\n      P1       = reinterpret<f32>(0x3E2AAA8F), //  1.6666625440e-1f\n      P2       = reinterpret<f32>(0xBB355215), // -2.7667332906e-3f\n      Ox1p127f = reinterpret<f32>(0x7F000000);\n    var hx = reinterpret<u32>(x);\n    var sign_ = <i32>(hx >> 31);\n    hx &= 0x7FFFFFFF;\n    if (hx >= 0x42AEAC50) {\n      if (hx >= 0x42B17218) {\n        if (!sign_) return x * Ox1p127f;\n        else if (hx >= 0x42CFF1B5) return 0;\n      }\n    }\n    var hi: f32, lo: f32;\n    var k: i32;\n    if (hx > 0x3EB17218) {\n      if (hx > 0x3F851592) {\n        k = <i32>(invln2 * x + builtin_copysign<f32>(0.5, x));\n      } else {\n        k = 1 - (sign_ << 1);\n      }\n      hi = x - <f32>k * ln2hi;\n      lo = <f32>k * ln2lo;\n      x = hi - lo;\n    } else if (hx > 0x39000000) {\n      k = 0;\n      hi = x;\n      lo = 0;\n    } else {\n      return 1 + x;\n    }\n    var xx = x * x;\n    var c = x - xx * (P1 + xx * P2);\n    var y: f32 = 1 + (x * c / (2 - c) - lo + hi);\n    if (k == 0) return y;\n    return scalbn(y, k);\n  }\n\n  export function expm1(x: f32): f32 { // see: musl/src/math/expm1f.c and SUN COPYRIGHT NOTICE above\n    const\n      o_threshold = reinterpret<f32>(0x42B17180), //  8.8721679688e+01f\n      ln2_hi      = reinterpret<f32>(0x3F317180), //  6.9313812256e-01f\n      ln2_lo      = reinterpret<f32>(0x3717F7D1), //  9.0580006145e-06f\n      invln2      = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00f\n      Q1          = reinterpret<f32>(0xBD088868), // -3.3333212137e-02f\n      Q2          = reinterpret<f32>(0x3ACF3010), //  1.5807170421e-03f\n      Ox1p127f    = reinterpret<f32>(0x7F000000);\n    var u = reinterpret<u32>(x);\n    var hx = u & 0x7FFFFFFF;\n    var sign_ = <i32>(u >> 31);\n    if (hx >= 0x4195B844) {\n      if (hx > 0x7F800000) return x;\n      if (sign_) return -1;\n      if (x > o_threshold) {\n        x *= Ox1p127f;\n        return x;\n      }\n    }\n    var c: f32 = 0.0, t: f32, k: i32;\n    if (hx > 0x3EB17218) {\n      k = select<i32>(\n        1 - (sign_ << 1),\n        <i32>(invln2 * x + builtin_copysign<f32>(0.5, x)),\n        hx < 0x3F851592\n      );\n      t = <f32>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x33000000) {\n      return x;\n    } else k = 0;\n    var hfx: f32 = 0.5 * x;\n    var hxs: f32 = x * hfx;\n    var r1: f32 = 1.0 + hxs * (Q1 + hxs * Q2);\n    t  = 3.0 - r1 * hfx;\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e  = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x7F + k) << 23;\n    var twopk = reinterpret<f32>(u);\n    var y: f32;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 128) y = y * 2.0 * Ox1p127f;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x7F - k) << 23;\n    y = reinterpret<f32>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  @inline\n  export function fround(x: f32): f32 {\n    return x;\n  }\n\n  export function hypot(x: f32, y: f32): f32 { // see: musl/src/math/hypotf.c\n    const\n      Ox1p90f  = reinterpret<f32>(0x6C800000),\n      Ox1p_90f = reinterpret<f32>(0x12800000);\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    ux &= 0x7FFFFFFF;\n    uy &= 0x7FFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    x = reinterpret<f32>(ux);\n    y = reinterpret<f32>(uy);\n    if (uy == 0xFF << 23) return y;\n    if (ux >= 0xFF << 23 || uy == 0 || ux - uy >= 25 << 23) return x + y;\n    var z: f32 = 1;\n    if (ux >= (0x7F + 60) << 23) {\n      z  = Ox1p90f;\n      x *= Ox1p_90f;\n      y *= Ox1p_90f;\n    } else if (uy < (0x7F - 60) << 23) {\n      z  = Ox1p_90f;\n      x *= Ox1p90f;\n      y *= Ox1p90f;\n    }\n    return z * builtin_sqrt<f32>(<f32>(<f64>x * x + <f64>y * y));\n  }\n\n  @inline\n  export function imul(x: f32, y: f32): f32 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    const inv32 = 1.0 / 4294967296;\n    return (\n      <i32><i64>(x - 4294967296 * builtin_floor(x * inv32)) *\n      <i32><i64>(y - 4294967296 * builtin_floor(y * inv32))\n    );\n  }\n\n  export function log(x: f32): f32 { // see: musl/src/math/logf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi  = reinterpret<f32>(0x3F317180), // 6.9313812256e-01f\n      ln2_lo  = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06f\n      Lg1     = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f\n      Lg2     = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f\n      Lg3     = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f\n      Lg4     = reinterpret<f32>(0x3E789E26), // 0xf89e26.0p-26f\n      Ox1p25f = reinterpret<f32>(0x4C000000);\n    var u = reinterpret<u32>(x);\n    var k = 0;\n    if (u < 0x00800000 || <bool>(u >> 31)) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (u >> 31) return (x - x) / 0;\n      k -= 25;\n      x *= Ox1p25f;\n      u = reinterpret<u32>(x);\n    } else if (u >= 0x7F800000) return x;\n      else if (u == 0x3F800000) return 0;\n    u += 0x3F800000 - 0x3F3504F3;\n    k += <u32>(<i32>u >> 23) - 0x7F;\n    u = (u & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(u);\n    var f = x - 1.0;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq = <f32>0.5 * f * f;\n    var dk = <f32>k;\n    return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log10(x: f32): f32 { // see: musl/src/math/log10f.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f32>(0x3EDE6000), //  4.3432617188e-01f\n      ivln10lo  = reinterpret<f32>(0xB804EAD9), // -3.1689971365e-05f\n      log10_2hi = reinterpret<f32>(0x3E9A2080), //  3.0102920532e-01f\n      log10_2lo = reinterpret<f32>(0x355427DB), //  7.9034151668e-07f\n      Lg1       = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2       = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n      Lg3       = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n      Lg4       = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n      Ox1p25f   = reinterpret<f32>(0x4C000000);\n    var ix = reinterpret<u32>(x);\n    var k = 0;\n    if (ix < 0x00800000 || <bool>(ix >> 31)) {\n      if (ix << 1 == 0) return -1 / (x * x);\n      if (ix >> 31) return (x - x) / 0.0;\n      k -= 25;\n      x *= Ox1p25f;\n      ix = reinterpret<u32>(x);\n    } else if (ix >= 0x7F800000) return x;\n      else if (ix == 0x3F800000) return 0;\n    ix += 0x3F800000 - 0x3F3504F3;\n    k += <i32>(ix >> 23) - 0x7F;\n    ix = (ix & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(ix);\n    var f = x - 1.0;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq: f32 = 0.5 * f * f;\n    var hi = f - hfsq;\n    ix = reinterpret<u32>(hi);\n    ix &= 0xFFFFF000;\n    hi = reinterpret<f32>(ix);\n    var lo = f - hi - hfsq + s * (hfsq + r);\n    var dk = <f32>k;\n    return dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi + hi * ivln10hi + dk * log10_2hi;\n  }\n\n  export function log1p(x: f32): f32 { // see: musl/src/math/log1pf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f32>(0x3F317180), // 6.9313812256e-01\n      ln2_lo = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06\n      Lg1    = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2    = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f, 0.40000972152f\n      Lg3    = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f, 0.28498786688f\n      Lg4    = reinterpret<f32>(0x3E789E26); // 0xf89e26.0p-26f, 0.24279078841f\n    var ix = reinterpret<u32>(x);\n    var c: f32 = 0, f: f32 = 0;\n    var k: i32 = 1;\n    if (ix < 0x3ED413D0 || <bool>(ix >> 31)) {\n      if (ix >= 0xBF800000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (ix << 1 < 0x33800000 << 1) return x;\n      if (ix <= 0xBE95F619) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (ix >= 0x7F800000) return x;\n    if (k) {\n      let uf: f32 = 1 + x;\n      let iu = reinterpret<u32>(uf);\n      iu += 0x3F800000 - 0x3F3504F3;\n      k = <i32>(iu >> 23) - 0x7F;\n      if (k < 25) {\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      iu = (iu & 0x007FFFFF) + 0x3F3504F3;\n      f = reinterpret<f32>(iu) - 1;\n    }\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq: f32 = 0.5 * f * f;\n    var dk = <f32>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f32): f32 { // see: musl/src/math/log2f.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln2hi = reinterpret<f32>(0x3FB8B000), //  1.4428710938e+00f\n      ivln2lo = reinterpret<f32>(0xB9389AD4), // -1.7605285393e-04\n      Lg1     = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2     = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n      Lg3     = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n      Lg4     = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n      Ox1p25f = reinterpret<f32>(0x4C000000);\n    var ix = reinterpret<u32>(x);\n    var k: i32 = 0;\n    if (ix < 0x00800000 || <bool>(ix >> 31)) {\n      if (ix << 1 == 0) return -1 / (x * x);\n      if (ix >> 31) return (x - x) / 0.0;\n      k -= 25;\n      x *= Ox1p25f;\n      ix = reinterpret<u32>(x);\n    } else if (ix >= 0x7F800000) return x;\n      else if (ix == 0x3F800000) return 0;\n    ix += 0x3F800000 - 0x3F3504F3;\n    k += <i32>(ix >> 23) - 0x7F;\n    ix = (ix & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(ix);\n    var f = x - 1.0;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq: f32 = 0.5 * f * f;\n    var hi = f - hfsq;\n    var u = reinterpret<u32>(hi);\n    u &= 0xFFFFF000;\n    hi = reinterpret<f32>(u);\n    var lo: f32 = f - hi - hfsq + s * (hfsq + r);\n    var dk = <f32>k;\n    return (lo + hi) * ivln2lo + lo * ivln2hi + hi * ivln2hi + dk;\n  }\n\n  @inline\n  export function max(value1: f32, value2: f32): f32 {\n    return builtin_max<f32>(value1, value2);\n  }\n\n  @inline\n  export function min(value1: f32, value2: f32): f32 {\n    return builtin_min<f32>(value1, value2);\n  }\n\n  export function pow(x: f32, y: f32): f32 { // see: musl/src/math/powf.c and SUN COPYRIGHT NOTICE above\n    const\n      dp_h1   = reinterpret<f32>(0x3F15C000), //  5.84960938e-01f\n      dp_l1   = reinterpret<f32>(0x35D1CFDC), //  1.56322085e-06f\n      two24   = reinterpret<f32>(0x4B800000), //  16777216f\n      huge    = reinterpret<f32>(0x7149F2CA), //  1.0e+30f\n      tiny    = reinterpret<f32>(0x0DA24260), //  1.0e-30f\n      L1      = reinterpret<f32>(0x3F19999A), //  6.0000002384e-01f\n      L2      = reinterpret<f32>(0x3EDB6DB7), //  4.2857143283e-01f\n      L3      = reinterpret<f32>(0x3EAAAAAB), //  3.3333334327e-01f\n      L4      = reinterpret<f32>(0x3E8BA305), //  2.7272811532e-01f\n      L5      = reinterpret<f32>(0x3E6C3255), //  2.3066075146e-01f\n      L6      = reinterpret<f32>(0x3E53F142), //  2.0697501302e-01f\n      P1      = reinterpret<f32>(0x3E2AAAAB), //  1.6666667163e-01f\n      P2      = reinterpret<f32>(0xBB360B61), // -2.7777778450e-03f\n      P3      = reinterpret<f32>(0x388AB355), //  6.6137559770e-05f\n      P4      = reinterpret<f32>(0xB5DDEA0E), // -1.6533901999e-06f\n      P5      = reinterpret<f32>(0x3331BB4C), //  4.1381369442e-08f\n      lg2     = reinterpret<f32>(0x3F317218), //  6.9314718246e-01f\n      lg2_h   = reinterpret<f32>(0x3F317200), //  6.93145752e-01f\n      lg2_l   = reinterpret<f32>(0x35BFBE8C), //  1.42860654e-06f\n      ovt     = reinterpret<f32>(0x3338AA3C), //  4.2995665694e-08f\n      cp      = reinterpret<f32>(0x3F76384F), //  9.6179670095e-01\n      cp_h    = reinterpret<f32>(0x3F764000), //  9.6191406250e-01\n      cp_l    = reinterpret<f32>(0xB8F623C6), // -1.1736857402e-04\n      ivln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00\n      ivln2_h = reinterpret<f32>(0x3FB8AA00), //  1.4426879883e+00\n      ivln2_l = reinterpret<f32>(0x36ECA570), //  7.0526075433e-06\n      inv3    = reinterpret<f32>(0x3EAAAAAB);  // 0.333333333333\n    var hx = reinterpret<i32>(x);\n    var hy = reinterpret<i32>(y);\n    var ix = hx & 0x7FFFFFFF;\n    var iy = hy & 0x7FFFFFFF;\n    if (iy == 0) return 1.0; // x**0 = 1, even if x is NaN\n    // if (hx == 0x3F800000) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\n    if (ix > 0x7F800000 || iy > 0x7F800000) return x + y; // NaN if either arg is NaN\n    var yisint  = 0, j: i32, k: i32;\n    if (hx < 0) {\n      if (iy >= 0x4B800000) yisint = 2;\n      else if (iy >= 0x3F800000) {\n        k = (iy >> 23) - 0x7F;\n        let ki = 23 - k;\n        j = iy >> ki;\n        if ((j << ki) == iy) yisint = 2 - (j & 1);\n      }\n    }\n    if (iy == 0x7F800000) { // y is +-inf\n      if (ix == 0x3F800000) return NaN; // C: (-1)**+-inf is 1, JS: NaN\n      else if (ix > 0x3F800000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\n      else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\n    }\n    if (iy == 0x3F800000) return hy >= 0 ? x : 1.0 / x;\n    if (hy == 0x40000000) return x * x;\n    if (hy == 0x3F000000) {\n      if (hx >= 0) return builtin_sqrt<f32>(x);\n    }\n    var ax = builtin_abs<f32>(x);\n    var z: f32;\n    if (ix == 0x7F800000 || ix == 0 || ix == 0x3F800000) {\n      z = ax;\n      if (hy < 0) z = 1.0 / z;\n      if (hx < 0) {\n        if (((ix - 0x3F800000) | yisint) == 0) {\n          let d = z - z;\n          z = d / d;\n        }\n        else if (yisint == 1) z = -z;\n      }\n      return z;\n    }\n    var sn = <f32>1.0;\n    if (hx < 0) {\n      if (yisint == 0) {\n        let d = x - x;\n        return d / d;\n      }\n      if (yisint == 1) sn = -1.0;\n    }\n    var t1: f32, t2: f32, r: f32, s: f32, t: f32, u: f32, v: f32, w: f32, p_h: f32, p_l: f32;\n    var n: i32, is: i32;\n    if (iy > 0x4D000000) {\n      if (ix < 0x3F7FFFF8) return hy < 0 ? sn * huge * huge : sn * tiny * tiny;\n      if (ix > 0x3F800007) return hy > 0 ? sn * huge * huge : sn * tiny * tiny;\n      t = ax - 1;\n      w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\n      u = ivln2_h * t;\n      v = t * ivln2_l - w * ivln2;\n      t1 = u + v;\n      is = reinterpret<i32>(t1);\n      t1 = reinterpret<f32>(is & 0xFFFFF000);\n      t2 = v - (t1 - u);\n    } else {\n      let s2: f32, s_h: f32, s_l: f32, t_h: f32, t_l: f32;\n      n = 0;\n      if (ix < 0x00800000) {\n        ax *= two24;\n        n -= 24;\n        ix = reinterpret<i32>(ax);\n      }\n      n += (ix >> 23) - 0x7F;\n      j = ix & 0x007FFFFF;\n      ix = j | 0x3F800000;\n      if (j <= 0x1CC471) k = 0;\n      else if (j < 0x5DB3D7) k = 1;\n      else {\n        k = 0;\n        n += 1;\n        ix -= 0x00800000;\n      }\n      ax = reinterpret<f32>(ix);\n      let bp = select<f32>(1.5, 1.0, k); // k ? 1.5 : 1.0\n      u = ax - bp;\n      v = 1.0 / (ax + bp);\n      s = u * v;\n      s_h = s;\n      is = reinterpret<u32>(s_h);\n      s_h = reinterpret<f32>(is & 0xFFFFF000);\n      is = ((ix >> 1) & 0xFFFFF000) | 0x20000000;\n      t_h = reinterpret<f32>(is + 0x00400000 + (k << 21));\n      t_l = ax - (t_h - bp);\n      s_l = v * ((u - s_h * t_h) - s_h * t_l);\n      s2 = s * s;\n      r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\n      r += s_l * (s_h + s);\n      s2 = s_h * s_h;\n      t_h = 3.0 + s2 + r;\n      is  = reinterpret<u32>(t_h);\n      t_h = reinterpret<f32>(is & 0xFFFFF000);\n      t_l = r - ((t_h - 3.0) - s2);\n      u = s_h * t_h;\n      v = s_l * t_h + t_l * s;\n      p_h = u + v;\n      is  = reinterpret<u32>(p_h);\n      p_h = reinterpret<f32>(is & 0xFFFFF000);\n      p_l = v - (p_h - u);\n      let z_h = cp_h * p_h;\n      let dp_l = select<f32>(dp_l1, 0.0, k);\n      let z_l = cp_l * p_h + p_l * cp + dp_l;\n      t = <f32>n;\n      let dp_h = select<f32>(dp_h1, 0.0, k);\n      t1 = (((z_h + z_l) + dp_h) + t);\n      is = reinterpret<u32>(t1);\n      t1 = reinterpret<f32>(is & 0xFFFFF000);\n      t2 = z_l - (((t1 - t) - dp_h) - z_h);\n    }\n    is = reinterpret<u32>(y);\n    var y1 = reinterpret<f32>(is & 0xFFFFF000);\n    p_l = (y - y1) * t1 + y * t2;\n    p_h = y1 * t1;\n    z = p_l + p_h;\n    j = reinterpret<u32>(z);\n    if (j > 0x43000000) {\n      return sn * huge * huge;\n    } else if (j == 0x43000000) {\n      if (p_l + ovt > z - p_h) return sn * huge * huge;\n    } else if ((j & 0x7FFFFFFF) > 0x43160000) {\n      return sn * tiny * tiny;\n    } else if (j == 0xC3160000) {\n      if (p_l <= z - p_h) return sn * tiny * tiny;\n    }\n    var i = j & 0x7FFFFFFF;\n    k = (i >> 23) - 0x7F;\n    n = 0;\n    if (i > 0x3F000000) {\n      n = j + (0x00800000 >> (k + 1));\n      k = ((n & 0x7FFFFFFF) >> 23) - 0x7F;\n      t = reinterpret<f32>(n & ~(0x007FFFFF >> k));\n      n = ((n & 0x007FFFFF) | 0x00800000) >> (23 - k);\n      if (j < 0) n = -n;\n      p_h -= t;\n    }\n    t = p_l + p_h;\n    is = reinterpret<u32>(t);\n    t = reinterpret<f32>(is & 0xFFFF8000);\n    u = t * lg2_h;\n    v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\n    z = u + v;\n    w = v - (z - u);\n    t = z * z;\n    t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\n    r = (z * t1) / (t1 - 2.0) - (w + z * w);\n    z = 1.0 - (r - z);\n    j = reinterpret<u32>(z);\n    j += n << 23;\n    if ((j >> 23) <= 0) z = scalbn(z, n);\n    else z = reinterpret<f32>(j);\n    return sn * z;\n  }\n\n  @inline\n  export function seedRandom(value: i64): void {\n    NativeMath.seedRandom(value);\n  }\n\n  // Using xoroshiro64starstar from http://xoshiro.di.unimi.it/xoroshiro64starstar.c\n  export function random(): f32 {\n    if (!random_seeded) throw new Error(\"PRNG must be seeded.\");\n\n    var s0 = random_state0_32;\n    var s1 = random_state1_32;\n    var r  = rotl<u32>(s0 * 0x9E3779BB, 5) * 5;\n\n    s1 ^= s0;\n    random_state0_32 = rotl<u32>(s0, 26) ^ s1 ^ (s1 << 9);\n    random_state1_32 = rotl<u32>(s1, 13);\n\n    return reinterpret<f32>((r >> 9) | (127 << 23)) - 1.0;\n  }\n\n  @inline\n  export function round(x: f32): f32 {\n    return builtin_copysign<f32>(builtin_floor<f32>(x + 0.5), x);\n  }\n\n  @inline\n  export function sign(x: f32): f32 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_abs(x) > 0 ? builtin_copysign<f32>(1, x) : x;\n    } else {\n      return x > 0 ? 1 : x < 0 ? -1 : x;\n    }\n  }\n\n  @inline\n  export function signbit(x: f32): bool {\n    return <bool>((reinterpret<u32>(x) >>> 31) & (x == x));\n  }\n\n  export function sin(x: f32): f32 { // see: musl/src/math/sinf.c\n    const s1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // M_PI_2 * 1\n    const s2pio2 = reinterpret<f64>(0x400921FB54442D18); // M_PI_2 * 2\n    const s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // M_PI_2 * 3\n    const s4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3f490fda) {  /* |x| ~<= π/4 */\n      if (ix < 0x39800000) { /* |x| < 2**-12 */\n        return x;\n      }\n      return sin_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407b53d1) {   /* |x| ~<= 5π/4 */\n        if (ix <= 0x4016cbe3) { /* |x| ~<= 3π/4 */\n          return sign ? -cos_kernf(x + s1pio2) : cos_kernf(x - s1pio2);\n        }\n        return sin_kernf(-(sign ? x + s2pio2 : x - s2pio2));\n      }\n\n      if (ix <= 0x40e231d5) {   /* |x| ~<= 9π/4 */\n        if (ix <= 0x40afeddf) { /* |x| ~<= 7π/4 */\n          return sign ? cos_kernf(x + s3pio2) : -cos_kernf(x - s3pio2);\n        }\n        return sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n      }\n    }\n\n    /* sin(Inf or NaN) is NaN */\n    if (ix >= 0x7f800000) return x - x;\n\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n\n    var t = n & 1 ? cos_kernf(y) : sin_kernf(y);\n    return n & 2 ? -t : t;\n  }\n\n  export function sinh(x: f32): f32 { // see: musl/src/math/sinhf.c\n    var u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    var absx = reinterpret<f32>(u);\n    var t: f32;\n    var h = builtin_copysign<f32>(0.5, x);\n    if (u < 0x42B17217) {\n      t = expm1(absx);\n      if (u < 0x3F800000) {\n        if (u < 0x3F800000 - (12 << 23)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    t = 2 * h * expo2f(absx);\n    return t;\n  }\n\n  @inline\n  export function sqrt(x: f32): f32 {\n    return builtin_sqrt<f32>(x);\n  }\n\n  export function tan(x: f32): f32 { // see: musl/src/math/tanf.c\n    const t1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // 1 * M_PI_2\n    const t2pio2 = reinterpret<f64>(0x400921FB54442D18); // 2 * M_PI_2\n    const t3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // 3 * M_PI_2\n    const t4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3f490fda) {  /* |x| ~<= π/4 */\n      if (ix < 0x39800000) { /* |x| < 2**-12 */\n        return x;\n      }\n      return tan_kernf(x, 0);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407b53d1) {   /* |x| ~<= 5π/4 */\n        if (ix <= 0x4016cbe3) { /* |x| ~<= 3π/4 */\n          return tan_kernf((sign ? x + t1pio2 : x - t1pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t2pio2 : x - t2pio2), 0);\n        }\n      }\n      if (ix <= 0x40e231d5) {   /* |x| ~<= 9π/4 */\n        if (ix <= 0x40afeddf) { /* |x| ~<= 7π/4 */\n          return tan_kernf((sign ? x + t3pio2 : x - t3pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t4pio2 : x - t4pio2), 0);\n        }\n      }\n    }\n\n    /* tan(Inf or NaN) is NaN */\n    if (ix >= 0x7f800000) return x - x;\n\n    /* argument reduction */\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n    return tan_kernf(y, n & 1);\n  }\n\n  export function tanh(x: f32): f32 { // see: musl/src/math/tanhf.c\n    var u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    var y = reinterpret<f32>(u);\n    var t: f32;\n    if (u > 0x3F0C9F54) {\n      if (u > 0x41200000) t = 1 + 0 / y;\n      else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (u > 0x3E82C578) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (u >= 0x00800000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f32>(t, x);\n  }\n\n  @inline\n  export function trunc(x: f32): f32 {\n    return builtin_trunc<f32>(x);\n  }\n\n  export function scalbn(x: f32, n: i32): f32 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbnf.c\n    const\n      Ox1p24f   = reinterpret<f32>(0x4B800000),\n      Ox1p127f  = reinterpret<f32>(0x7F000000),\n      Ox1p_126f = reinterpret<f32>(0x00800000);\n    var y = x;\n    if (n > 127) {\n      y *= Ox1p127f;\n      n -= 127;\n      if (n > 127) {\n        y *= Ox1p127f;\n        n = builtin_min<i32>(n - 127, 127);\n      }\n    } else if (n < -126) {\n      y *= Ox1p_126f * Ox1p24f;\n      n += 126 - 24;\n      if (n < -126) {\n        y *= Ox1p_126f * Ox1p24f;\n        n = builtin_max<i32>(n + 126 - 24, -126);\n      }\n    }\n    return y * reinterpret<f32>(<u32>(0x7F + n) << 23);\n  }\n\n  export function mod(x: f32, y: f32): f32 { // see: musl/src/math/fmodf.c\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    var ex = <i32>(ux >> 23 & 0xFF);\n    var ey = <i32>(uy >> 23 & 0xFF);\n    var sx = ux & 0x80000000;\n    var uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0xFF || isNaN<f32>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    var ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      if (ux1 == uy1) return 0 * x;\n      return x;\n    }\n    if (!ex) {\n      ex -= builtin_clz<u32>(ux << 9);\n      ux <<= -ex + 1;\n    } else {\n      ux &= <u32>-1 >> 9;\n      ux |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= -ey + 1;\n    } else {\n      uy &= <u32>-1 >> 9;\n      uy |= 1 << 23;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 23); ux <<= 1) --ex;\n    var shift = <i32>builtin_clz<u32>(ux << 8);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 23;\n      ux |= <u32>ex << 23;\n    } else {\n      ux >>= -ex + 1;\n    }\n    ux |= sx;\n    return reinterpret<f32>(ux);\n  }\n\n  export function rem(x: f32, y: f32): f32 { // see: musl/src/math/remquof.c\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    var ex = <i32>(ux >> 23 & 0xFF);\n    var ey = <i32>(uy >> 23 & 0xFF);\n    var sx = <i32>(ux >> 31);\n    var uxi = ux;\n    if (uy << 1 == 0 || ex == 0xFF || isNaN(y)) return (x * y) / (x * y);\n    if (ux << 1 == 0) return x;\n    if (!ex) {\n      ex -= builtin_clz<u32>(uxi << 9);\n      uxi <<= -ex + 1;\n    } else {\n      uxi &= <u32>-1 >> 9;\n      uxi |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= -ey + 1;\n    } else {\n      uy &= <u32>-1 >> 9;\n      uy |= 1 << 23;\n    }\n    var q = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -30;\n      else {\n        let shift = builtin_clz<i32>(uxi << 8);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n  // end\n    if (ex > 0) {\n      uxi -= 1 << 23;\n      uxi |= <u32>ex << 23;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f32>(uxi);\n    y = builtin_abs<f32>(y);\n    var x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (<f32>x2 > y || (<f32>x2 == y && <bool>(q & 1))))) {\n      x -= y;\n      // q++;\n    }\n    return sx ? -x : x;\n  }\n\n  export function sincos(x: f32): void { // see: musl/tree/src/math/sincosf.c\n    const s1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // 1 * M_PI_2\n    const s2pio2 = reinterpret<f64>(0x400921FB54442D18); // 2 * M_PI_2\n    const s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // 3 * M_PI_2\n    const s4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7fffffff;\n\n    if (ix <= 0x3f490fda) {  /* |x| ~<= π/4 */\n      if (ix < 0x39800000) { /* |x| < 2**-12 */\n        sincos_s32 = x;\n        sincos_c32 = 1;\n        return;\n      }\n      sincos_s32 = sin_kernf(x);\n      sincos_c32 = cos_kernf(x);\n      return;\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407b53d1) {   /* |x| ~<= 5π/4 */\n        if (ix <= 0x4016cbe3) { /* |x| ~<= 3π/4 */\n          if (sign) {\n            sincos_s32 = -cos_kernf(x + s1pio2);\n            sincos_c32 =  sin_kernf(x + s1pio2);\n          } else {\n            sincos_s32 = cos_kernf(s1pio2 - x);\n            sincos_c32 = sin_kernf(s1pio2 - x);\n          }\n          return;\n        }\n        /* -sin(x + c) is not correct if x+c could be 0: -0 vs +0 */\n        sincos_s32 = -sin_kernf(sign ? x + s2pio2 : x - s2pio2);\n        sincos_c32 = -cos_kernf(sign ? x + s2pio2 : x - s2pio2);\n        return;\n      }\n\n      if (ix <= 0x40e231d5) {   /* |x| ~<= 9π/4 */\n        if (ix <= 0x40afeddf) { /* |x| ~<= 7π/4 */\n          if (sign) {\n            sincos_s32 =  cos_kernf(x + s3pio2);\n            sincos_c32 = -sin_kernf(x + s3pio2);\n          } else {\n            sincos_s32 = -cos_kernf(x - s3pio2);\n            sincos_c32 =  sin_kernf(x - s3pio2);\n          }\n          return;\n        }\n        sincos_s32 = sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n        sincos_c32 = cos_kernf(sign ? x + s4pio2 : x - s4pio2);\n        return;\n      }\n    }\n\n    /* sin(Inf or NaN) is NaN */\n    if (ix >= 0x7f800000) {\n      let xx = x - x;\n      sincos_s32 = xx;\n      sincos_c32 = xx;\n      return;\n    }\n\n    /* general argument reduction needed */\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n    var s = sin_kernf(y);\n    var c = cos_kernf(y);\n\n    switch (n & 3) {\n      case 0: {\n        sincos_s32 = s;\n        sincos_c32 = c;\n        break;\n      }\n      case 1: {\n        sincos_s32 =  c;\n        sincos_c32 = -s;\n        break;\n      }\n      case 2: {\n        sincos_s32 = -s;\n        sincos_c32 = -c;\n        break;\n      }\n      case 3:\n      default: {\n        sincos_s32 = -c;\n        sincos_c32 =  s;\n        break;\n      }\n    }\n  }\n}\n\nexport function ipow32(x: i32, e: i32): i32 {\n  var out = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (e < 0) return 0;\n\n    switch (e) {\n      case 0: return 1;\n      case 1: return x;\n      case 2: return x * x;\n    }\n\n    let log = 32 - clz(e);\n    if (log <= 5) {\n      // 32 = 2 ^ 5, so need only five cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 5: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n\n  while (e > 0) {\n    if (e & 1) out *= x;\n    e >>= 1;\n    x *= x;\n  }\n  return out;\n}\n\nexport function ipow64(x: i64, e: i32): i64 {\n  var out: i64 = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (e < 0) return 0;\n    switch (e) {\n      case 0: return 1;\n      case 1: return x;\n      case 2: return x * x;\n    }\n\n    let log = 32 - clz(e);\n    if (log <= 6) {\n      // 64 = 2 ^ 6, so need only six cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 6: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 5: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n\n  while (e > 0) {\n    if (e & 1) out *= x;\n    e >>= 1;\n    x *= x;\n  }\n  return out;\n}\n\nexport function ipow32f(x: f32, e: i32): f32 {\n  var sign = e >> 31;\n  e = (e + sign) ^ sign; // abs(e)\n  var out: f32 = 1;\n  while (e) {\n    out *= select<f32>(x, 1.0, e & 1);\n    e >>= 1;\n    x *= x;\n  }\n  return sign ? <f32>1.0 / out : out;\n}\n\nexport function ipow64f(x: f64, e: i32): f64 {\n  var sign = e >> 31;\n  e = (e + sign) ^ sign; // abs(e)\n  var out = 1.0;\n  while (e) {\n    out *= select(x, 1.0, e & 1);\n    e >>= 1;\n    x *= x;\n  }\n  return sign ? 1.0 / out : out;\n}\n"]}